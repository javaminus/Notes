首先，我们需要问清楚，一天100W次的登录，在一天内有没有某个时段是高峰的？高峰期的QPS大概可以达到多少。 

如果没有高峰期，虽然100万听上去挺多的，但是其实平均下来一秒钟的QPS也就10，这个量的话，其实根本不需要做什么特别的JVM优化。  

一般业务场景中，都是有自己的业务高峰期的，比如电商业务基本上上午十点和下午两点是业务高峰期，基本上这时候的QPS是平时的20倍都不止。  

我们假设登录业务存在高峰期，峰值时长大概持续1个小时，**峰值的QPS可以达到200**。那么需要做哪些优化？ 

> 作为一个登录服务，一般来说我们在接收到请求之后，只需要给用户进行鉴权并把结果返回给前端就行了。在这个过程中一般不太会去查询太多的数据，比如权限什么的也都是在后面访问页面再查询的。所以，峰值200左右的QPS，对于JVM的内存来说，最主要的就是会因为远程调用，而创建出很多请求参数和请求的响应。而这些对象基本都是**朝生暮死**的，接口调用结束之后就会被回收掉。并且通常来说这些对象也不会很大， **因为登录并不是注册，其实并不携带特别多的信息**，那么也就是说，会产生大量的小对象，即新生代会不断的创建对象，并被回收掉。 

基于以上简单分析，我们看下该如何做我们的JVM调优。 

#### 堆内存设置 

首先是堆内存大小的设置。当我们的机器只有4核8G的时候，堆内存的大小肯定不能太大，一般不建议设置的太大，因为我们需要给机器上的其他应用预留出一部分内容。所以，**我们一般建议都是把JVM的堆内存设置成操作系统内存的一半**，也就是4G。至于初始内存和最大内存，我们这场景中建议设置成一样的。这样可以**避免 JVM 在运行过程中频繁进行内存扩容和收缩操作**，**提高应用程序的性能和稳定性**。即：   

```
-Xms4G -Xmx4G
// 配置 java -Xms512m -Xmx2048m -jar yourapp.jar
```



#### 垃圾收集器选择 

在设置了堆空间的总大小之后，我们需要考虑用哪种垃圾收集器。另外，我们前面分析过，**这个业务中会频繁在新生代创建并销毁对象，那么，就意味着新生代的GC会比较频繁。**所以我们需要选择一种在GC过程中**STW时间短**的，并且在年轻代的回收中也能发挥效果的。  

在新生代的垃圾收集器中，主要以Serial、ParNew、Parallel Scavenge以及支持整堆回收的G1了。  **因为新生代采用的都是复制算法，所以不太需要考虑碎片的问题，我们主要考虑吞吐量和STW的时长就行了**。  

首先排除单线程的Serial，剩下ParNew是一个并发的收集器，Parallel Scavenge更加关注吞吐量，而G1作为JDK 9中默认垃圾收集器，他不仅同时具有**低暂停时间**和**高吞吐量**的优点，**但是他对内存有要求，最小要4G，**  

从使用门槛上来说，G1是可以用的，因为一般来说，内存要大于等于4G的话，才适合使用G1进行GC。  

所以，我们采用G1作为垃圾收集器： 

```

-XX：+UseG1GC
```



其次，我们还可以自己调节一些G1的配置，比如设置他的GC线程数，可以先配置4个线程数进行GC，后续根据实际情况再做调整： 

```

-XX:ParallelGCThreads=4       // 设置并行 GC 线程数为 4
-XX:ConcGCThreads=2           // 设置并发 GC 线程数为 2
```



> 并行和并发是计算机领域中常见但容易混淆的两个概念，区别如下：
>
> - 并行：多核 CPU 同时处理多个线程，每个线程占用一个核心。
> - 并发：单核 CPU 快速切换线程，用户感觉多个任务同时进行，但实际上任意时刻只有一个任务真正运行。
>
> ---
>
> **并行（Parallelism）**  
> - 指**同一时刻**有多个任务在多个处理器（或多个核心）上**真正同时执行**。
> - 强调物理上的“同时”，比如多核 CPU 上多个线程各自运行在独立的核心上。
> - 例子：4个 CPU 核心，每个核心同时运行一个任务，这就是并行。
>
> **并发（Concurrency）**  
> - 指**同一时间段**内有多个任务在进行，但不一定是物理上的同时执行，可能是轮流切换（调度）。
> - 强调任务之间“交替进行”，比如单核 CPU 上通过任务切换让多个任务“看起来”同时进行。
> - 例子：单核 CPU 上多个线程通过时间片轮转，轮流获得执行权，这就是并发。
>
> ---
>
> **一句话区别：**  
> - 并行是“物理同时”，并发是“逻辑同时”。  
> - 并行通常依赖多核或多处理器硬件，并发则更多依赖操作系统调度和程序设计。
>
> ---
>
> **举例说明：**  
> - 并行：多核 CPU 同时处理多个线程，每个线程占用一个核心。
> - 并发：单核 CPU 快速切换线程，用户感觉多个任务同时进行，但实际上任意时刻只有一个任务真正运行
>

G1的内存划分是自适应的，它会根据堆的大小和使用情况来动态调整各个区域的大小和比例。但是，我们也可以通过一些JVM参数来手动设置G1的各个分代内存配置。  

G1 中的分代和其他垃圾回收器不太一样，它不是严格按照年轻代和老年代划分的，而是通过划分各个区域的存活对象数量来实现垃圾回收的。因此，G1 中不需要像其他垃圾回收器那样设置新生代和老年代的大小比例，而是需要设置一些区域的内存配置。  

`-XX:G1NewSizePercent` 和 `-XX:G1MaxNewSizePercent`分别用于设置年轻代的初始大小和最大大小，它们的默认值分别为 5% 和 60%。针对我们的业务场景，我们其实可以适当的调高一下年轻代的初始大小，5%的比例太小了，我们可以调整到30%。 

```

-XX:G1HeapRegionSize=2m：将 G1 的区域大小设置为 2MB，以提高垃圾回收的效率和精度。
-XX:G1NewSizePercent=20：设置年轻代的初始大小为堆的 20%。
-XX:G1MaxNewSizePercent=50：设置年轻代的最大大小为堆的 50%。
-XX:G1OldCSetRegionThresholdPercent=10：设置老年代的大小为堆的 10%。
-XX:G1HeapWastePercent=5：设置垃圾回收后留下的未使用区域的最大比例为 5%。
```



####添加必要的日志

因为以上配置都是根据业务大致分析出来的初始配置，所以我们一定是需要不断地调优的，那么必要的日志相关参数就要添加。如： 

```
-XX:MaxGCPauseMillis=100：最大 GC 暂停时间为 100 毫秒，可以根据实际情况调整；
-XX:+HeapDumpOnOutOfMemoryError：当出现内存溢出时，自动生成堆内存快照文件；
-XX:HeapDumpPath=/path/to/heap/dump/file.hprof：堆内存快照文件的存储路径；
-XX:+PrintGC：输出 GC 信息；
-XX:+PrintGCDateStamps：输出 GC 发生时间；
-XX:+PrintGCTimeStamps：输出 GC 发生时 JVM 的运行时间；
-XX:+PrintGCDetails：输出 GC 的详细信息；
-Xlog:gc*:file=/path/to/gc.log:time,uptime:filecount=10,filesize=100M：将 GC 日志输出到指定文件中，可以根据需要调整日志文件路径、数量和大小
```

