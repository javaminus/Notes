# G1 与 CMS 垃圾收集器对比

## G1 简介

- G1 是 JDK 1.9 中的默认垃圾收集器，替代了 Java 8 默认的 Parallel Scavenge GC + Parallel Old GC，以及 CMS。
- G1 基于三色标记法，实现了更低的 STW（Stop The World）时长和可预测的暂停时间。

---

## G1 vs CMS 对比表

| 特性         | CMS                          | G1                                                 |
| ------------ | ---------------------------- | -------------------------------------------------- |
| 回收位置     | 仅老年代                     | 整个堆（年轻代+老年代）                            |
| GC算法       | 标记-清除算法                | 标记-复制算法回收年轻代<br>标记-整理算法回收老年代 |
| 垃圾识别算法 | 三色标记法——增量更新解决漏标 | 三色标记法——原始快照解决漏标                       |
| 碎片产生     | 存在内存碎片                 | 可防止内存碎片产生                                 |
| 可预测性     | 无法预测                     | STW时长可预测                                      |
| 堆内存要求   | 一般要求不高                 | 4G及以上                                           |
| 自适应调优   | 不支持                       | 支持                                               |

---

## G1 的实现特点

- **堆划分**：将 Java 堆分为多个大小相等的 Region（每个 Region 大小为 1M-32M），可灵活调整。
- **年轻代回收**：采用标记-复制算法，避免内存碎片。
- **老年代回收**：采用标记-整理算法，同样避免内存碎片。
- **并行与并发**：标记和清理过程可并行执行，多线程充分利用 CPU，缩短 STW 时长。
- **复制并发**：对象复制过程可与用户线程并发，无需全程 STW。
- **动态调优**：运行时可动态调整各个 Region 的内存大小，自适应优化性能。
- **可预测性**：允许用户设定最大暂停时间，G1 会努力满足。

---

## 总结

G1 通过堆分区、标记-复制/整理算法和并行并发回收方式，显著提升了垃圾回收的效率和可预测性，防止了内存碎片的产生，适合大堆内存和高并发场景，而 CMS 已逐步被 G1 取代。

### **CMS 回收流程**

1. **初始标记（STW）**：标记 GC Roots 直接可达对象
2. **并发标记**：扫描整个堆，标记可达对象
3. **重新标记（STW）**：修正并发标记阶段遗漏的对象
4. **并发清除**：清理不可达对象（不压缩堆，可能造成碎片化）

> 1. **低延迟**
>    - CMS 设计目标就是减少老年代GC的停顿时间（STW），在用户线程和GC线程并发执行的阶段，应用响应更快，适合对延迟敏感的业务场景。
> 2. **实现成熟、稳定**
>    - CMS在Java 6、Java 7、Java 8已经广泛应用，社区和文档资源丰富，很多系统对其调优经验丰富。
> 3. **资源消耗较低**
>    - CMS对堆的基本要求较低，适合内存较小的环境（比如小于4G的堆），而G1更适合大堆。
> 4. **更少的后台资源占用**
>    - CMS的后台线程和辅助内存开销相对较小，适合资源受限的老系统或虚拟机场景。
> 5. **对应用行为的控制更精细**
>    - CMS支持手动触发Full GC，容易根据业务特性做定制化调优。

**缺点**：
 ❌ **容易内存碎片化**，可能导致 Full GC
 ❌ **高并发压力下 STW 仍可能过长**

------

### **G1 回收流程**

1. **全堆分区（Region）**，不再区分老年代和新生代
2. **优先回收垃圾最多的 Region**（"Garbage First"）
3. **阶段性并发标记，预测回收停顿时间**
4. **复制整理，减少碎片化，提升吞吐量**

**优点**：
 ✅ **可控 STW 停顿时间（Predictable Pause Time）**
 ✅ **避免碎片化，适用于大堆内存（6GB+）**
 ✅ **适合高并发、大数据系统**

------

### **如何选择？**

- **CMS**：适用于**低延迟应用（如金融、秒杀）**，但易碎片化，JDK 9 已废弃
- **G1**：适用于**大堆（6GB+）、高并发场景（如大数据、微服务）**，JDK 9+ 默认

🚀 **JDK 11 及以上建议直接使用 G1**，JDK 17 还可考虑 **ZGC / Shenandoah** 低延迟 GC！