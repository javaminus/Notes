## 问题：JVM垃圾回收（GC）的分代模型是什么？各代的回收器如何协同工作？

### 详细解释

JVM的堆内存采用**分代管理**，主要分为**新生代（Young Generation）**、**老年代（Old Generation）**和**元空间/方法区（Metaspace/Method Area）**。分代模型的核心思想是：不同生命周期的对象用不同的回收策略，提高GC效率。

#### 1. 分代内存结构

- **新生代（Young Gen）**  
  存放新创建的对象。分为 Eden 区和两个 Survivor 区（S0、S1）。
- **老年代（Old Gen）**  
  存放从新生代晋升过来的长生命周期对象。
- **元空间（Metaspace，JDK8+）/方法区**  
  存放类元数据、静态变量等，不再属于堆。

#### 2. 垃圾回收器协同工作

- **新生代回收（Minor GC）**  
  采用“复制算法”，通常只回收新生代。对象大多存活时间短，回收频繁但速度快。
- **老年代回收（Major/Full GC）**  
  采用“标记-清除”或“标记-整理”算法。回收老年代，通常伴随新生代的回收，耗时较长。
- **元空间/方法区回收**  
  主要回收废弃的类元数据。

**典型组合：**
- ParNew + CMS
- Parallel Scavenge + Parallel Old
- G1（统一管理新生代、老年代）

#### 3. 对象晋升与回收流程

1. 对象新建于 Eden 区。
2. Minor GC后仍存活，对象进入 Survivor 区。
3. 多次GC后仍存活，晋升到老年代。
4. 老年代空间不足时触发Full GC，回收整个堆。

**示意图：**
```
Eden -> Survivor0 <-> Survivor1 -> Old Gen
```

#### 4. 典型场景与例子

- 高频请求、临时对象（如Web请求参数）往往在新生代分配并很快被回收。
- 长连接、缓存等对象容易晋升到老年代，需关注老年代内存溢出风险。

#### 5. 分代带来的优化好处

- 针对不同对象生命周期采用最优回收算法，提高GC效率。
- 减少Full GC发生频率，提升吞吐量和响应速度。

### 总结性回答/提示词

- JVM分代：新生代（Eden+Survivor）、老年代、元空间
- GC分为Minor GC（新生代）、Full GC（全堆/老年代）
- 对象“熬老”：多次GC后晋升老年代
- 典型回收器组合：ParNew/CMS、Parallel Scavenge/Parallel Old、G1
- 复习提示：**“分代GC分新老，复制算法快，晋升规则定，回收器协同优化效率”**