数据库的事务隔离级别主要有以下四种：

1. 读未提交（Read Uncommitted）
   - 一个事务可以读取另一个尚未提交事务的数据。
   - 可能导致脏读（Dirty Read）。

2. 读已提交（Read Committed）
   - 一个事务只能读取已经被其他事务提交的数据。
   - 可以避免脏读，但可能出现不可重复读（Non-repeatable Read）。

3. 可重复读（Repeatable Read）
   - 在同一个事务内，多次读取同一数据结果一致，除非本事务自己修改。
   - 可以避免脏读和不可重复读，但可能出现幻读（Phantom Read）。

4. 串行化（Serializable）
   - 所有事务串行执行，完全隔离。
   - 可以避免脏读、不可重复读和幻读，但并发性能最低。

**总结表：**

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| -------- | ---- | ---------- | ---- |
| 读未提交 | 可能 | 可能       | 可能 |
| 读已提交 | 否   | 可能       | 可能 |
| 可重复读 | 否   | 否         | 可能 |
| 串行化   | 否   | 否         | 否   |

不同数据库默认隔离级别可能不同，如MySQL的InnoDB默认是“可重复读”，SQL Server默认是“读已提交”。

## 面试官可能深挖的面试题及答案

### 1. 什么是幻读？如何避免幻读？

**答：**
幻读是指在同一个事务中，两次执行相同的查询，返回的结果集不同，通常是因为其他事务插入或删除了满足查询条件的数据行。  
可以通过**串行化（Serializable）**隔离级别避免幻读。在 MySQL 的 InnoDB 引擎中，可重复读通过**间隙锁（Gap Lock）**在一定程度上防止幻读。

---

### 2. 可重复读和串行化的区别是什么？

**答：**
- 可重复读保证同一事务内多次读取同一数据结果一致，但可能出现幻读。
- 串行化隔离级别则通过强制事务串行执行，彻底避免幻读，但并发性能最差。

---

### 3. MySQL 的可重复读是如何实现的？会出现幻读吗？

**答：**
MySQL（InnoDB）通过多版本并发控制（MVCC）和间隙锁（Gap Lock）实现可重复读。  
MVCC 避免了不可重复读；间隙锁可以防止其他事务在范围内插入新记录，从而在大多数情况下避免幻读，但特殊情况下（如非唯一索引），幻读仍可能发生。

---

### 4. 什么是脏读、不可重复读、幻读？举例说明。

**答：**
- **脏读**：事务A读取了事务B尚未提交的数据，B回滚后A读到的数据就是脏数据。
- **不可重复读**：同一事务中两次读取同一行数据，数据内容被其他已提交事务修改。
- **幻读**：同一事务中两次查询返回的记录数不同，通常是因为其他事务插入或删除了新行。

---

### 5. 为什么不直接使用最高隔离级别串行化？

**答：**
串行化虽然能完全避免各种并发问题，但由于所有事务串行执行，性能和并发能力大幅下降，通常只在极端需要强一致性的场景下使用。

---

### 6. 不同数据库的默认隔离级别是什么？如何修改？

**答：**
- MySQL（InnoDB）：默认可重复读（Repeatable Read）
- SQL Server：默认读已提交（Read Committed）
- Oracle：默认读已提交

可以通过 SQL 语句 `SET TRANSACTION ISOLATION LEVEL ...` 修改隔离级别。

---

### 7. 什么是 MVCC？它与事务隔离级别有什么关系？

**答：**
MVCC（多版本并发控制）是一种实现高并发下事务隔离的方法，通常用于实现读已提交和可重复读。通过保存数据的多个版本，使读操作无需加锁即可获得一致性视图，提高并发性能。

---

## 复习提示

- 四大隔离级别、三大并发问题牢牢记
- 默认隔离级别要清楚，MVCC 与锁机制要理解
- 能举例说明各种并发问题
- 能说出每种隔离级别的适用场景与性能影响