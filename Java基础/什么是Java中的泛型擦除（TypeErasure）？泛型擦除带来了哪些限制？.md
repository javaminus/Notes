## 15. 什么是Java中的泛型擦除（Type Erasure）？泛型擦除带来了哪些限制？

### 详细解释

**泛型擦除（Type Erasure）** 是 Java 泛型实现的机制。Java 泛型只存在于编译阶段，编译器在编译时会将泛型类型擦除，替换为原始类型（如 Object 或限定的上界），运行时不会保留任何泛型类型信息。

#### 主要影响和限制
- **运行时获取不到泛型类型信息**，即 `List<String>` 和 `List<Integer>` 在运行时其实是同一个类型。
- **不能直接创建泛型数组**，如 `new T[]` 或 `new List<String>[]` 会报错。
- **不能用 instanceof 判断具体泛型类型**，如 `obj instanceof List<String>` 是非法的。
- **静态变量不能用泛型类型参数**，因为类型参数属于实例，不属于类。

> 这是Java泛型实现中的类型擦除(Type Erasure)机制导致的特性，我来分别解释这些现象的原因：
>
> 1. 运行时获取不到泛型类型信息（类型擦除）：
> - Java泛型在编译后会进行类型擦除，所有泛型类型参数都会被替换为它们的边界类型（通常是Object）
> - 所以List<String>和List<Integer>在运行时都变成原始类型List，类型参数信息丢失
> - 这是为了兼容Java5之前没有泛型的代码
>
> 2. 不能直接创建泛型数组：
> - 数组在创建时需要知道确切的组件类型
> - 由于类型擦除，运行时无法确定T的具体类型，导致new T[]无法通过类型检查
> - 同样，List<String>[]也会因为类型擦除导致数组类型检查失效
>
> 3. 不能用instanceof判断具体泛型类型：
> - instanceof检查是在运行时进行的
> - 由于类型擦除，运行时无法获取List<String>和List<Integer>的区别
> - 只能检查obj instanceof List（原始类型）
>
> 4. 静态变量不能用泛型类型参数：
> - 静态变量属于类而非实例
> - 泛型类型参数是属于实例的（每个实例可以有不同的类型参数）
> - 如果允许静态变量使用类型参数，会导致语义矛盾
>
> 这些限制都是Java泛型实现方式带来的结果，目的是在保证类型安全的同时保持与旧版本Java的兼容性。要绕过这些限制，通常需要显式传递Class对象或使用反射等技术。

**通俗例子：**
```java
List<String> list1 = new ArrayList<>();
List<Integer> list2 = new ArrayList<>();
System.out.println(list1.getClass() == list2.getClass()); // true

// new T[]; // 编译报错
```

#### 应对办法
- 通过传递 Class<T> 参数或使用反射配合类型令牌（TypeToken）等方式规避部分泛型擦除带来的问题。

### 总结性提示词

> Java泛型编译后类型被擦除，运行时无泛型信息，限制了泛型数组、类型判断等操作，常需用Class参数或反射辅助。