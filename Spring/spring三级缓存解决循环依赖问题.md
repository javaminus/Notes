Spring 通过 **三级缓存** 解决循环依赖问题，核心思想是 **提前暴露对象的引用**，允许依赖对象在完整初始化前先获取到一个早期的对象引用。具体来说，Spring 的三级缓存包括：

1. **singletonObjects（一缓存）**：  
   - 存放已经完全初始化的单例 Bean，直接可用。
  
2. **earlySingletonObjects（二缓存）**：  
   - 存放**提前暴露**的 Bean 实例（半成品），用于解决循环依赖。
  
3. **singletonFactories（三缓存）**：  
   - 存放**ObjectFactory**，用于创建 Bean 的早期引用，主要用于 AOP 代理对象的生成。

### **三级缓存的核心流程**
1. **创建 Bean 实例，但未初始化**，将其实例工厂（`ObjectFactory`）放入 **三级缓存** (`singletonFactories`)。
2. **检测依赖**，如果遇到循环依赖，先尝试从**一级缓存**获取完整 Bean，否则从**二级缓存**获取早期实例。
3. **如果二级缓存未命中**，则从**三级缓存**中获取 `ObjectFactory`，调用 `getObject()` 生成 Bean 的早期引用，并存入**二级缓存**，然后删除三级缓存中的 `ObjectFactory`。
4. **最终 Bean 初始化完成**，存入**一级缓存**，并从**二、三级缓存中移除**。

### **关键作用**
- **防止 AOP 代理丢失**：AOP 代理对象需要在 Bean 完成后增强，但如果直接暴露原始对象，代理可能无法生效。因此，Spring 让 `ObjectFactory` 提供代理后的对象。
- **降低空间占用**：只有在确实遇到循环依赖时才会使用二级缓存，从而减少不必要的实例存储。

### **局限性**
- **仅支持“构造方法外”的循环依赖**（即字段、Setter 注入）。
- **`@Scope("prototype")` 无法使用**，因为原型 Bean 不会放入单例池。

总结来说，**Spring 三级缓存机制通过提前暴露 Bean 的引用，使得循环依赖得以解决，同时保证 AOP 代理不丢失**。