# 🧠 什么是 Java 内存模型（JMM）？它解决了哪些问题？请举例说明 JMM 如何影响多线程程序的正确性。

---

> **Java 内存模型（Java Memory Model, JMM）** 是 Java 虚拟机（JVM）规范中关于多线程读写共享变量的行为准则。JMM 保障了多线程环境下数据的**可见性**、**有序性**、**原子性**，避免出现“莫名其妙”的并发 bug。

---

## 📋 JMM 解决的核心问题

| 问题类型   | 含义                   | 常见场景                           |
| ---------- | ---------------------- | ---------------------------------- |
| **原子性** | 操作不可中断           | i++ 不是原子操作                   |
| **可见性** | 变量更新对其他线程可见 | 一个线程修改变量，另一个线程没看到 |
| **有序性** | 指令执行顺序和代码一致 | 指令重排导致执行先后错乱           |

---

## 🌟 JMM 的工作机制

- **主内存**（Main Memory）：所有线程共享的变量存储区（JVM 堆）。
- **工作内存**（Working Memory）：每个线程的私有区域，从主内存拷贝变量副本进行操作。
- **同步规则**：线程对变量的操作（读写）必须先同步到主内存，才能被其他线程看到。

---

## 🏷️ 例子：可见性问题

```java
// 线程A
running = false;

// 线程B
while (running) {
    // do something
}
```
如果 `running` 没有加 `volatile` 修饰，线程A修改的值线程B**可能永远看不到**，造成死循环。这是因为 JMM 允许线程缓存变量副本，导致线程间不可见。

---

## 🛡️ 解决手段

- `volatile`：保证变量的可见性和禁止指令重排（适用于状态标志等简单同步场景）。
- `synchronized`：保证可见性和原子性，常用于临界区保护。
- 原子类（`AtomicInteger` 等）：保证原子性，适合计数器等场景。

---

## 🎯 总结（复习提示）

- **JMM 解决了多线程下的原子性、可见性、有序性问题。**
- **主内存/工作内存模型，线程间变量交互需通过主内存。**
- **`volatile` 保证可见性，`synchronized` 保证原子性和可见性。**
- **多线程代码正确性依赖 JMM 规则，常见面试点：可见性 bug、DCL 单例为何加 volatile。**

---

> 💡 **口诀记忆**：JMM 三大性，主内存/工作内存分离，volatile 保可见，synchronized 保原子，写多线程一定牢记！