# ZGC（Z Garbage Collector）简介及与G1对比

## 一、ZGC 简介

ZGC 是自 Java 11 引入的一种新型垃圾回收器，专为**超低延迟**和**高吞吐量**场景设计，具有以下主要特点：

### 1. 低停顿
- ZGC 的目标是让 GC 暂停时间保持在亚毫秒级（<1ms），且暂停时间不会随堆、存活对象集或 root 集大小增长。

### 2. 高吞吐量
- ZGC 是完全并发的垃圾收集器，大部分 GC 工作可与 Java 应用线程同时进行，大大减少对应用响应的影响。

### 3. 兼容性
- 可直接用于现有 Java 应用，无需修改代码。
- 仅支持 64 位 Linux 系统（部分新版本已支持 macOS 和 Windows），不支持 32 位和压缩指针。

### 4. 简单性
- 设计简洁、代码库小，易于维护和扩展。

### 5. 支持巨型堆
- 支持堆大小从 8MB 到 16TB，适合大规模内存需求场景。

### 6. 不分代回收
- ZGC 不区分新生代和老年代，对全堆进行标记，但回收时只针对内存分区，优先回收垃圾多的页面。

---

## 二、ZGC 与 G1 对比

| 特性       | ZGC                        | G1 GC                            |
| ---------- | -------------------------- | -------------------------------- |
| 停顿时间   | 目标为亚毫秒级（极低）     | 几十毫秒到几百毫秒，可预测但较高 |
| 并发性     | 几乎所有阶段均并发         | 标记、清理等部分并发             |
| 吞吐量     | 极高                       | 高                               |
| 堆大小支持 | 8MB ~ 16TB                 | 通常推荐4GB以上，最大支持有限    |
| 分代机制   | 不分代                     | 分代（新生代、老年代）           |
| 内存碎片   | 极少，采用分区和指针重定向 | 通过标记-复制和标记-整理避免碎片 |
| 兼容性     | 仅64位Linux（新版本扩展）  | 跨平台广泛支持                   |
| 配置复杂度 | 简单，自动调优为主         | 有较多参数可调，调优复杂         |
| 维护性     | 简单，代码库小             | 复杂                             |
| 应用场景   | 超大堆、对延迟极为敏感场景 | 大多数一般场景，兼顾吞吐和延迟   |

---

### 三、优缺点总结

#### ZGC 优点
- 极低GC停顿时间（亚毫秒级），对延迟极敏感场景极其友好。
- 支持超大堆（TB级），适合云服务、大数据等。
- 设计简单，维护成本低。
- 自动调优，易用性高。

#### ZGC 缺点
- 平台兼容性不如G1（仅支持64位Linux为主）。
- 不支持分代，部分短生命周期对象可能回收效率略低。
- 某些场景下吞吐率略低于G1（但绝大部分场景优于G1）。

#### G1 优点
- 支持分代，适合各种应用场景，适应性强。
- 可预测最大暂停时间，易于配置。
- 跨平台支持好（Linux、Windows、macOS）。
- 吞吐量高，调优空间大。

#### G1 缺点
- 停顿时间受堆大小影响，难以做到亚毫秒级。
- 配置参数较多，调优较复杂。
- 极大堆场景下性能不如ZGC。

---

## 四、总结

ZGC 是为超低延迟、大堆场景设计的新一代GC，适合对响应要求极高或堆内存极大的应用；而G1则适合大多数通用场景，支持分代和可预测延迟。选择哪种GC需根据业务需求、平台兼容性、延迟和吞吐量要求综合考虑。