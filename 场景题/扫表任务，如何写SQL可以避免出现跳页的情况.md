你的疑惑很常见，**下面以你给的例子详细解释“分页跳页”的原理**：

---

## 1. 正常分页场景（不修改数据时）

假设有5条数据，状态都为`INIT`，id从1到5。

| id   | state |
| ---- | ----- |
| 1    | INIT  |
| 2    | INIT  |
| 3    | INIT  |
| 4    | INIT  |
| 5    | INIT  |

- **第一页**：`LIMIT 0, 2`，查出id=1,2
- **第二页**：`LIMIT 2, 2`，查出id=3,4

**没有问题**。

---

## 2. 分页过程中数据被处理并更新（状态变更）

假如你用分页批量处理，每处理一批数据就把`state`从`INIT`改为`SUCCESS`。

### 步骤一：查第一页

```sql
SELECT * FROM table WHERE state = 'INIT' ORDER BY id LIMIT 0, 2;
```
查出来id=1,2。处理后，状态变为`SUCCESS`。

此时数据库变为：

| id   | state   |
| ---- | ------- |
| 1    | SUCCESS |
| 2    | SUCCESS |
| 3    | INIT    |
| 4    | INIT    |
| 5    | INIT    |

### 步骤二：查第二页

```sql
SELECT * FROM table WHERE state = 'INIT' ORDER BY id LIMIT 2, 2;
```
**这句SQL的意思是：**  
先查出所有`state=INIT`的记录，排序后**跳过前2条，取第3、4条**。

- 现在`state=INIT`的只有id=3,4,5。
- 排序后为3,4,5。

**LIMIT 2, 2**，会跳过前2条（即id=3,4），选第3、4条（但这里只剩id=5了）。

**所以查出来只有id=5，id=3和id=4被跳过了！**

---

## 3. 总结为什么会跳页

- OFFSET/LIMIT分页是**基于当前的结果集计算的**。
- 你每处理一批数据，会把一些数据的状态从`INIT`改成`SUCCESS`，下次分页时，这些数据就**从结果集消失了**。
- OFFSET的**“偏移”是基于最新的结果集**，而不是基于原始的数据。
- 所以实际查第二页时，**OFFSET导致你跳过了还没处理的数据**（因为前面的数据已经“消失”了，偏移量不准了）。

---

## 4. 解决方案

**不要用OFFSET/LIMIT分页处理会变更自身状态的数据。**  
常用的稳妥做法是**基于唯一主键（如id）做游标分页**：

```sql
-- 取大于上次最大id的数据
SELECT * FROM table WHERE state = 'INIT' AND id > 上次最大id ORDER BY id LIMIT 100;
```
每次记住已处理的最大id，下一次从这个id往后查，不会跳页、不会漏数据。

---

## 5. 结论

> 跳页的根本原因是：分页批处理时，处理过的数据被状态变更，下次分页OFFSET偏移错位，导致部分数据被跳过、遗漏。

---

如果还有疑问或者想要代码/流程图例子，可以继续追问！