## 问题：Redis 的事务机制是怎样的？能否保证原子性和隔离性？常见的事务相关命令有哪些？

### 详细解释（结合场景，含通俗例子）

#### 1. Redis 事务基本机制

- Redis 通过 `MULTI` 和 `EXEC` 命令实现事务机制。
- 一个事务包含多个命令，先用 `MULTI` 开启事务，连续输入多个命令，最后用 `EXEC` 一次性提交执行。
- 在事务提交前，所有命令只是进入队列，不会立即执行；提交后才顺序执行。

#### 2. 事务的原子性和隔离性

- **原子性**：Redis 保证事务内的命令要么全部执行，要么全部不执行（如被 `DISCARD` 取消），但不支持回滚（执行中某个命令出错不会导致其他命令回滚）。
- **隔离性**：事务提交前，命令不会被其他客户端看到。事务执行时，Redis 不会被其他命令插入打断（单线程保证）。
- **注意**：如果事务中某条命令语法错误，`EXEC` 时所有命令都不会执行；如果是运行时错误（如类型错误），只有出错的命令报错，其他命令正常执行，**无回滚机制**。

#### 3. 事务相关常用命令

- `MULTI`：开启事务。
- `EXEC`：提交事务，执行所有队列中的命令。
- `DISCARD`：放弃事务，清空命令队列。
- `WATCH key [key ...]`：对一个或多个 key 实现“乐观锁”，如果被监控的 key 在事务提交前被其他客户端修改，则事务会被取消（防止并发写覆盖）。
- `UNWATCH`：取消对 key 的监控。

#### 通俗例子

就像银行柜台办理一组业务（事务），先把所有表单交给柜员（MULTI），柜员收齐后统一处理（EXEC）。如果你发现有问题随时可以撤销（DISCARD）。但如果某份表单写错（命令语法错），所有业务都不办；如果某个表单受理失败（如余额不足），其他表单业务还是会继续。

---

### 总结性回答（复习提示）

> Redis 事务通过 MULTI-EXEC 保证命令批量有序执行，支持原子性但不支持回滚。可用 WATCH 实现乐观锁防止并发冲突，适合需要简单事务控制的场景。