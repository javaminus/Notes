## 问题4：请举例说明一次实际 JVM 调优的过程和参数调整依据

下面以一个线上 Spring Boot 服务因频繁 Full GC、响应延迟飙升的案例来说明调优思路与实践。

### 1. 背景与目标
- 问题现象：生产环境服务在高峰期频繁触发 Full GC，导致 200–500 ms 的 STW 暂停，业务接口响应不稳定，SLA 报警。
- 调优目标：减少 Full GC 次数、缩短单次 GC 停顿时长，将最大停顿控制在 100 ms 以内，同时保证总体吞吐量。

### 2. 收集与分析数据
1. **GC 日志**  
   `-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/logs/gc.log`  
   分析发现：  
   - Minor GC 频繁（平均 5 s/次），新生代回收很快  
   - Full GC 每分钟 2–3 次，每次停顿 300–500 ms  
2. **堆快照（Heap Dump）**  
   通过 `jmap -dump:live,format=b,file=heap.hprof`，用 MAT 分析发现：  
   - 大量短生命周期对象（请求上下文、JSON 序列化临时对象）快速晋升到老年代  
   - 老年代使用率经常超过 85%，触发频繁 Full GC  
3. **监控面板**  
   - CPU 利用率未饱和，说明 GC 耗时主要在 STW，而不是并发阶段  
   - 线程数与请求量正相关，未发现线程泄漏

### 3. 制定调优策略
1. **增大新生代空间**  
   - 让更多临时对象在新生代回收，减少晋升  
   - 参数：`-Xmn1g`（初始 512 m 升到 1 g）
2. **切换到 G1 GC**  
   - G1 对大堆场景的停顿控制更好，可设置最大停顿目标  
   - 参数：`-XX:+UseG1GC -XX:MaxGCPauseMillis=100`
3. **调整堆大小**  
   - 结合机器内存（16 g），给应用预留 8 g  
   - 参数：`-Xms8g -Xmx8g`
4. **优化晋升阈值**  
   - 延长对象在新生代中存活次数，减少晋升  
   - 参数：`-XX:MaxTenuringThreshold=15`

### 4. 执行与验证
1. **灰度发布**：  
   - 部分实例应用新参数，实时监控 GC 曲线与响应时延。  
2. **效果对比**：  
   - 新生代 GC 间隔延长到 15 s/次，Minor GC 平均停顿 < 10 ms  
   - 老年代混合回收（Mixed GC）替代 Full GC，STW 停顿均值约 50 ms  
   - 业务 P95 响应从 350 ms 降到 120 ms，错误率下降 80%  
3. **回滚与补充**：  
   - 若出现 OOM 或停顿异常，快速回滚到旧参数，进一步观察分阶段调整

### 5. 总结与经验
- **监控先行**：问题定位依赖完整的 GC 日志和 Heap Dump  
- **小步快跑**：每次只改一两项参数，观察指标变化，避免“调了一锅”  
- **选对 GC**：G1/ ZGC 等低停顿回收器适合大内存、对延迟敏感的场景  
- **结合业务**：新生代大小、晋升阈值要根据对象生命周期特点来设置

### 复习提示
“收集（GC 日志+Heap Dump）→ 分析（晋升率+Gen 使用率）→ 策略（新生代、GC 算法、堆大小、晋升阈值）→ 小步验证→上线监控”  