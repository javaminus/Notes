## 高频高并发面试题 —— “高并发下如何保证数据一致性？常见一致性方案与适用场景”

### 问题
在分布式高并发系统中，如何保证核心数据的一致性？请说明常见数据一致性模型（如强一致性、最终一致性、弱一致性），典型实现方案（如分布式事务、消息一致性、乐观锁/悲观锁等），并结合实际场景分析优缺点及应用建议。

---

### 详细解释

#### 1. 业务场景

- 电商下单扣减库存和账户余额，需要保证二者要么都成功、要么都失败。
- 金融转账，涉及多个账户，必须保证资金安全一致。
- 微服务拆分后，多个服务间存在跨库/跨服务操作，数据一致性难度提升。

#### 2. 一致性模型

- **强一致性**  
  数据在任何时刻对所有用户都一致，更新后读到的永远是最新值。实现难度高，性能开销大。  
  *场景：银行核心账务、订单支付等关键业务。*

- **最终一致性**  
  系统保证经过一段时间后，所有副本最终达到一致。允许短时间不一致，性能更优。  
  *场景：电商订单状态同步、消息通知等。*

- **弱一致性**  
  不保证数据何时一致，可能永远不一致，适用于对一致性要求极低的场景。  
  *场景：非核心日志、监控数据等。*

#### 3. 常见实现方案

- **分布式事务**
  - 两阶段提交（2PC）、三阶段提交（3PC）：常用于强一致性场景，性能开销大，易阻塞。
  - 本地消息表+最终一致性方案（如阿里巴巴的TCC、SAGA模式）：适用于微服务，降低耦合，保证关键业务最终一致。

- **消息中间件保证一致性**
  - 通过消息队列异步通知下游服务，确保操作最终一致。
  - 需结合幂等性、补偿机制、消息确认等设计。

- **乐观锁/悲观锁**
  - 乐观锁常用版本号/时间戳，适合读多写少场景。
  - 悲观锁适合并发冲突频繁的场景，但性能较差。

#### 4. 实际案例

电商下单，扣减库存与生成订单分属不同服务。采用本地消息表+消息队列，先本地落库订单，再异步发送库存扣减消息，消费失败可重试或人工补偿，实现最终一致性。

#### 5. 优缺点及注意事项

- **强一致性**：安全但牺牲性能，适合关键业务。
- **最终一致性**：高性能，复杂度高，需重点关注异常补偿和幂等性。
- **分布式事务**：实现难度高，场景有限。微服务推荐本地消息表+MQ+补偿机制。

---

### 总结性回答（复习提示词）

- **一致性模型**：强一致性、最终一致性、弱一致性
- **常用方案**：分布式事务（2PC/TCC/SAGA）、消息中间件+补偿、乐观锁/悲观锁
- **高并发建议**：最终一致性+幂等+补偿，关键业务用强一致
- **记忆口诀**：强一致慢安全，最终一致高性能，幂等补偿保周全