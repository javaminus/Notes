基于本地消息表实现分布式事务，常用于没有MQ事务消息支持的场景，具体步骤如下：

1. **业务操作与消息写入同一个本地事务**  
  在服务A处理核心业务时，同时将待发送的消息写入本地消息表，确保两者原子性，一起成功或失败。

2. **异步投递消息**  
  由后台线程或定时任务定期扫描消息表，将未投递的消息发送到MQ，保证消息最终被发送。

3. **幂等和重试机制**  
  消息发送采用幂等设计，防止重复消费；如发送失败，系统会重试，确保消息尽最大努力投递。

4. **下游服务消费消息**  
  服务B从MQ获取消息后，处理自己的业务操作，实现分布式事务的最终一致性。

**一句话总结（面试用）**  
本地消息表方案通过将业务操作和消息写入本地事务中，结合异步投递和幂等机制，实现各服务间的数据最终一致性，是分布式事务中常用且简单可靠的解决方案。

> 当然可以，举个实际例子你就容易理解了：
>
> ## **不是没有 MQ，而是 MQ 没有事务消息支持！** 
>
> ### 场景举例：用户下单和库存扣减
>
> 假设你有两个服务：  
> - **订单服务A**：负责创建订单  
> - **库存服务B**：负责扣减库存
>
> #### 具体流程
>
> 1. **订单服务A本地事务（核心业务+消息写入）**  
>    用户下单时，订单服务A在一个本地事务里同时做两件事：  
>    - 写入订单表，生成订单  
>    - 写入消息表，记录“订单已创建，需扣减库存”的消息  
>      这样如果订单生成失败，消息也不会写入；反之亦然，保证原子性。
>
> 2. **异步投递消息到MQ**  
>    后台线程或定时任务会定期扫描消息表，把“订单已创建”这类消息发送到消息队列（MQ）。  
>    发送成功后，更新消息表里的状态（比如“已发送”）。
>
> 3. **幂等和重试**  
>    假如消息发送失败，系统会自动重试。  
>    即使重复发送，库存服务B也要做幂等处理——比如每个订单只扣一次库存，防止重复扣减。
>
> 4. **库存服务B消费消息**  
>    库存服务B监听MQ，收到“订单已创建”消息后，扣减库存。  
>    这里也可以做幂等，确保即使收到重复消息也只扣减一次。
>
> #### 一句话总结示例  
> 本地消息表方案就是把业务操作和消息写入同一个本地事务，再通过后台异步发消息和幂等重试机制，实现服务间数据最终一致性，常用于没有MQ事务消息的分布式事务场景。
>
> ---
>
> **简单理解**：  
> 下单和消息写入一块儿做，后台把消息发出去，库存服务收到后扣减库存。即使消息有点慢、失败会重试，也不会出错或丢单，实现最终一致性。