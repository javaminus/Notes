# 如何实现不重复的短链地址？

实现短链服务（短网址服务）时，生成不重复且难以被穷举的短链地址是核心难点。常见方案对比如下：

---

## 1️⃣ 直接用Hash算法（如MD5、SHA）

- **优点**：实现简单，输入同一个URL输出一样的短链
- **缺点**：有碰撞风险（不同URL生成相同短链），且短链不可控长度较长

---

## 2️⃣ 自增ID/全局唯一ID

- **方案**：数据库/Redis自增ID，每次生成唯一数，再转为Base62编码
- **优点**：绝对不重复，短链长度可控，实现简单
- **缺点**：容易被穷举（可预测下一个短链是什么），暴露业务量

---

## 3️⃣ 雪花算法等分布式唯一ID

- **方案**：用雪花算法生成分布式唯一ID，再Base62编码
- **优点**：分布式高并发，唯一性强
- **缺点**：短链较长，依然可被穷举

---

## 4️⃣ MurmurHash + Base62（推荐）

这是业界常用且较均衡的一种方案。

### 实现步骤：

1. **对长URL做MurmurHash**，生成固定长度的哈希值（通常64位或128位）
2. **将哈希值转成Base62编码**（字符集为0-9a-zA-Z，共62个字符），得到短链字符串
3. **存储映射**（短链 -> 长链）到数据库
4. **冲突处理**：如果新生成的短链已存在且映射的是不同长链，可以尝试加盐（如用户ID、时间戳）后重新hash，直到不冲突为止

#### Base62编码的意义

- 只用数字和大小写字母（共62个），没有特殊字符，保证短链**更短且URL安全**
- 比Base64更适合做短链

#### MurmurHash优势

- 分布均匀、高性能、低碰撞率
- 不容易被穷举（比自增ID安全）
- 可通过加盐进一步降低碰撞和穷举风险

---

### 示例流程

1. 输入长URL：https://www.example.com/article/123
2. 计算哈希值：MurmurHash3(https://www.example.com/article/123)
3. 转为Base62：如`8M0kX`
4. 存入数据库，映射关系：`8M0kX` <-> `https://www.example.com/article/123`
5. 访问短链时，查库还原原始URL

---

### 扩展：避免重复&被穷举

- 可以加入用户ID、时间戳等做加盐混合，进一步增加唯一性和不可预测性
- 冲突时递归加盐重算

---

## 总结

- **推荐方案**：MurmurHash + Base62，适当加盐
- **优点**：短、唯一、不易被穷举，易实现
- **注意**：需处理哈希冲突，短链和长链的映射必须持久化存储

---

> 💡 **一句话总结：用高性能哈希算法（如MurmurHash）+ Base62编码生成短链，并加盐防止重复和穷举，是实现高质量短链服务的常用做法。**