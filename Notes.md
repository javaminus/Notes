

## 【MySQL】

| Problems                                                     | Hints                                                        | Solution                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| SQL 学习指南：从入门到精通                                   | `group by`是分组，`having`是分组后过滤，` 窗口函数`用于对查询结果中的数据分组后进行排序、累计、排名等计算，而不影响原有数据的行数。 | [Editorial](./MySQL/SQL学习指南：从入门到精通.md)            |
| EXPLAIN 分析SQL详解                                          | 核心就是`type`：`system、const、eq_ref、ref、range、index、all`**分析步骤**：1、看type是否为ALL 2、看key是否命中预期索引 3、分析rows是否过大 4、关注Extra字段是否出现临时表，用到外部排序 5、多表join，注意id和select_type，谁是驱动表 | [Editorial](./MySQL/EXPLAIN分析SQL详解.md)                   |
| 数据库操作分类                                               | 数据定义操作（DDL，创建修改表结构）；数据操作（DML，数据crud）；数据控制操作（权限）；事务控制操作； |                                                              |
| 范式                                                         | 设计关系型数据库**表结构**时需要遵循的一系列规范，目的是**减少数据冗余**、**消除数据异常**、**保证数据一致性**。常见的范式有第一范式（1NF，**字段不可再分**）、第二范式（2NF，**消除部分依赖**）、第三范式（3NF，**消除传递依赖**） | [Editorial](./MySQL/范式.md)                                 |
| MySQL分层                                                    | MySQL 的查询处理大致分为两层：**Server 层**和**存储引擎层**。Server 层负责 SQL 的**解析**、**优化**和**执行**等逻辑处理，而存储引擎层（也叫存储层）负责数据的**实际存储**和**读取**。Server 层不关心数据如何落盘，存储引擎层则专注于数据的管理方式，比如 InnoDB、MyISAM 等不同引擎。这样分层设计让 MySQL 既灵活又高效。 | [Editorial](./MySQL/MySQL分层.md)                            |
| 数据库建表要注意什么                                         | 表结构是否合理（每个表只负责一种业务实体），主键唯一（递增），字段数据选择能小不用大，能设置not null 就不要设置 null ，索引设计，选择合适的字符集与排序规则（utf8mb4, utf8mb4_general_ci）,表注释和字段注释，预留拓展字段，尽量满足第三范式。 | [Editorial](./MySQL/数据库建表要注意什么.md)                 |
| 索引分类                                                     | 物理结构：聚簇索引（主键索引）、非聚簇索引；逻辑结构：单列索引、复合索引；功能：唯一索引、普通索引、主键索引； | [Editorial](./MySQL/索引分类.md)                             |
| 介绍一下索引下推                                             | 索引下推**优化了联合索引**的**过滤**过程，它的主要作用是在使用索引进行数据检索时，将部分 WHERE 条件“下推”到存储引擎层，由存储引擎在扫描索引时提前过滤不符合条件的记录，从而减少回表次数，提高查询效率。 | [Editorial](./MySQL/介绍一下索引下推.md)                     |
| 事务隔离级别有哪些？                                         | 四种隔离级别：读未提交、读已提交、可重复读、串行化           | [Editorial](./MySQL/事务隔离级别有哪些？.md)                 |
| 脏读和幻读的区别？                                           | **脏读**：一个事务读到了「未提交事务修改过的数据」**幻读**：在一个事务内多次查询某个符合查询条件的「记录数量」，如果前后两次查询到的记录数量不一样。 |                                                              |
| 如何防止幻读？                                               | **针对快照读**（普通 select 语句），是通过 MVCC 方式解决了幻读；  **针对当前读**（select ... for update等语句），是通过 `next-key lock`（记录锁+间隙锁）**这里的记录锁就是行锁！！！** | [Editorial](./MySQL/如何防止幻读.md)                         |
| 间隙锁和记录锁既然都是锁一个范围，那么有什么区别，为什么防止幻读不能只选一个 | **记录锁**：锁定的是已有的数据行（记录），只保护已存在的行不被其他事务修改或删除。  **间隙锁**：锁定的是数据之间的“间隙”，即某个区间内没有实际数据的部分。它防止其他事务在这个区间插入新行。 | [Editorial](./MySQL/间隙锁和记录锁既然都是锁一个范围，那么有什么区别，为什么防止幻读不能只选一个.md) |
| 可重复读有没有幻读的问题？（举了例子）                       | **可能存在幻读**问题，但不会有脏读和不可重复读               | [Editorial](./MySQL/可重复读有没有幻读的问题？（举了例子）.md) |
| **MySQL的MVCC是什么？它是如何实现高并发读写的？**            | MVCC（Multi-Version Concurrency Control，多版本并发控制）是一种**无锁并发控制机制**，用于解决数据库事务的**可见性**问题，避免 **脏读、不可重复读、幻读**，同时提高数据库的**并发性能**。 主要依赖机制： （1）隐藏列（事务 ID & 回滚指针） 、 （2）Undo Log（回滚日志） | [Editorial](./MySQL/MySQL的MVCC是什么？它是如何实现高并发读写的？.md) |
| mysql的什么命令会加上间隙锁？                                | 在可重复读隔离级别下。 使用非唯一索引进行带`where`语句的查询、删除、更新 | [Editorial](./Mysql/mysql的什么命令会加上间隙锁.md)          |
| MySQL 的存储引擎有哪些？为什么常用InnoDB？                   | InnoDB【支持事务、最小锁的粒度是行锁】、MyISAM、Memory       | [Editorial](./MySQL/MySQL的存储引擎有哪些？为什么常用InnoDB？.md) |
| B+ 树和 B 树的比较                                           | 叶子节点存储数据不同、B+树支持范围查询（叶子节点通过双向链表连接）、B+树修改树的效率更高（矮胖） | [Editorial](./MySQL/B+树和B树的比较.md)                      |
| 展示一下Mysql的B+树和Redis的跳表删除和插入一个节点的变化     |                                                              | [Editorial](./MySQL/展示一下Mysql的B+树和Redis的跳表删除和插入一个节点的变化.md) |
| 索引失效的情况                                               | 使用左模糊或者左右模糊匹配 、 对索引列使用函数 、 对索引列进行表达式计算[`where a+1>50`] 、 联合索引没有正确使用需要遵循最左匹配原则 | [Editorial](./MySQL/索引失效的情况.md)                       |
| **MySQL的联合索引为什么要遵循最左前缀原则？**                | 联合索引按最左字段排列，查询必须包含最左字段，才能用上索引（最左前缀原则）。 | [Editorial](./MySQL/MySQL的联合索引为什么要遵循最左前缀原则？.md ) |
| 什么是覆盖索引？它的优点是什么？                             | 覆盖索引是指一个查询的**所有字段**都能从索引中获取到，而不需要回表到数据表中查找。优点包括：减少磁盘IO，提升查询性能，减少锁的范围。 |                                                              |
| MySQL 的**自增主键**在高并发下会出现什么问题？如何解决？     | 在高并发场景下，自增主键可能会导致**主键冲突**、**插入性能瓶颈**，甚至在主从复制时因主键重复导致数据不一致。解决方案包括：使用**分布式唯一ID**（如雪花算法、UUID等）、主键预分配、或者采用数据库自带的分布式ID生成器。 |                                                              |
| 什么是二级索引？                                             | 主键索引以外就叫二级索引，如果二级索引包含查找字段，就不用回表。 |                                                              |
| 二级索引存放的有哪些数据？                                   | 主键索引（聚簇索引）叶子节点存放**完整数据**，二级索引存放**主键**。 |                                                              |
| 事务的特性是什么？如何实现的？                               | 原子性（   undo log（回滚日志） ）、隔离性（  MVCC（多版本并发控制） 或锁机制 ）、持久性（ redo log （重做日志） ）、一致性（ 持久性+原子性+隔离性 ）； | [Editorial](./MySQL/事务的特性是什么？如何实现的？.md)       |
| 间隙锁的原理                                                 | 只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。 | [Editorial](./MySQL/间隙锁的原理.md)                         |
| 滥用事务，或者一个事务里有特别多sql的弊端？                  | 容易造成死锁和锁超时、数据回滚时间变长、容易造成主从延迟、占用大量日志和内存、长事务导致快照保留时间长 | [Editorial](./MySQL/滥用事务，或者一个事务里有特别多sql的弊端？.md) |
| MySQL两个线程的update语句同时处理一条数据，会不会有阻塞？    | 会，因为InnoDB的行锁。                                       |                                                              |
| 两条update语句处理一张表的不同的主键范围的记录，一个<10，一个>15，会不会遇到阻塞？底层是为什么的？ | **不会**，因为锁住的范围不一样，不会形成冲突。 第一条 update sql 的话（ id<10），锁住的范围是（-♾️，10） 第二条 update sql 的话（id >15），锁住的范围是（15，+♾️） |                                                              |
| 如果上面2个范围不是主键或索引？还会阻塞吗？                  | 触发全表扫描，会**阻塞**                                     |                                                              |
| 表中十个字段，你主键用自增ID还是UUID，为什么？               | **自增ID**。使用 InnoDB 应该尽可能的按主键的自增顺序插入，并且尽可能使用单调的增加的聚簇键的值来插入新行 。 | [Editorial](./MySQL/表中十个字段，你主键用自增ID还是UUID，为什么？.md) |
| MySQL的锁讲一下                                              | 全局锁、表级锁、行级锁                                       | [Editorial](./MySQL/MySQL的锁讲一下（按锁的粒度讲一遍）.md)  |
| 设计一个行级锁的死锁，举一个实际的例子                       | **死锁发生条件**：两个事务**交叉加锁**，形成**循环等待**。  **解决方案**：  1、 **统一加锁顺序**（最有效）。 2、 **使用 `NOWAIT` 或 `SKIP LOCKED`** 避免长时间等待。 3、 **使用短事务**，避免锁占用过长。 | [Editorial](./MySQL/行级锁死锁例子.md)                       |
| mysql 如何避免全表扫描？                                     | 建立索引                                                     | [Editorial](./MySQL/mysql如何避免全表扫描？.md)              |
| mysql如何实现如果不存在就插入如果存在就更新？                | 可以使用 `INSERT ... ON DUPLICATE KEY UPDATE` 语句来实现“如果不存在就插入，如果存在就更新”的功能。 | [Editorial](./Mysql/mysql如何实现如果不存在就插入如果存在就更新.md) |
| 数据库访问量过大怎么办？                                     | **创建或优化索引** 、 **查询优化** 、 **避免索引失效** 、 **读写分离**、 **优化数据库表**、 **使用缓存技术** | [Editorial](./MySQL/数据库访问量过大怎么办.md)               |
| MySQL的三大日志说一下，分别应用场景是什么？                  | **redolog**、**binlog**和**undolog**   **只靠redolog可以保证持久性，但不能满足所有业务需求**【 **主从复制、数据恢复、增量备份** 】 | [Editorial](./MySQL/MySQL的三大日志说一下，分别应用场景是什么？.md) |
| **MySQL的Binlog有哪几种格式？各自的优缺点是什么？**          | Binlog有STATEMENT、ROW、MIXED三种格式；STATEMENT体积小但有一致性风险，ROW安全但日志大，MIXED自动切换，生产常用ROW或MIXED。 | [Editorial](./MySQL/MySQL的Binlog有哪几种格式？各自的优缺点是什么？.md) |
| 慢查询是如何调试解决的？                                     | 确认慢查询、分析执行计划、优化查询语句、优化数据库结构、缓存和查询缓存 | [Editorial](./MySQL/慢查询是如何调试解决的？.md)             |
| MySQL 的慢查询日志是什么？如何开启和分析慢查询？             | 慢查询日志：记录慢SQL，定位数据库瓶颈，常用mysqldumpslow或pt-query-digest分析。 | [Editorial](./MySQL/MySQL的慢查询日志是什么？如何开启和分析慢查询？.md) |
| **MySQL 的 explain 工具怎么用？各字段含义是什么？**          | EXPLAIN分析SQL执行计划，重点关注type、key、rows、extra字段，定位是否走索引、是否全表扫描，优化性能必备。 | [Editorial](./MySQL/MySQL的explain工具怎么用？各字段含义是什么？.md) |
| 数据库翻页（limit）查询时，发现越往后查询越来越慢，为什么？该如何修改 SQL 能解决? | 数据库翻页使用 `LIMIT offset` 时，`offset` 越大查询越慢，因为需要跳过前面大量数据，建议用基于主键的“条件翻页”优化SQL性能。 | [Editorial](./MySQL/数据库翻页（limit）查询时，发现越往后查询越来越慢，为什么？该如何修改SQL能解决.md) |
| 什么是慢查询以及如何调试解决的?                              | 慢查询是指数据库中执行时间超过**设定阈值**的 SQL，通过开启**慢查询日志**、**分析执行计划**和**优化索引**或 **SQL 结构进行定位**和解决。 | [Editorial](./MySQL/什么是慢查询以及如何调试解决的.md)       |
| **什么是回表？为什么有时候会发生回表操作？举例说明。**       | 普通索引查不到的数据，需要通过主键回到聚簇索引获取；**索引覆盖**可避免回表。 | [Editorial](./MySQL/什么是回表？为什么有时候会发生回表操作？举例说明.md ) |
| MySQL 的唯一索引与普通索引有什么区别？各自的应用场景是什么?  | 唯一索引：唯一性约束+加速查询；普通索引：只加速查询，无唯一性约束。 | [Editorial](./MySQL/MySQL的唯一索引与普通索引有什么区别？各自的应用场景是什么.md) |
| **为什么建议在InnoDB表中使用自增主键作为聚簇索引？**         | 自增主键聚簇索引：插入有序、性能高、碎片少，建议优先选择。   | [Editorial](./MySQL/为什么建议在InnoDB表中使用自增主键作为聚簇索引？.md) |
| MySQL中为什么需要分库分表，以及常见的分库分表策略有哪些？    | 分库分表：为解决单表单库性能瓶颈，常用范围、哈希、时间、逻辑分表策略。 | [Editorial](./MySQL/MySQL中为什么需要分库分表，以及常见的分库分表策略有哪些？.md) |
| MySQL为什么要使用索引？索引的弊端有哪些？                    | 索引加速查询有空间和维护开销，数量需适度，查读写平衡。       | [Editorial](./MySQL/MySQL为什么要使用索引？索引的弊端有哪些？.md) |
| MySQL的**主从复制**原理是什么？常见的主从延迟有哪些原因？    | 主从复制：binlog同步与重放，主写从读，常因写入压力、硬件、网络或大事务导致延迟。 | [Editorial](./MySQL/MySQL的主从复制原理是什么？常见的主从延迟有哪些原因？.md) |
| MySQL中的“锁表”和“锁行”有什么区别？在什么场景下会发生锁表？  | 锁表锁全表，锁行锁单行，InnoDB支持行级锁，MyISAM只支持表级锁，表锁常见于DDL或无索引大操作。 | [Editorial](./MySQL/MySQL中的“锁表”和“锁行”有什么区别？在什么场景下会发生锁表？.md) |
| MySQL 的分区表是什么？适合解决哪些问题？                     | 分区表：大表分片存储，优化大表性能，常用于时间、范围分区，提升查询和归档效率。 | [Editorial](./MySQL/MySQL的分区表是什么？适合解决哪些问题？.md) |
| 如何在MySQL中创建一个按月份分区的订单表？                    | 分区表按规则“切片”存储大表，每个分区独立管理，常见按时间分区，DDL可直接操作分区。 | [Editorial](./MySQL/如何在MySQL中创建一个按月份分区的订单表？.md) |
| 说一说MySQL一条SQL语句的执行过程？                           | 连接数据库->检查缓存->由解析器进行（语法分析\|语义分析）->优化器（索引优化查询）->执行器 |                                                              |
| 什么是意向锁？                                               | 意向锁是数据库多粒度锁机制中的一种辅助锁类型，主要用于标识事务在更细粒度对象（如行）上加锁的**意图**，从而协调不同粒度（如表级和行级）之间的**锁兼容性**。它**本身不会直接锁定数据**，而是通过在高层对象（如表）上加意向锁，快速判断是否可以安全地在更细粒度对象上加锁，**提高并发控制的效率，避免锁冲突和死锁问题**。 | [Editorial](./MySQL/什么是意向锁.md)                         |
| 为什么不推荐使用外键？如果不用外键，用什么方案替代呢？       | 在高并发或分布式系统中，不推荐使用外键，是因为外键约束会影响数据库的**写入性能**，增加数据迁移和扩展的复杂性；实际开发中通常使用**应用层**通过**代码校验**和**唯一索引**等方式保证数据一致性，比如插入订单时先校验用户是否存在，这样既提升了性能，又便于系统水平拆分和维护。  使用`user_id`这个字段，但是不作为外键连接两张表。 | [Editiroal](./MySQL/为什么不推荐使用外键？如果不用外键，用什么方案替代呢？.md) |
| Mysql如何使用乐观锁和悲观锁                                  | 悲观锁：`select ... for update`  乐观锁：在数据库表里面加一个字段【版本号 or 更新时间】，每次更新前先查询对应的版本号，然后拿着版本号做更新。 | [Editorial](./MySQL/Mysql如何使用乐观锁和悲观锁.md)          |
| 区分度不高的**字段建索引**一定没用吗？                       | 不一定                                                       | [Editorial](./MySQL/区分度不高的字段建索引一定没用吗.md)     |
| 如何区分sql语句是在主库执行还是在分库执行                    | **数据库连接配置**，配置多个`datasource`                     | [Editorial](./MySQL/如何区分sql语句是在主库执行还是在分库执行.md) |
| 如何区分sql语句是在主库执行还是在备库执行                    | 配置`datasource`下面的`master`和`slave`                      | [Editorial](./MySQL/如何区分sql语句是在主库执行还是在备库执行.md) |
| 介绍一下InnoDB的数据页，和B+树的关系是什么                   | 数据页就是InnoDB的每个节点，通常大小为4096B也就是4KB         | [Editorial](./MySQL/介绍一下InnoDB的数据页，和B+树的关系是什么.md) |
| innoDB是一个数据页存储一行数据吗？那么如果一行数据超出16kb怎么办？ |                                                              | [Editorial](./MySQL/innoDB是一个数据页存储一行数据吗？那么如果一行数据超出16kb怎么办.md) |
| 既然一个数据页里面存储多行数据，那么如何保证在数据页里面快速查找？时间复杂度是多少？ | 如果有索引，二分查找，也是log级别                            | [Editorial](./MySQL/既然一个数据页里面存储多行数据，那么如何保证在数据页里面快速查找？时间复杂度是多少.md) |
| innodb的B+树2000万的数据一般有多少个数据页                   | B+树不是红黑树！                                             | [Editorial](./MySQL/innodb的B+树2000万的数据一般有多少个数据页.md) |
| 介绍一下mysql的in和exists                                    | **IN** 用于判断某字段是否在一个集合中，适合集合较小或主键列表查询；**EXISTS** 用于判断子查询是否有数据返回，通常在大表关联或只需判断“是否存在”时更高效。在 MySQL 中，IN 更关注具体值的匹配，EXISTS 更关注关联关系和存在性检测，选择哪种方式应根据数据规模和查询场景灵活取舍。 | [Editorial](./MySQL/介绍一下mysql的in和exists.md)            |

## 【Redis】

| Problems                                                     | Hints                                                        | Solution                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Jedis学习笔记                                                | 不学这个                                                     | [Editorial](./Redis/Jedis学习笔记.md)                        |
| Spring_Data_Redis 加Lettuce                                  | 记一下五大基础数据结构的读写以及设置过期键                   | [Editorial](./Redis/Spring_Data_Redis加Lettuce.md)           |
| Redission学习笔记                                            | 分布式的场景用的最多                                         | [Editorial](./Redis/Redission学习笔记.md)                    |
| Redis是AP还是CP？                                            | 单机的Redis连P（分区容错性）都没有，不讨论；分布式的Redis是AP，因为Redis通过异步的主从同步保证系统的高可用（A），那么这个时候的数据一致性得不到保证（C）; |                                                              |
| Redis 使用什么协议进行通信?                                  | Redis 使用自己设计的一种文本协议进行客户端与服务端之间的通信——**RESP**（REdis Serialization Protocol），这种协议简单、高效，易于解析，被广泛使用。  RESP 协议基于 **TCP** 协议，采用请求/响应模式，每条请求由多个参数组成，以命令名称作为第一个参数。请求和响应都以行结束符（\r\n）作为分隔符. |                                                              |
| Redis高级数据结构的使用场景                                  | 常见的有五种数据类型：String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）。 BitMap、HyperLogLog、GEO、Stream。 | [Editorial](./Redis/Redis高级数据结构的使用场景.md)          |
| redis五种数据结构的底层                                      | hash结构的切换是（512，64字节），zset的切换是（256，64字节） | [Editorial](./Redis/redis五种数据结构的底层.md)              |
| 什么是GEO，有什么用？                                        |                                                              | [Editorial](./Redis/什么是GEO有什么用.md)                    |
| Redis BitMap 和 HyperLogLog 的原理是什么？分别适合哪些实际应用场景？ | **BitMap位图，本质是一个超长的数组 适合大规模布尔统计（如签到、活跃统计），节省空间，支持位运算。**  **HyperLogLog基于概率算法的数据结构 适合大规模去重计数（如UV统计），空间极小但有一定误差。**  **二者都是 Redis 的“以空间换效率”的典型高阶数据结构，适用于高并发大数据量的统计场景。** | [Editorial](./Redis/RedisBitMap和HyperLogLog的原理是什么？分别适合哪些实际应用场景？.md) |
| 热 key 是什么？怎么解决？                                    | Redis热key是指被频繁访问的key 。业务层、缓存架构、服务层、降级和容错 | [Editorial](./Redis/热key是什么？怎么解决？.md)              |
| String 是使用什么存储的?为什么不用 c 语言中的字符串?         | Redis 的 String 字符串是用 `SDS` 数据结构存储的。  **len，记录了字符串长度**。  **alloc，分配给字符数组的空间长度**。  **flags，用来表示不同类型的 SDS**。  **buf[]，字符数组，用来保存实际数据**。  增加了三个元数据：len、alloc、flags，用来解决 C 语言字符串的缺陷。  O（1）复杂度获取字符串长度 ； 二进制安全 ； 不会发生缓冲区溢出 。 | [Editorial](./Redis/String是使用什么存储的为什么不用c语言中的字符串.md) |
| AOF和RDB哪个更占空间                                         | **AOF（Append Only File）比 RDB（Redis DataBase snapshot）更占空间**。 | [Editorial](./Redis/AOF和RDB哪个更占空间.md)                 |
| Redis有什么持久化策略？                                      | Redis持久化有RDB（快照）、AOF（日志）、混合模式。RDB恢复快适合备份，AOF安全性高适合重要数据，混合兼顾性能和安全。   **我明白了RDB只保留一份，而不像undolog，保留了很多的历史版本！！！** | [Editorial](./Redis/Redis有什么持久化策略？.md)              |
| RDB是怎样做的？                                              | Redis 提供了两个命令来生成 RDB 文件，分别是 **save** 和 **bgsave**，他们的区别就在于是否在「主线程」里执行 | [Editorial](./Redis/RDB是怎样做的.md)                        |
| aof的写入策略，按时间写入和每次都写入的区别，优缺点          | Redis 提供了 3 种写回硬盘的策略， 在 Redis.conf 配置文件中的 appendfsync 配置项可以有以下 3 种参数可填： Always、 Everysec 、No | [Editorial](./Redis/aof的写入策略，按时间写入和每次都写入的区别，优缺点.md) |
| 你平常是怎么使用RDB和AOF的？                                 | 数据安全性（AOF）、数据恢复速度（RDB）、数据备份和迁移（RDB）、数据可读性（AOF） | [Editorial](./Redis/你平常是怎么使用RDB和AOF的？.md)         |
| 普通列表和压缩列表对比                                       | 压缩列表的所有数据在一块空间，没有指针连接元素               | [Editorial](./Redis/普通列表和压缩列表对比.md)               |
| Redis 的压缩列表（Ziplist）和跳表（Skiplist）是什么？它们在 Redis 中分别有哪些应用？ | **压缩列表（ziplist）**：节省内存的小型线性存储结构，常用于小 List、Hash、ZSet。  **跳表（skiplist）**：高效有序数据结构，支持范围查找和排序，主要用于 ZSet 大数据量场景。 | [Editorial](./Redis/Redis的压缩列表（Ziplist）和跳表（Skiplist）是什么？它们在Redis中分别有哪些应用？.md) |
| Zset 使用了什么数据结构？                                    | Zset 类型的底层数据结构是由**压缩列表或跳表**实现的          | [Editorial](./Redis/Zset使用了什么数据结构.md)               |
| redis的hashset底层数据结构是什么？                           | Hash 类型的底层数据结构是由**压缩列表或哈希表**实现的。      | [Editorial](./Redis/redis的hashset底层数据结构是什么？.md)   |
| 介绍一下redis中的跳表                                        | 跳表（Skip List）是一种 **基于链表的有序数据结构**，通过**多级索引**来加速查询。 | [Editorial](./Redis/跳表.md)                                 |
| 为什么 MySQL 不用 SkipList？对比                             | B+树的高度在3层时存储的数据可能已达千万级别，但对于跳表而言同样去维护千万的数据量那么所造成的跳表层数过高而导致的磁盘io次数增多，也就是使用B+树在存储同样的数据下**磁盘io次数**更少 。 | [Editorial](./Redis/为什么MySQL不用SkipList.md)              |
| Redis 使用场景?                                              | **缓存，消息队列、分布式锁等场景**。                         | [Editorial](./Redis/Redis使用场景.md)                        |
| Redis 性能好的原因是什么？                                   | 大部分操作**都在内存中完成** 、 采用单线程模型可以**避免了多线程之间的竞争** 、 采用了 **I/O 多路复用机制**处理大量的客户端 Socket 请求 | [Editorial](./Redis/Redis性能好的原因是什么？.md)            |
| Redis 和 MySQL 如何保证一致性                                | **「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的**。 |                                                              |
| 什么情况使用MySQL，什么情况使用Redis？                       | **MySQL**： 当需要存储结构化数据，并且需要支持复杂的查询操作时，和需要支持事务处理时。  **Redis**：当需要快速访问和处理数据的缓存时，可以选择Redis，能够提供快速的数据读取和写入。 | [Editorial](./Redis/什么情况使用MySQL，什么情况使用Redis？.md) |
| 本地缓存和Redis缓存的区别                                    | **本地缓存** 适合 **单机、低并发场景**，速度极快，但**数据不共享**。**Redis 缓存** 适合 **分布式、高并发场景**，支持**持久化**，但**访问速度比本地缓存稍慢**。**最佳实践**：**本地缓存 + Redis 结合使用**，**热点数据走本地缓存**，大规模数据放 Redis 共享。 | [Editorial](./Redis/本地缓存与Redis缓存.md)                  |
| Redis的Key过期了是立马删除吗                                 | 不会，Redis 的过期删除策略是选择「**惰性删除+定期删除**」这两种策略配和使用。 | [Editorial](./Redis/Redis的Key过期了是立马删除吗.md)         |
| Redis的大Key问题是什么？                                     | 某个key对应的value值所占的内存空间比较大，导致Redis的性能下降、内存不足、数据不均衡以及主从同步延迟等问题。 | [Editorial](./Redis/Redis的大Key问题是什么？.md)             |
| 大Key问题的缺点？                                            | 内存占用过高 、 性能下降 、 阻塞其他操作 、 网络拥塞 、 主从同步延迟 、 数据倾斜 | [Editorial](./Redis/大Key问题的缺点？.md)                    |
| redis hotkey用什么查，怎么解决hotkey？                       | 使用 Monitor 命令可以实时监控 Redis 数据库的所有命令操作，包括对 Hotkey 的读取和写入操作，通过对返回的执行命令进行统计来分析 Hotkey 的分布。 | [Editorial](./Redis/redishotkey用什么查，怎么解决hotkey？.md) |
| Redis三种集群模式                                            | Redis提供了三种不同的集群架构方案，各有特点。首先是**主从复制**模式，它是最基础的，通过一个主节点负责写操作，多个从节点复制数据提供读服务，实现了数据备份和读写分离，但缺点是主节点故障需手动切换，没有自动容灾能力。其次是**哨兵模式**，它在主从的基础上增加了哨兵进程，负责监控Redis实例，当主节点故障时自动选举新主节点进行故障转移，提高了系统可用性，适合对高可用有要求但数据量不是特别大的场景。最后是**Cluster集群模式**，它通过数据分片技术将16384个哈希槽分布到多个主节点，每个主节点可以有从节点，解决了Redis水平扩展的问题，支持自动故障转移，是处理大规模数据的理想选择。在实际应用中，我们需要根据数据规模、可用性要求和性能需求选择合适的模式。比如小规模应用可以用主从，需要高可用但数据量中等可以用哨兵，而需要大规模数据存储则应该选择Cluster模式。 | [Editorial](./Redis/Redis三种集群模式.md)                    |
| redis主节点挂了怎么办？                                      | 分下面几种情况：单机单节点、主从复制结构、 Redis Sentinel（哨兵机制） 、 Redis Cluster（分布式集群模式） | [Editorial](./Redis/redis主节点挂了怎么办.md)                |
| redis分布式锁怎么实现？                                      | **分布式锁是用于分布式环境下并发控制的一种机制，用于控制某个资源在同一时刻只能被一个应用所使用**。setnx+expire | [Editorial](./Redis/redis与reddsion实现分布式锁.md)          |
| 介绍一下redis中的看门狗机制                                  | Redis中的看门狗机制是Redisson客户端实现的一种**自动续期机制**，它通过后台线程定期检查并延长锁的过期时间，解决了分布式锁中业务执行时间不确定导致锁过早释放的问题，确保锁在持有者完成操作前不会因过期而被其他线程获取。 注意事项： **显式过期与看门狗互斥**：当你手动指定锁的过期时间时，看门狗机制将不会生效 。    **确保正确释放锁**：即使有看门狗机制，也应确保在finally块中释放锁 | [Editorial](./Redis/介绍一下redis中的看门狗机制.md)          |
| Redis内存淘汰策略                                            | 8种淘汰策略                                                  | [Editorial](./Redis/Redis内存淘汰策略.md)                    |
| **Redis为什么采用单线程模型，单线程模型下为什么还这么快？**  | 单线程避免了锁竞争和上下文切换，配合高效的I/O多路复用和纯内存操作，让Redis即使单线程也极快。 | [Editorial](./Redis/Redis为什么采用单线程模型，单线程模型下为什么还这么快？.md) |
| Redis为什么要采用哨兵（Sentinel）机制？它的作用和工作原理是什么？ | 哨兵（Sentinel）机制用于Redis**高可用**，**自动监控**、**故障转移**和**通知**，实现**主从切换**保障服务不中断。 | [Editorial](./Redis/Redis为什么要采用哨兵（Sentinel）机制？它的作用和工作原理是什么？.md ) |
| **Redis的过期键删除策略有哪些？为什么要用多种策略结合？**    | Redis 过期键删除采用惰性删除+定期删除+内存淘汰三种策略结合，兼顾性能和内存利用。 | [Editorial](./Redis/Redis的过期键删除策略有哪些？为什么要用多种策略结合？.md) |
| Redis如何实现分布式锁？有哪些常见的实现方式和注意事项？      | Redis分布式锁常用`SETNX+过期时间+唯一标识`，解锁要校验value，生产用RedLock提升可靠性。 | [Editorial](./Redis/Redis如何实现分布式锁？有哪些常见的实现方式和注意事项？.md) |
| **Redis集群（Cluster）是如何实现分布式存储和高可用的？主要原理和机制是什么？** | Redis Cluster通过哈希槽分片+多主多从架构，实现分布式存储和高可用，支持自动故障转移和请求自动路由。 | [Editorial](./Redis/Redis集群（Cluster）是如何实现分布式存储和高可用的？主要原理和机制是什么？.md) |
| **Redis的事务（Transaction）是如何实现的？它能保证原子性和隔离性吗？** | Redis事务通过`MULTI/EXEC`实现批量命令原子性，不支持回滚。`WATCH`可实现**乐观锁**，保证事务隔离性，但不是传统数据库的强隔离/原子性。 | [Editorial](./Redis/Redis的事务（Transaction）是如何实现的？它能保证原子性和隔离性吗？.md ) |
| Redis的慢查询是如何监控和分析的？出现慢查询一般怎么优化？    | Redis通过SLOWLOG监控慢查询，分析记录后优化数据结构、避免大key、合理分片和优化命令，提升整体性能。 | [Editorial](./Redis/Redis的慢查询是如何监控和分析的？出现慢查询一般怎么优化？.md) |
| Redis如何实现高并发下的数据一致性？比如缓存和数据库如何保证一致性？ | 缓存一致性推荐“先更新数据库，再删除缓存”，可配合延迟双删或消息队列，确保高并发下数据最终一致。 | [Editorial](./Redis/Redis如何实现高并发下的数据一致性？比如缓存和数据库如何保证一致性？.md) |
| Redis缓存雪崩、缓存击穿、缓存穿透分别是什么？如何应对这些问题？ | 缓存雪崩（分批过期、限流降级）、缓存击穿（互斥锁、热点永不过期）、缓存穿透（缓存空值、布隆过滤器）。 | [Editorial](./Redis/Redis缓存雪崩、缓存击穿、缓存穿透分别是什么？如何应对这些问题？.md) |
| Redis的发布/订阅（Pub/Sub）机制是怎样实现的？适用于哪些场景？ | Redis的发布/订阅是一种消息通信机制，允许消息的发送者（发布者）和接收者（订阅者）之间解耦。发布者将消息发布到某个频道（channel），订阅者只需订阅自己关心的频道即可收到消息。 | [Editorial](./Redis/Redis的发布订阅（PubSub）机制是怎样实现的？适用于哪些场景？.md) |
| **Redis的主从复制（Replication）是如何实现的？它在实际工作中有什么用？** | Redis主从复制通过全量+增量同步机制实现，广泛用于读写分离、高可用、数据备份等场景，是Redis高性能和高可靠性的基础技术之一。 | [Editorial](./Redis/Redis的主从复制（Replication）是如何实现的？它在实际工作中有什么用？.md ) |
| Redis管道（Pipeline）机制是什么？它的原理、优势和应用场景有哪些？ | Redis管道（Pipeline）是一种可以将多个命令一次性打包发送到Redis服务器的机制，减少了客户端与服务器之间的网络往返（RTT，Round Trip Time）次数，从而大幅提升批量操作的效率。 但不是事务，命令`不保证原子性`。 | [Editorial](./Redis/Redis管道（Pipeline）机制是什么？它的原理、优势和应用场景有哪些？.md) |
| Redis Stream 数据结构是什么？它的典型使用场景有哪些？与传统消息队列有何异同？ | Redis Stream是面向消息流的结构，支持持久化、消费组、消息确认和重试，适合异步任务队列、事件追踪、实时日志等场景，是Redis实现轻量级消息队列的首选。 | [Editorial](./Redis/RedisStream数据结构是什么？它的典型使用场景有哪些？与传统消息队列有何异同？.md) |
| Redis 如何实现消息队列？有哪些实现方式？各自优缺点如何？     | Redis 可用 List、Pub/Sub、Stream 实现消息队列。  **List 简单高效但功能基础**，适合轻量任务。  **Pub/Sub 支持广播但消息不可靠**，适合即时通知。  **Stream 功能最强，支持消费组与持久化**，适合可靠队列和复杂业务。 | [Editorial](./Redis/Redis如何实现消息队列？有哪些实现方式？各自优缺点如何？.md) |
| Redis 持久化与主从复制、集群机制的关系是什么？各自如何影响数据安全和高可用？ | **持久化**保障单机数据不丢，**主从复制**实现数据冗余，**哨兵/集群**保障服务不中断。 - 生产环境要结合持久化、主从复制、自动故障转移机制，才能既高可用又高安全。 | [Editorial](./Redis/Redis持久化与主从复制、集群机制的关系是什么？各自如何影响数据安全和高可用？.md) |
| Redis 的慢查询如何监控与分析？常见慢查询场景如何优化？       | Redis 用 SLOWLOG 监控慢查询，重点关注大 Key 和全量操作，建议用 SCAN 代替 KEYS，定期分析慢查询日志，优化数据结构和命令使用，保障高性能。 | [Editorial](./Redis/Redis的慢查询如何监控与分析？常见慢查询场景如何优化？.md) |
| Redis如何实现延迟消息？                                      | Redis过期消息 、`zset`、redisson的 `RDelayedQueue `          | [Editorial](./Redis/Redis如何实现延迟消息？.md)              |
| Redis除了缓存，还可以做什么？                                | 消息队列（不推荐）、延迟队列（不推荐）、排行榜、计数器、分布式ID、分布式锁、地理位置应用、分布式限流、分布式Session、布隆过滤器、状态统计、共同关注、推荐关注 | [Editorial](./Redis/redis除了缓存，还可以做什么)             |
| 对于 Redis 的操作，有哪些推荐的 Best Practices？             |                                                              | [Editorial](./Redis/对于Redis的操作，有哪些推荐的BestPractices？.md) |
| Redis中hash结构比string的好处有哪些？                        |                                                              | [Editorial](./Redis/Redis中hash结构比string的好处有哪些.md)  |
| ZSet为什么在数据量少的时候用ZipList，而在数据量大的时候转成SkipList？ | ZipList的存储更**节省空间**，而SkipList的**操作性能**会更好。  所以，对于少量数据，ZipList更好，因为它的内存开销很小，而且性能也可以接受（N越小，logN和N的差别更小）。但是当数据量大到一定程度时，SkipList的 O(log N) 性能会显著优于ZipList 的 O(N) 性能，尤其是涉及到范围查询和顺序遍历时。  所以，默认情况下，当元素数量少于128，每个元素的长度都小于64字节的时候，ZSet使用ZipList（ListPack），否则，使用SkipList！ |                                                              |
| 为什么Lua脚本可以保证原子性                                  | Lua脚本可以保证原子性，因为Redis会将Lua脚本封装成一个单独的事务，而这个单独的事务会在Redis客户端运行时，由Redis服务器自行处理并完成整个事务，如果在这个进程中有其他客户端请求的时候，Redis将会把它暂存起来，等到 Lua 脚本处理完毕后，才会再把被暂存的请求恢复。 |                                                              |
| 为什么Redis不支持回滚                                        | 总结一下，因为Redis的**设计就是简单、高效**等，所以引入事务的回滚机制会让系统更加的复杂，并且影响性能。从使用场景上来说，Redis一般都是被用作缓存的，不太需要很复杂的事务支持，当人们需要复杂的事务时会考虑持久化的关系型数据库。相比于关系型数据库，Redis是通过单线程执行的，在执行过程中，出现错误的概率比较低，并且这些问题一般来编译阶段都应该被发现，所以就不太需要引入回滚机制。  不支持回滚，是因为它本质上是一个高性能的内存数据库，采用**单线程**模型，追求极致的速度和简单性，并未实现复杂的事务隔离和持久化机制。虽然Redis**支持简单的事务（MULTI/EXEC）**和部分原子操作，但没有像传统关系型数据库那样的回滚（ROLLBACK）功能，因此一旦数据写入就无法撤销或自动恢复，只能通过额外的补偿逻辑手动修正。这是Redis在架构设计上为保证高并发和高性能所作出的权衡。 |                                                              |
| Redis的事务和Lua之间有哪些区别？                             | 事务和Lua都是可以保证原子性操作的，但是，这里说的原子性我们提过很多次，指的是不可拆分，不可中断的原子性操作。所以，需要注意的是，不管是Redis的事务还是Lua，都没办法回滚，一旦执行过程中有命令失败了，都是不支持回滚的。  **但是，Redis的事务在执行过程中，如果有某一个命令失败了，是不影响后续命令的执行的，而Lua脚本中，如果执行过程中某个命令执行失败了，是会影响后续命令执行的。** |                                                              |
| redis做分布式锁与zookeeper做分布式锁的区别                   | Redis和ZooKeeper都可以实现分布式锁，但原理和适用场景不同。Redis分布式锁基于`setnx`和`过期时间`，性能高，适合高并发场景，但在主从切换时可能存在锁丢失的风险；ZooKeeper则通过`临时顺序节点`和`watch机制`实现分布式锁，强一致性更好，适合对一致性要求高的场景，比如分布式协调，但性能略低，实现稍复杂。简单来说，Redis锁快但一致性略弱，ZooKeeper锁慢但更稳健。 |                                                              |

## 【Java基础】

| Problems                                                     | Hints                                                        | Solution                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 现在JDK的最新版本是什么？                                    | 半年一个版本：每年3月和9月发行；最近是2025年3月JDK24发布，预计下一个2025年9月JDK25发布； 最近的LTS（ Long Term Support ）版本是JDK 21 |                                                              |
| JDK新版本中都有哪些新特性？                                  | JDK 8中推出了Lambda表达式、Stream、Optional、新的日期API等； JDK 9中推出了模块化 ；JDK 10中推出了本地变量类型推断； JDK 12中增加了switch表达式； JDK 13中增加了text block； JDK 14中增加了Records JDK 14中增加了instance模式匹配； JDK 15中增加了封闭类 JDK； 17中扩展了switch模式匹配； JDK 21中增加了虚拟线程；【目前Java还没有引入协程】 | [Editorial](./Java基础/JDK新版本中都有哪些新特性？.md)       |
| 虚拟线程与协程对比                                           | 协程是一种比线程更轻量的并发模型。它支持**挂起**和**恢复**，让程序可以在任意位置中断并恢复执行。 | [Editorial](./Java基础/虚拟线程与协程对比.md)                |
| 双亲委派机制是什么？                                         | 是Java类加载器（ClassLoader）中的一种工作原理。  主要用于**解决类加载过程中的安全和避免重复加载的问题**。 | [Editorial](./Java基础/双亲委派机制.md)                      |
| .class文件是JVM编译的吗？                                    | 不是，是javac将`.java`文件编译成`.class`文件，JVM只负责执行`.class`文件 |                                                              |
| 什么是类加载器？如何实现自定义类加载器？                     | **类加载器类型、双亲委派流程、定制场景和实现方式**要熟记。  记得举例：Tomcat 热部署、SPI 插件机制、加密 class 加载等。  刷题口诀：   类加载三类清  双亲委派防篡改  自定义 loader 灵活用 | [Editorial](./Java基础/什么是类加载器？如何实现自定义类加载器？.md) |
| JDK8和9中类加载器有哪些不同                                  | JDK 1.8 采用传统的双亲委派机制，核心类由 `BootstrapClassLoader` 加载，而 JDK 1.9 引入了模块化系统（JPMS），用 `ModuleClassLoader` 取代了原来的 `ExtClassLoader`，并且类加载器不仅按包名，还要结合模块信息进行类隔离和加载管理，从而提升了安全性和可维护性。 | [Editorial](./Java基础/JDK8和9中类加载器有哪些不同.md)       |
| 介绍一下类加载器                                             | 加载、验证、准备、解析、初始化                               | [Editorial](./Java基础/类加载器.md)                          |
| 编译型语言和解释型语言的区别？                               | **编译型语言**：在程序执行**之前**，整个源代码会被编译成机器码或者字节码，生成可执行文件。执行时直接运行编译后的代码，速度快，但跨平台性较差。<br/>**解释型语言**：在程序执行时，逐行解释执行源代码，不生成独立的可执行文件。通常由解释器动态解释并执行代码，跨平台性好，但执行速度相对较慢。   <br/>典型的编译型语言如C、C++，典型的解释型语言如Python、JavaScript。 Java是编译型语言，但是具有解释型语言的特点。（ 字节码的实际执行是通过 JVM 的解释器完成的 ） |                                                              |
| 抽象类与接口的区别                                           | 当存在“is-a”关系，有共性代码需要复用时用抽象类。  当只需定义能力或规范，或需要多继承时用接口。 | [Editorial](./Java基础/抽象类与接口的区别.md)                |
| 字节流与字符流                                               |                                                              | [Editorial](./Java基础/字节流与字符流.md)                    |
| 枚举类                                                       |                                                              | [Editorial](./Java基础/枚举类.md)                            |
| Java面试基础知识笔记1                                        |                                                              | [Editorial](./Java基础/Java面试基础知识笔记1.md)             |
| Object类有哪些方法                                           | `equals`默认是比地址，不重写就算两个内容一样的对象也不想等，重写了`equals`那么也要重写`hashcode`也要重写，不然放HashMap这种集合查不出来，`toString`默认是输出类名加哈希，调试没法看，项目里面都会重写，打印关键信息，日志一目了然。还有`notify`和`wait`之类是线程通信用的，但必须写在`synchronized`块里面，还有`clone()`是浅拷贝，`finalize`用于资源释放（不推荐使用，Java9已经抛弃），还有`getClass`用于获取对象类信息，反射的时候会用。 |                                                              |
| 介绍一下`finalize`                                           |                                                              | [Editorial](./Java基础/介绍一下finalize.md)                  |
| lambda表达式为什么只能使用final局部变量                      | Java 的 Lambda 表达式只能使用 **final 或实际上未被修改（effectively final）的局部变量**，这是因为 Lambda 捕获的是**变量的值快照而不是变量本身**，只有这样才能保证被捕获变量在 Lambda 执行期间**不会发生变化**，**避免并发和数据不一致问题**，也符合 Java 编译器对**变量作用域和生命周期的管理要求**。 | [Editorial](./Java基础/lambda表达式为什么只能使用final局部变量.md) |
| 反射与封装是否矛盾？如何解决反射破坏封装不安全的问题？       | 反射与封装存在一定矛盾，因为反射可以在运行时突破访问限制，操作对象的私有成员，从而破坏封装性。为解决这一安全隐患，Java通过权限控制、SecurityManager和合理使用反射API等方式进行约束，实际开发中应规范反射用法(代码省查着重查看反射的代码)，新版本 Java（JDK 9及以上）通过模块系统，可以明确限制哪些包可以被反射访问，提高安全性。避免滥用，确保封装不被随意破坏。 | [Editorial](./Java基础/反射与封装是否矛盾？如何解决反射破坏封装不安全的问题.md) |
| 字符串常量是什么时候进入到字符串常量池的？                   | 字符串常量是在编译期间进入字符串常量池的。当Java源码中的字符串字面量（如 `"abc"`）被编译时，编译器会将其加入到class文件的常量池，运行时类加载器加载类时，这些字符串字面量就会被放入方法区的字符串常量池。此外，通过 `String.intern()` 方法，也可以在运行期间将字符串对象显式加入常量池。 |                                                              |
| String中intern的原理是什么？                                 | intern的作用是这样的：  如果字符串池中已经存在一个等于该字符串的对象，`intern()`方法会返回这个已存在的对象的引用；  如果字符串池中没有等于该字符串的对象，`intern()`方法会将该字符串**添加**到字符串池中，并返回对新添加的字符串对象的引用。 |                                                              |
| String是如何实现不可变的？                                   | 1、String类被声明为final，这意味着它不能被继承。那么他里面的方法就是没办法被覆盖的。 2、用final修饰字符串内容的char[]（从JDK 1.9开始，char[]变成了byte[]），由于该数组被声明为final，一旦数组被初始化，就不能再指向其他数组。 3、String类没有提供用于修改字符串内容的公共方法。例如，没有提供用于追加、删除或修改字符的方法。如果需要对字符串进行修改，会创建一个新的String对象。 |                                                              |
| `Arrays.sort`是使用什么排序算法实现的？                      | 基本数据类型和包装类型不同                                   | [Editorial](./Java基础/Arrays_sort排序算法.md)               |
| 为什么JDK 9中把String的char[]改成了byte[]？                  | JDK 9将String的底层实现由char[]改为byte[]，主要是为了节省内存和提升性能，因为很多字符串只包含Latin-1字符，只需要1个字节存储，而不是原来的2字节char，优化后英文等常用字符串能显著节省空间，同时也让字符串处理更高效。  如果是非拉丁文字母，还是沿用之前char[]的方案。 |                                                              |
| ClassNotFoundException和NoClassDefFoundError的区别是什么？   | `ClassNotFoundException`是一个**受检异常**（checked exception）。他通常在运行时，在类加载阶段尝试加载类的过程中，找不到类的定义时触发;  `NoClassDefFoundError`是一个**错误**（error），它表示运行时尝试加载一个类的定义时，虽然找到了类文件，但在加载、解析或链接类的过程中发生了问题。这通常是由于依赖问题或类定义文件（.class文件）损坏导致的。也就是说这个类在编译时存在，运行时丢失了，就会导致这个异常。 |                                                              |
| while(true)和for(;;)哪个性能好？                             | 对class文件进行反编译，一模一样；只是`while(true)`  有的IDE会警告 |                                                              |
| char能存储中文吗？                                           | 能！ 在Java中，char类型是用来表示一个16位（2个字节）的Unicode字符，它可以存储任何Unicode字符集中的字符，当然也包括中文字符。 【一个字节8位】 |                                                              |
| 什么是UUID，能保证唯一吗？                                   | UUID（通用唯一识别码）是一种用于标识信息的128位标识符，常用于分布式系统中。它通过算法确保全球范围内生成的ID几乎不会重复，实际应用中可以认为是唯一的，因此常被用作数据库主键或唯一标识。    Version 1和Version 2 这两个版本的UUID，主要基于**时间**和**MAC地址。**  Version 3和 Version 5 这两种UUID都是基于**名称空间**的，所以在一定范围内是唯一的，而且如果有需要生成重复UUID的场景的话，这两种是可以实现的。  Version 4 这种是最简单的，只是基于**随机数**生成的，但是也是**最不靠谱**的。适合数据量不是特别大的场景下。  实际开发中几乎可以保证唯一，但是不能绝对保证。  v4最常用 |                                                              |
| 常见的语法糖有哪些？                                         | 常见的语法糖有 switch支持枚举及字符串、泛型、条件编译、断言、可变参数、自动装箱/拆箱、枚举、内部类、增强for循环、try-with-resources语句、lambda表达式等。  jdk本身不支持语法糖，在编译阶段一个重要的步骤就是`desuger()` |                                                              |
| 介绍一下api与spi                                             | API（应用程序编程接口）是软件系统之间进行功能调用的约定，主要为外部提供服务和功能的访问方式，强调“我能为你做什么”；而SPI（服务提供者接口）则是一种扩展机制，允许开发者基于标准接口自定义实现，强调“你能为我做什么”。API通常用于**调用系统功能**，SPI则用于**系统发现并加载第三方扩展或插件**。合理区分和运用API与SPI，有助于系统的模块化和可扩展性设计。 | [Editorial](./Java基础/介绍一下api与spi.md)                  |
| 介绍一下RPC框架                                              | RPC框架（Remote Procedure Call Framework），即**远程过程调用框架**，是分布式系统中常用的通信技术。它能够让我们像调用本地方法一样调用远程服务器上的服务，屏蔽了底层的网络细节，提高了开发效率。常见的RPC框架如gRPC、Dubbo等，通常具备高性能、跨语言、服务治理等特点。通过使用RPC框架，系统各模块可以灵活解耦，便于扩展和维护，是**微服务架构**不可或缺的基础组件。 |                                                              |
| 为什么BigDecimal不能用equals()                               | 需要使用compareTo()， equals方法和compareTo并不一样，equals方法会比较两部分内容，分别是值（value）和标度（scale） ，其中0.1与0.10不相等。   假设有一个BigDecimal表示的数值是123.45，那么无标度值（Unscaled Value）是12345。标度（Scale）是2。因为123.45 = 12345 × 10^(-2)。 |                                                              |
| BigDecimal(double)和BigDecimal(String)有什么区别？           | 因为double是不精确的，所以使用一个不精确的数字来创建BigDecimal，得到的数字也是不精确的。如0.1这个数字，double只能表示他的近似值。 只能使用String创建。 |                                                              |
| Java本地缓存                                                 | 原生实现：HashMap、ConcurrentHashMap;  Guava Cache;  Caffeine;  Ehcache;  Spring Cache | [Editorial](./Java基础/Java本地缓存.md)                      |
| Java 中 try-with-resources 与 try-catch-finally 详细讲解     | try-with-resources只适合实现了`AutoCloseable`接口的对象，并且资源关闭顺序与声明顺序相反（也很好理解，类似出栈操作） | [Editorial](./Java基础/Java中try-with-resources与try-catch-finally详细讲解.md) |
| 动态数组的实现有哪些？                                       | ArrayList和Vector都支持动态扩容，都属于动态数组。 **都是在元素数量超过当前容量时自动扩容**。    **线程安全性**：Vector是线程安全的，ArrayList不是线程安全的。  **扩容策略**：ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍。 |                                                              |
| HashMap 的扩容条件是什么？                                   | Java7扩容需要满足两个条件：   1、当前数据存储的数量（即size()）大小必须大于等于阈值 ；2、当前加入的数据是否发生了hash冲突。    Java8只需要满足**条件1**。 | [Editorial](./Java基础/HashMap的扩容条件是什么.md)           |
| ArrayList 扩容机制                                           | 初始为10，每次扩容为原来的1.5倍，LinkedList不扩容            | [Editorial](./Java基础/ArrayList扩容机制.md)                 |
| HashMap与ConcurrentHashMap扩容注意事项                       | 建议构造时自定义容量                                         | [Editorial](./Java基础/HashMap与ConcurrentHashMap扩容注意事项.md) |
| OS线程是什么？                                               | **操作系统线程**； 操作系统线程（内核线程）是由操作系统直接管理的，能真正实现多核并发； 用户线程是在用户程序层面管理的，比如由JVM或协程库调度，操作系统只看到进程而不直接管理线程，切换开销更小，但不能真正利用多核并发。 简单说，**内核线程更强大，用户线程更轻量。** | [Editorial](./Java基础/OS线程是什么.md)                      |
| 线程池的创建方式                                             | 1、使用Executors工具类，`Executors.newFixedThreadPool(5)`、`Executors.newSingleThreadExecutor();`、`Executors.newScheduledThreadPool(3);`2、使用 `ThreadPoolExecutor` 构造函数自定义；3、用 Spring，可以用 `ThreadPoolTaskExecutor` 做线程池管理： | [Editorial](./Java基础/线程池的创建方式.md)                  |
| 谈谈你对线程池的理解                                         | **7个参数**：corePoolSize（核心线程数量）、 **maximumPoolSize** （ 线程池中最多可容纳的线程数量 ）、 **keepAliveTime** （ 当线程池中线程的数量大于corePoolSize，并且某个线程的空闲时间超过了keepAliveTime，那么这个线程就会被销毁。 ）、 **unit** （ 就是keepAliveTime时间的单位。 ） 、**workQueue** （工作队列）、 **threadFactory **（线程工厂，一般自定义） 、**handler**（拒绝策略） | [Editorial](./Java基础/谈谈你对线程池的理解.md)              |
| 线程池为什么要构建空任务的**非核心线程**                     | **线程池会暂时保留空闲的非核心线程，是为了应对突发任务，减少线程频繁创建和销毁的开销，提高系统响应性能。** | [Editorial](./Java基础/线程池为什么要构建空任务的非核心线程.md) |
| 线程池的参数如何设置                                         | 核心线程数、最大线程数、等待队列、拒绝策略                   | [Editorial](./Java基础/线程池的参数如何设置.md)              |
| 什么时候需要自定义线程工厂？给出代码例子                     | 自定义线程工厂主要用于对线程进行统一管理，比如设置有意义的**线程名称**，方便排查问题和日志追踪；**配置守护线程、线程优先级**等属性；**统一处理未捕获的异常**，提升系统健壮性。在实际开发中，只要需要对线程进行特殊设置或更好的运维监控，就应该自定义线程工厂。 | [Editorial](./Java基础/什么时候需要自定义线程工厂？给出代码例子.md) |
| Java 里面线程有哪些状态?                                     | new、Runnable、blocked、waiting、timed_waiting、terminated； | [Editorial](./Java基础/Java里面的线程状态.md)                |
| wait 状态下的线程如何进行恢复到 running 状态?                | 等待的线程**被其他线程对象唤醒**，`notify()`和`notifyAll()`。  如果线程**没有获取到锁**则会直接进入 Waiting 状态，其实这种本质上它就是执行了 LockSupport.park() 方法进入了Waiting 状态，那么解锁的时候会执行`LockSupport.unpark(Thread)`，与上面park方法对应，给出许可证，**解除等待状态**。 |                                                              |
| notify 和 notifyAll 的区别?                                  | **notify 只唤醒一个线程，其他线程仍在等待，若该线程未调用 notify，其余线程可能永远无法唤醒。**  **notifyAll 唤醒所有等待线程，它们竞争锁，最终只有`一个`线程执行，剩余线程继续等待锁释放。** |                                                              |
| notify 选择哪个线程?                                         | notify在源码的注释中说到notify选择唤醒的线程是**任意的**，但是依赖于具体实现的jvm。     JVM有很多实现，比较流行的就是hotspot，hotspot对notify()的实现并不是我们以为的随机唤醒,，而是**“先进先出”**的顺序唤醒。 |                                                              |
| 介绍一下sleep()、wait()、join()。                            | 都与多线程有关                                               | [editorial](./Java基础/介绍一下sleep、wait、join.md)         |
| Java 中 Condition 的理解                                     | **Condition** 是 `java.util.concurrent.locks` 包中的一个接口，配合 `Lock`（比如 `ReentrantLock`）使用，用于实现比 `Object.wait()`/`notify()` 更加灵活的线程协作机制。 | [Editorial](./Java基础/Java中Condition的理解.md)             |
| 如何停止一个线程的运行?                                      | 1、使用标志位；2、使用`interrupt()`；3、结合`interrupt()`和标志位；4、使用 `FutureTask.cancel(true)`    因为**线程在调用 sleep()、wait()、join() 等方法时会进入阻塞（等待）状态**，而这些方法都声明了会抛出 `InterruptedException`。这样设计有以下原因： **强制开发者关注中断处理**、**中断是线程之间协作的一种机制**、**清理资源，安全退出** | [Editorial](./Java基础/如何停止一个线程的运行.md)            |
| 介绍NIO BIO AIO？                                            | BIO（同步阻塞）：传统 I/O 模式，适用于 小规模连接。 NIO（同步非阻塞）：通过 Selector 实现 多路复用，适用于 高并发。 AIO（异步非阻塞）：基于 回调机制，适用于 超高并发、长连接。 | [Editorial](./Java基础/介绍NIOBIOAIO.md)                     |
| volatile可见性例子                                           | volatile用于保证内存的可见性，可以将其看做是轻量级的锁，它具有如下的内存语义：<br>写内存语义：当写一个volatile变量时，JMM会把该线程本地内存中的共享变量的值刷新到主内存中。<br>读内存语义：当读一个volatile变量时，JMM会把该线程本地内存置为无效，使其从主内存中读取共享变量。<br>volatile只能保证单个变量读写的原子性，而锁则可以保证对整个临界区的代码执行具有原子性。所以，在功能上锁比volatile更强大，在可伸缩性和性能上volatile更优优势。<br><br>加分回答<br>volatile的底层是采用内存屏障来实现的，就是在编译器生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。内存屏障就是一段与平台相关的代码，Java中的内存屏障代码都在Unsafe类中定义，共包含三个方法：LoadFence()、storeFence()、fullFence()。 | [Editorial](./Java基础/volatile可见性例子.md)                |
| volatile 保证原子性吗？                                      | volatile关键字并没有保证我们的变量的原子性，volatile是Java虚拟机提供的一种轻量级的同步机制，主要有这三个特性：**保证可见性** 、**不保证原子性**、**禁止指令重排** 使用 `synchronized`来保证原子性 |                                                              |
| synchronized 支持重入吗？如何实现的?                         | ✔ **synchronized 支持重入**，同一线程可多次获取同一把锁。  ✔ **通过对象头的“锁计数器”实现**，锁被同一线程持有时计数递增，释放时递减。  ✔ **避免死锁**，允许父子类方法或递归调用顺利执行。 🚀 | [Editorial](./Java基础/synchronized支持重入吗.md)            |
| Java创建线程有几种方式                                       | 继承Thread类，重写`run()`方法； 实现Runnable接口并实现`run()`方法，然后将实现了Runnable接口的类传递给Thread类； 使用Callable和Future接口通过Executor框架创建线程；通过线程池方式创建。 | [Editorial](./Java基础/Java创建线程有几种方式.md)            |
| 线程池有哪些优势？                                           | **减少线程创建和销毁的开销**：频繁地创建和销毁线程会消耗大量系统资源，线程池通过重用已存在的线程来减少这种开销。  **提高响应速度**：当任务到达时，无需等待线程的创建即可立即执行，因为线程池中已经有等待的线程。 |                                                              |
| 说一下面向对象3大特性理解？                                  | 封装、继承、多态                                             | [Editorial](./Java基础/说一下面向对象3大特性理解.md)         |
| Java有什么常用的集合类？                                     | Collection：List、Set、Queue；Map                            | [Editorial](./Java基础/Java有什么常用的集合类.md)            |
| 你能说出几种集合的排序方式？                                 | 实现Comparable（类里面重写`compareTo`）、 借助Comparator （比较器）、 通过Stream | [Editorial](./Java基础/你能说出几种集合的排序方式.md)        |
| 遍历的同时修改一个List有几种方式？                           | 迭代器、copy一份副本、使用并发安全的集合类、Stream的过滤方法【 因为Stream每次处理后都会生成一个新的Stream，不存在并发问题，所以Stream的filter也可以修改list集合。（建议，简单高效） 】 |                                                              |
| 有哪些集合类是线程安全的，哪些是不安全的？                   | **Vector、HashTable、Properties是线程安全的；**  **ArrayList、LinkedList、HashSet、TreeSet、HashMap、TreeMap等都是线程不安全的。** |                                                              |
| ArrayList和LinkedList区别？                                  | 都实现了**List**接口 ，底层数据结构、插入删除元素效率、随机访问效率、空间占用、使用场景、线程安全 | [Editorial](./Java基础/ArrayList和LinkedList区别.md)         |
| 讲下HashMap？                                                | 从JDK1.7【数组+链表】与JDK1.8【小于8使用链表，超过8使用红黑树】回答 | [Editorial](./Java基础/讲下HashMap？.md)                     |
| 讲下ConcurrentHashMap？                                      | JDK1.7【数组+链表】JDK1.8【 数组 + 链表/红黑树 】            | [Editorial](./Java基础/讲下ConcurrentHashMap？.md)           |
| 讲下阻塞队列？                                               | 阻塞队列（BlockingQueue）是一种支持**阻塞插入和阻塞获取**的队列，它可以在 **生产者-消费者模型** 中高效地实现**线程安全的数据交换**。 | [Editorial](./Java基础/阻塞队列.md)                          |
| 讲下线程安全的List？                                         | 常见的线程安全的List实现包括 `Collections.synchronizedList` 和 `CopyOnWriteArrayList` 【适合频繁读写】。补充一个`vector` | [Editorial](./Java基础/讲下线程安全的List？.md)              |
| 实际中类加载会遇到哪些问题？                                 | **类找不到（ClassNotFoundException）** 、   **类定义冲突（NoClassDefFoundError）** 、   **类版本不匹配（UnsupportedClassVersionError）** 、   **类加载死锁** 、   **双亲委派模型导致的类加载问题** 、   **热部署、类卸载失败** 、   **不同 ClassLoader 加载同一类** | [Editorial](./Java基础/实际中类加载会遇到哪些问题.md)        |
| 解释一下什么是可重入锁                                       | **同一个线程可以对同一把锁进行重复加锁**                     | [Editorial](./Java基础/解释一下什么是可重入锁.md)            |
| Java中有哪些常用的锁，在什么场景下使用？                     | ` synchronized 、 ReentrantLock 、 ReentrantReadWriteLock 、 StampedLock 、 Semaphore、CountDownLatch、CyclicBarrier `     **Semaphore（信号量）** 是一种计数信号量，用来控制同时访问某个资源的线程数量。它可以用来实现限流，比如只允许最多N个线程同时访问某个临界区。常用于连接池、限流等场景。 **CountDownLatch**  允许一个或多个线程等待，直到其他线程完成一组操作。它内部有一个计数器，调用 `countDown()` 会使计数减一，直到为0时，等待的线程才能继续执行。常用于主线程等待多个子任务完成再继续。 **CyclicBarrier** 用于让一组线程到达一个屏障点时被阻塞，直到所有线程都到达后一起继续执行。它可以循环使用，适合多线程分阶段协作，比如多线程分段计算，然后统一汇总结果。【分治】 | [Editorial](./Java基础/Java中有哪些常用的锁，在什么场景下使用？.md) |
| 什么是反射？有哪些使用场景？                                 | Java 反射机制是在**运行状态中**，对于**任意一个类**，都能够知道这个类中的**所有属性和方法**，对于任意一个**对象**，都能够调用它的任意一个**方法和属性**；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。 常用于框架、工具库、JDBC、插件机制等场景。 | [Editorial](./Java基础/什么是反射，有哪些使用场景.md)        |
| ThreadLocal的作用和使用场景？                                | `ThreadLocal` 是Java提供的**线程本地变量**，每个线程都拥有独立的变量副本。它最常用于为每个线程提供独立的存储空间，避免多线程间的数据竞争，常见于用户会话、数据库连接、事务管理等场景。  自定义ThreadLocal初始化：重写 initialValue 或用 withInitial | [Editorial](./Java基础/ThreadLocal作用和使用场景.md)         |
| ThreadLocal、Thread、ThreadLocalMap之间的联系                | ThreadLocal就是**保险柜的**钥匙，Thread就是房间，ThreadLocalMap就是保险柜（每个Thread里面都有一个ThreadLocalMap）；                                                             **get()操作：**首先我们会根据**当前的线程**走到对应的房间，然后用ThreadLocal这个钥匙打开ThreadLocalMap保险柜取出我们想要的。                                                              **set()操作：**首先我们会根据**当前的线程**走到对应的房间，然后用ThreadLocal这个钥匙打开ThreadLocalMap保险柜，将我们需要存放的数据放进去。  **每个房间（线程）都有自己的保险柜（ThreadLocalMap），保险柜里可以用不同钥匙（ThreadLocal对象）开不同的格子，每个格子存的是本线程的数据。 **  **钥匙（ThreadLocal）在不同房间能开出不同的数据，互不干扰。**                                                **保险柜的设计让每个线程可以存很多种类型的数据（用不同的钥匙），而且可以自动管理和清理失效的数据（用弱引用防止内存泄漏）。** |                                                              |
| ThreadLocal会造成内存泄漏吗？为什么？                        | 是的，可能会。ThreadLocalMap中的key为ThreadLocal的弱引用，value为强引用。**如果ThreadLocal实例被回收但线程还在运行，value对象不会被及时回收**，造成内存泄漏（尤其在线程池环境下）。但是当线程结束，还是会被回收，这里的value会变成不可达对象。 |                                                              |
| ThreadLocal 为什么把key设计成弱引用，value设计成强引用；为什么key设为弱引用就不怕提前回收？如果把threadLocal设为静态变量还会有这个问题吗？ |                                                              | [Editorial](./Java基础/ThreadLocal追问.md)                   |
| 调用 interrupt 是如何让线程抛出异常的?                       | 每个线程都有一个初始值为 `false` 的中断状态，`interrupt()` 会更新该状态。  若线程在 `sleep()`、`join()`、`wait()` 等可中断方法中，会抛出 `InterruptedException` 并解除阻塞；否则，仅设置中断状态，线程可轮询决定是否停止。 |                                                              |
| 如果是靠变量来停止线程，缺点是什么?                          | 缺点是中断可能不够及时，循环判断时会到下一个循环才能判断出来。 |                                                              |
| 什么是不可变对象（Immutable Object）？Java中如何实现不可变对象？ | 不可变对象：final类 + final字段 + 无setter + 深拷贝引用类型字段，线程安全、可作哈希键、设计简单。 | [Editorial](./Java基础/什么是不可变对象（ImmutableObject）？Java中如何实现不可变对象？.md) |
| 什么是Java中的自动装箱与拆箱（Autoboxing & Unboxing）？      | 自动装箱/拆箱：基本类型与包装类型自动转换，常见于集合和运算，注意性能和空指针风险。 | [Editorial](./Java基础/什么是Java中的自动装箱与拆箱（Autoboxing&Unboxing）？.md) |
| 什么是泛型？Java 泛型的原理和常见使用场景?                   | **泛型**允许在类、接口、方法中使用类型参数，实现代码的类型安全和重用。底层类型擦除，常用于集合、自定义通用类和方法。 | [Editorial](./Java基础/什么是泛型（Generics）？Java泛型的原理和常见使用场景？.md) |
| 类型擦除                                                     | 类型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java代码直接转换成普通java字节码。 |                                                              |
| 泛型中K T V E ？ Object等分别代表什么含义。                  | K/T/V/E 等是泛型中的惯用表示，K代表键，V代表值，T代表类型，E代表元素，仅为约定俗成，实际用法可自定义，但建议遵循规范。Object 是普通类，不是泛型专用字母。 |                                                              |
| 什么是Java中的序列化？常见的应用场景有哪些？                 | 序列化：对象转字节流用于存储或传输，常用于网络通信、持久化、分布式系统。实现`Serializable`，配合ObjectOutputStream/ObjectInputStream使用。 | [Editorial](./Java基础/什么是Java中的序列化？常见的应用场景有哪些？.md) |
| 什么是Java中的深拷贝与浅拷贝？它们的区别是什么？             | 深拷贝复制对象及其引用对象，浅拷贝只复制`引用地址`。深拷贝两对象完全独立，浅拷贝引用类型字段会相互影响。 | [Editorial](./Java基础/什么是Java中的深拷贝与浅拷贝？它们的区别是什么？.md) |
| Java中创建对象有哪些种方式                                   | 使用`new`、反射、`clone()`、反序列化、方法句柄、unsafe分配内存 |                                                              |
| 介绍一下方法句柄                                             | **方法句柄**可以理解为一种“方法的遥控器”。它是 Java 里的一种工具，能够帮你**间接地调用某个方法**，而不是直接写代码去调用。 |                                                              |
| Java注解                                                     | 注解（Annotation）是Java中一种特殊的语法，用于**在代码中添加元信息**。它通常以“@注解名”的形式出现，可以标记类、方法、字段等。注解本身不会直接影响程序逻辑，但可以被编译器或运行时工具读取，用于实现自动化处理、配置、代码生成等功能。常见的注解有@Override、@Deprecated、@Autowired等，是简化开发和增强代码可读性的有效手段。 元注解：用于实现注解的注解 |                                                              |
| serialVersionUID 有何用途? 如果没定义会有什么问题？          | serialVersionUID 是 Java 序列化机制中用于**标识类版本的唯一ID**。它保证在对象序列化和反序列化时**类的兼容性**。如果没有显式定义 serialVersionUID，JVM 会根据类结构自动生成一个，但如果类发生变化（比如字段或方法调整），自动生成的值也会改变，导致反序列化时抛出 **InvalidCastException** 或 **IncompatibleClassChangeError**。因此，建议自定义 serialVersionUID，以确保序列化兼容性和稳定性。 |                                                              |
| 一段话谈谈你对枚举的认识                                     | 枚举（Enum）是Java中一种特殊的类型，用于定义一组**固定的常量集合**。通过枚举可以让代码更加清晰、类型安全，避免了魔法数字或字符串的使用。枚举不仅可以有自己的属性和方法，还能和其他类一样实现接口，适用于表示状态、类别等有限且明确的取值场景，是提高代码可读性和维护性的有力工具。 |                                                              |
| 为什么说枚举是实现单例最好的方式？                           | 1、枚举实现的单例写法简单  2、枚举实现的单例天然是线程安全的  3、枚举实现的单例可避免被反序列化破坏 | [Editorial](./Java基础/为什么说枚举是实现单例最好的方式？.md) |
| 什么是Java中的内部类？有哪些类型？实际开发中如何使用？       | 内部类有成员、静态、局部、匿名四种，常用于封装辅助逻辑、事件回调和隐藏实现细节。可访问外部类成员，简化开发。 | [Editorial](./Java基础/什么是Java中的内部类？有哪些类型？实际开发中如何使用？.md) |
| 什么是Java中的Lambda表达式？常见的使用场景有哪些？           | Lambda表达式用于**简化单方法接口实现**，常用于集合操作、线程、回调等场景，使代码更简洁明了。 | [Editorial](./Java基础/什么是Java中的Lambda表达式？常见的使用场景有哪些？.md) |
| lambda表达式能用于多方法接口的简化吗？                       | 不能。**lambda表达式在Java中只能用于函数式接口**（Functional Interface）的简化，而函数式接口的定义是**只包含一个抽象方法的接口**（即Single Abstract Method，简称SAM接口）。 | [Editorial](./Java基础/lambda表达式能用于多方法接口的简化吗？.md) |
| 什么是Java中的泛型擦除（Type Erasure）？泛型擦除带来了哪些限制？ | Java泛型编译后类型被擦除，运行时无泛型信息，限制了泛型数组、类型判断等操作，常需用Class参数或反射辅助。 | [Editorial](./Java基础/什么是Java中的泛型擦除（TypeErasure）？泛型擦除带来了哪些限制？.md) |
| 什么是Java中的注解（Annotation）？常见的应用场景有哪些？     | 注解用于为代码添加元数据，常见于编译检查、框架配置、自动化文档和运行时反射。支持自定义，便于自动化和解耦。 | [Editorial](./Java基础/什么是Java中的注解（Annotation）？常见的应用场景有哪些？.md) |
| 什么是JDK、JRE和JVM？三者有什么区别？                        | JDK用于开发，JRE用于运行，JVM用于跨平台。JDK包含JRE，JRE包含JVM。 | [Editorial](./Java基础/什么是JDK、JRE和JVM？三者有什么区别？.md) |
| 解释Java的跨平台原理（“一次编写，到处运行”）是如何实现的？   | Java 跨平台靠 JVM，不同平台有不同 JVM，只需编译一次字节码，就能在多种系统运行。 | [Editorial](./Java基础/解释Java的跨平台原理（“一次编写，到处运行”）是如何实现的？.md) |
| Java中的String和StringBuilder、StringBuffer有什么区别？      | String不可变，适合少量拼接；StringBuilder高效适合单线程拼接；StringBuffer线程安全适合多线程。 | [Editorial](./Java基础/Java中的String和StringBuilder、StringBuffer有什么区别？.md) |
| 简述Java类与对象的关系。                                     | 类是`模板`，对象是`实例`。类描述属性和行为，对象具体持有数据并能执行操作。 | [Editorial](./Java基础/简述Java类与对象的关系。.md)          |
| 什么是构造方法？构造方法的特点和作用是什么？                 | 构造方法用于对象创建时初始化，方法名与类名一致，无返回值，可重载。 | [Editorial](./Java基础/什么是构造方法？构造方法的特点和作用是什么？.md) |
| 什么是方法重载（Overload）和方法重写（Override）？有何区别？ | 重载是同类中方法名相同参数不同，重写是子类改变父类方法实现，二者关注点不同。 | [Editorial](./Java基础/什么是方法重载（Overload）和方法重写（Override）？有何区别？.md) |
| 什么是this关键字？Java中this的常用场景有哪些？               | this代表当前对象，常用于区分同名变量、调用本类其他构造及返回自身实例。 | [Editorial](./Java基础/什么是this关键字？Java中this的常用场景有哪些？.md) |
| 什么是static关键字？它的常见用途有哪些？                     | static修饰的成员属于类本身，常用于共享变量、工具方法、静态初始化和内部类。 | [Editorial](./Java基础/什么是static关键字？它的常见用途有哪些？.md) |
| 什么是包（package）？Java中包的作用是什么？                  | 包用于组织类，防止命名冲突，便于管理和控制访问，建议用域名倒序命名。 | [Editorial](./Java基础/什么是包（package）？Java中包的作用是什么？.md) |
| Java中的访问修饰符有哪些？分别有什么作用？                   | 四种访问修饰符：private最严格，public最开放，default包内可见，protected包及子类可见。 | [Editorial](./Java基础/Java中的访问修饰符有哪些？分别有什么作用？.md) |
| 什么是 Java 内存模型（Java Memory Model, JMM）？它解决了哪些问题？请举例说明 JMM 如何影响多线程程序的正确性。 | JMM 三大性，主内存/工作内存分离，volatile 保可见，synchronized 保原子，写多线程一定牢记！ | [Editorial](./Java基础/什么是Java内存模型（JavaMemoryModel,JMM）？它解决了哪些问题？请举例说明JMM如何影响多线程程序的正确性。.md) |
| 什么是乐观锁与悲观锁？它们的实现方式和适用场景各是什么？     | - 乐观锁适合读多写少，性能高但可能要重试（如 CAS）。 - 悲观锁适合写多读少，安全但效率低（如 synchronized）。 - 典型面试点：CAS、AtomicXXX、数据库版本号、synchronized 区别和应用。 | [Editorial](./Java基础/什么是乐观锁与悲观锁？它们的实现方式和适用场景各是什么？.md) |
| 为什么感觉所有的锁都适合读多写少的场景呢？有没有适合写多读少场景的锁？ | 写多：普通互斥锁、分段锁（ConcurrentHashMap）、无锁结构（队列、栈）; 读多： 读写锁、共享锁 | [Editorial](./Java基础/为什么感觉所有的锁都适合读多写少的场景呢？有没有适合写多读少场景的锁？.md) |
| 什么是CAS（Compare-And-Swap）？它在Java中的实现原理、优缺点以及应用场景是什么？ | - CAS 是无锁并发的核心，compare-and-swap原理+自旋重试机制。 - 优点：高性能，无阻塞。缺点：ABA、自旋、单变量。 - 面试常考：CAS原理、ABA问题、CAS与synchronized对比及适用场景。 | [Editorial](./Java基础/什么是CAS（Compare-And-Swap）？它在Java中的实现原理、优缺点以及应用场景是什么？.md) |
| 什么是AQS的原理、应用及常见实现有哪些？                      | AQS 用 state + 队列统一管理同步器，实现锁/信号量/闭锁等并发工具 - 原理：CAS修改state，失败则排队阻塞，唤醒后重试 - 常用同步器（ReentrantLock、Semaphore、CountDownLatch 等）都基于AQS - 面试重点：AQS的队列原理、独占与共享模式、模板方法设计 | [Editorial](./Java基础/什么是AQS（AbstractQueuedSynchronizer）？AQS的原理、应用及常见实现有哪些？.md) |
| AQS的同步队列与条件队列                                      | AQS（AbstractQueuedSynchronizer）内部维护两种队列：**同步队列**和**条件队列**。 同步队列用于管理所有请求锁但未获得锁的线程，采用双向链表实现，线程被阻塞时会被挂到同步队列尾部，只有队首线程才有资格竞争锁； 条件队列则用于实现等待/通知机制（如 await、signal），当线程调用条件的 await() 方法时，会被从同步队列移到条件队列，等待被 `signal()` 唤醒后重新加入同步队列参与锁竞争。 核心原理是利用队列管理线程的排队和唤醒，实现锁和条件变量的高效等待与通知 | [Editorial](./Java基础/AQS的同步队列与条件队列.md)           |
| 什么是AQS的独占模式和共享模式？                              | 当需要保证某个资源或一段代码在同一时间内只能被一个线程访问时，**独占模式**是最合适的选择。如我们经常用的ReentrantLock和ReadWriteLock中的写锁。    当资源或数据主要被多个线程读取，而写操作相对较少时，**共享模式**能够提高并发性能。如我们经常使用的Semaphore和CountDownLatch，用来多个线程控制共享资源的。还有ReadWriteLock中的读锁允许多个线程同时读取数据，只要没有线程在写入数据。 |                                                              |
| AQS为什么采用双向链表？                                      | AQS 采用双向链表作为同步队列的底层结构，主要是因为双向链表可以**高效地插入和删除任意节点**。这样在锁竞争或释放时，线程可以方便地挂到队尾，也能快速唤醒和移除队首或中间的节点，有助于实现高性能的线程排队和唤醒机制。此外，双向链表有助于支持条件队列和同步队列之间的节点迁移，提高线程调度的灵活性和效率。 |                                                              |
| AQS源码解读                                                  |                                                              | [Editorial](./Java基础/AQS源码解读.md)                       |
| AQS的底层原理细节与面试要点                                  | 用简明语言描述AQS的结构（state+队列），说明其支持的两种模式； - 能举出常见实现类，并解释其底层原理； - 强调AQS模板方法思想，子类只需实现资源获取/释放逻辑。 | [Editorial](./Java基础/AQS的底层原理细节与面试要点.md)       |
| AQS常见面试追问与补充                                        | AQS是JUC包下锁和同步器的基础框架，核心思想是用CAS保证state原子性，用FIFO队列管理等待线程，通过模板方法支持独占与共享两种模式。常见实现有ReentrantLock、Semaphore、CountDownLatch等。AQS通过高效挂起/唤醒和公平/非公平策略，兼顾了性能和灵活性，是Java并发编程的基石。 | [Editorial](./Java基础/AQS常见面试追问与补充.md)             |
| 零拷贝                                                       | 零拷贝是一种高效的I/O操作技术，它通过消除内核空间和用户空间之间不必要的数据复制来优化数据传输。传统I/O过程中，数据需要经历多次复制：从磁盘到内核缓冲区，再到用户空间缓冲区，然后又回到内核缓冲区才能进行网络传输，这导致CPU资源浪费和内存带宽消耗。零拷贝技术通过直接在内核空间中操作数据，利用诸如**内存映射(mmap)**、**sendfile()**系统调用或**DMA(直接内存访问)**等机制，实现数据从磁盘到网络接口的直接传输，从而避免了这些冗余拷贝。这种技术显著降低了CPU使用率，减少了内存带宽消耗，降低了延迟并提高了吞吐量，特别适用于处理大量数据传输的高性能应用，如Web服务器、文件服务器和流媒体服务。常见实现包括Linux的splice()和sendfile()、Java NIO的transferTo()方法以及各种网络框架中的零拷贝功能。 | [Editorial](./Java基础/零拷贝.md)                            |
| Java NIO 通道（Channel）详解                                 | 里面的方法、作用需要牢记                                     | [Editorial](./Java基础/JavaNIO通道Channel详解.md)            |
| 什么是多线程中的上下文切换？                                 | 上下文切换是指 CPU 从一个线程转到另一个线程时，需要保存当前线程的上下文状态，恢复另一个线程的上下文状态，以便于下一次恢复执行该线程时能够正确地运行。 |                                                              |
| 能不能谈谈你对线程安全的理解？                               | 线程安全是指某个函数在**并发**环境中被调用时，能够正确地处理**多个线程**之间的**共享变量**，使程序功能**正确完成**。 |                                                              |
| 什么是并发，什么是并行                                       | **并发**是指在同一时间段内，多个任务交替进行，但实际上每个时刻只有一个任务在执行（比如单核CPU通过任务切换实现“同时”处理多个任务）；  **并行**则是指在同一时刻，多个任务真正同时进行（比如多核CPU上多个任务分别由不同的核心同时处理）。 |                                                              |
| 什么是守护线程，和普通线程有什么区别？                       | 在Java中有两类线程：`User Thread`(用户线程)、`Daemon Thread`(守护线程) 。用户线程一般用于执行**用户级任务**，而守护线程也就是**“后台线程”**，一般用来执行后台任务，守护线程最典型的应用就是**GC(垃圾回收器)**。  这两种线程其实是没有什么区别的，唯一的区别就是Java虚拟机在所有<用户线程>都结束后就会退出，而不会等<守护线程>执行完。 |                                                              |
| 虚拟线程概述                                                 |                                                              | [Editorial](./Java基础/虚拟线程概述.md)                      |
| 有了虚拟线程，能否抛弃传统线程？                             |                                                              | [Editorial](./Java基础/有了虚拟线程，能否抛弃传统线程？.md)  |
| I/O密集型 vs CPU密集型                                       | cpu计算时间/cpu等待时间占比划分                              | [Editorial](./Java基础/IO密集型vsCPU密集型.md)               |
| JDK21 中的虚拟线程是怎么回事？                               | 虚拟线程是由**JVM直接管理**的轻量级线程，创建和销毁成本极低，可以同时拥有成千上万个，适合高并发场景；而传统线程则直接映射到操作系统的原生线程（**操作系统管理**），数量和资源受限，创建和切换开销较大。虚拟线程让并发编程更简单，无需复杂线程池，代码也更接近同步风格，极大提升了资源利用率和开发效率。 | [Editorial](./Java基础/JDK21虚拟线程.md)                     |
| 为什么虚拟线程不能用synchronized                             | 虚拟线程不能用`synchronized`的主要原因是`synchronized`会阻塞操作系统内核线程，而虚拟线程是映射在少量内核线程上的大量轻量线程。如果虚拟线程用`synchronized`阻塞，会导致底层载体内核线程也被阻塞，从而影响所有挂载在该内核线程上的虚拟线程调度，失去虚拟线程高并发的优势。因此，虚拟线程推荐使用`Lock`等不会阻塞内核线程的同步机制，以充分发挥虚拟线程的高并发性能。 |                                                              |
| 为什么虚拟线程不要和线程池一起用？                           | 虚拟线程不推荐和传统线程池一起使用，因为虚拟线程本身非常轻量，可以高效地创建和销毁，适合为每个任务分配一个独立的虚拟线程。如果用线程池限制虚拟线程的数量，反而会丧失其高并发和弹性优势，还可能导致资源浪费和性能下降。因此，虚拟线程应直接使用，不需要线程池进行复用和管理。 |                                                              |
| 为什么虚拟线程尽量避免使用ThreadLocal                        | 虚拟线程尽量避免使用 `ThreadLocal`，因为虚拟线程的数量非常大且生命周期短，频繁创建和销毁会导致 `ThreadLocal` 数据难以管理，而且 `ThreadLocal` 变量会和虚拟线程一起频繁分配和回收，增加垃圾回收压力，影响性能。此外，虚拟线程可能会被挂起并恢复在不同的载体线程上，导致 `ThreadLocal` 数据不安全或丢失。因此，推荐使用更适合虚拟线程的上下文传递方案，如 `ScopedValue` 或参数传递。 |                                                              |
| run/start、wait/sleep、notify/notifyAll区别?                 |                                                              | [Editorial](./Java基础/runstart、waitsleep、notifynotifyAll区别.md) |
| 线程数设定成多少更合适？                                     | 如果是CPU密集型应用，则线程池大小设置为N+1；如果是IO密集型应用，则线程池大小设置为2N+1 |                                                              |
| 什么是Unsafe？                                               | Unsafe 是Java中一个底层类 。因为Java无法直接访问底层操作系统，而是通过本地（native）方法来访问。不过尽管如此，JVM还是开了一个后门，JDK中有一个类Unsafe，它提供了硬件级别的原子操作。 |                                                              |
| synchronized的锁升级过程是怎样的？                           |                                                              | [Editorial](./Java基础/synchronized的锁升级过程是怎样的？.md) |
| synchronized锁能降级吗？                                     | `synchronized`锁**不能降级**。  锁降级（Lock Downgrade）是指：一个线程持有写锁后，先获取读锁，再释放写锁，从而将锁从写锁降级为读锁。`synchronized`只支持互斥锁（排他锁），不区分读锁和写锁，所以没有锁降级的概念。 如果需要锁降级功能，应该使用`ReentrantReadWriteLock`这样的读写锁。 |                                                              |
| synchronized的重量级锁很慢，为什么还需要重量级锁？           | 在非常激烈竞争的场景下，轻量级锁的**自旋**会导致CPU资源浪费，重量级锁通过阻塞来避免这些资源浪费。对于任务较重的操作，重量级锁能提高系统稳定性，避免性能因频繁自旋而下降。 |                                                              |
| synchronized的锁优化是怎样的                                 | `synchronized` 的锁优化通过锁粗化、锁消除、锁升级和自旋等机制，尽量减少锁竞争带来的性能损耗，提高 Java 并发程序的执行效率。 | [Editorial](./Java基础/synchronized的锁优化是怎样的.md)      |
| CAS在操作系统层面是如何保证原子性的？                        | CAS 的原子性依赖于 **CPU 提供的原子指令**，由硬件层面保障，操作系统无需额外干预。这使得 CAS 能在多线程环境下安全地实现无锁并发。 |                                                              |
| 父子线程之间怎么共享/传递数据？                              | `InheritableThreadLocal` 可以在子线程中继承父线程中的值。在创建子线程时，子线程将复制父线程中的 `InheritableThreadLocal` 变量。 |                                                              |
| 有了InheritableThreadLocal为啥还需要TransmittableThreadLocal？ | 虽然 `InheritableThreadLocal` 可以让子线程自动继承父线程的本地变量，但它**只在创建线程时拷贝一次**，无法解决线程池复用线程时的上下文传递问题。当线程池中的线程被反复复用时，`InheritableThreadLocal` 的值不会自动更新，容易导致上下文污染或丢失。而 `TransmittableThreadLocal` 专门为线程池等复用线程场景设计，能在任务提交时，自动拷贝并恢复父线程的本地变量，确保上下文在异步执行和线程池复用时也能正确传递。因此，`TransmittableThreadLocal` 是对 `InheritableThreadLocal` 在并发框架下的增强和补充。 |                                                              |
| Thread.sleep(0)的作用是什么？                                | 这种用法其实就是让当前线程释放一下CPU时间片，然后重新开始争抢。 |                                                              |
| 为什么不建议通过Executors构建线程池                          | 不建议通过 `Executors` 创建线程池，是为了避免默认参数带来的风险（如 OOM、线程暴增），推荐直接使用 `ThreadPoolExecutor`，手动配置线程池参数，保证系统的稳定和安全。 | [Editorial](./Java基础/为什么不建议通过Executors构建线程池.md) |
| 线程池的拒绝策略有哪些？                                     | **AbortPolicy**	抛出异常，拒绝任务； **CallerRunsPolicy**	由调用线程执行任务 ；**DiscardPolicy**	直接丢弃任务，不抛异常； **DiscardOldestPolicy** 丢弃队列最老任务，尝试提交新任务； |                                                              |
| 为什么JDK 15要废弃偏向锁？                                   | JDK 15 废弃偏向锁，主要因为偏向锁在现代应用和硬件环境下已经难以带来明显性能提升，反而增加了 JVM 的复杂性和维护成本；随着高并发编程模式和线程池等技术普及，偏向锁的设计初衷也逐渐不适用，因此官方选择移除偏向锁，以简化 JVM 实现并更好地优化其他锁机制。 | [Editorial](./Java基础/偏向锁的缺点.md)                      |
| Java是如何判断一个线程是否存活的？                           | 线程是否存活与线程的状态（如 NEW、RUNNABLE、BLOCKED、WAITING、TERMINATED）有关，只有非 TERMINATED 状态的线程才是存活的。 `isAlive()` 不能判断线程是否正在运行，只能判断线程是否还没有终止。 **一句话总结**： Java 通过 Thread.isAlive() 方法判断线程是否存活，即线程是否已经启动且尚未结束。 |                                                              |
| 如何实现主线程捕获子线程异常                                 | **主线程无法直接用 try-catch 捕获子线程的异常**，因为每个线程都有独立的异常处理机制。常见做法是通过线程池的 **Future 结合 Callable**，让主线程在调用 **future.get()** 时捕获子线程抛出的异常；或者为线程设置 **UncaughtExceptionHandler**，在子线程发生未捕获异常时由主线程感知和处理。此外，也可以通过**共享变量**或队列等方式将异常信息传递给主线程，实现异常的统一管理。 | [Editorial](./Java基础/如何实现主线程捕获子线程异常.md)      |
| 什么是内存屏障？                                             | 为了保证volatile变量的可见性和禁止指令重排序，Java会在生成的字节码中插入内存屏障来实现。 |                                                              |
| 有了CAS为啥还需要volatile？                                  | CAS和 volatile 在AQS中是互补的：CAS提供原子性操作以避免锁的使用，而 volatile 确保修改的可见性和内存操作的有序性。 |                                                              |
| 如何实现无锁化编程？                                         | **无锁化编程并非完全不使用锁**，而是指通过原子操作保证线程之间的数据一致性和操作的原子性，而不需要显式的加锁和解锁操作。原子操作是指对某个共享变量的操作（如加法、减法、比较等）是不可分割的，不会被中断。    在Java中，无锁化编程通常依赖于 **原子操作** 和 **CAS机制** 。 Java 提供了一些支持原子操作的类，位于 java.util.concurrent.atomic 包下，如： ● AtomicInteger ● AtomicLong ● AtomicReference ● AtomicBoolean ● AtomicStampedReference ● AtomicMarkableReference |                                                              |
| 介绍一下动态线程池                                           |                                                              | [Editorial](./Java基础/动态线程池.md)                        |
| 如何使用springtask做异步处理                                 | 线程池配置类开启异步`@EnableAsync`，`@Async("taskExecutor")` **taskExecutor**是线程池的名称 | [Editorial](./Java基础/如何使用springtask做异步处理.md)      |
| 日志重点打印的位置                                           | 我使用的是springboot自带的logpack                            | [Editorial](./Java基础/日志重点打印的位置.md)                |
| 多线程深度面试200连环深挖题                                  |                                                              | [Editorial](./Java基础/多线程进阶200题.md)                   |

## 【JVM】

| Problems                                                     | Hints                                                        | Solution                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| JVM 入门到进阶全解析                                         |                                                              | [Editorial](./JVM/JVM入门到进阶全解析.md)                    |
| JIT编译器                                                    | JIT编译器（即时编译器）是Java虚拟机中的一种运行时优化技术，它会在程序运行时将频繁执行的热点字节码编译为本地机器码，从而提升代码执行效率。这样，Java程序既能保持跨平台性，又能获得接近本地代码的高性能，是JVM实现高效运行的重要机制之一。 |                                                              |
| JVM中对象的生命周期和引用类型有哪些？如何影响垃圾回收？      | 对象生命周期：创建→使用→不可达→等待回收→被回收  四种引用类型：强、软、弱、虚  引用强度影响GC回收时机  典型应用：缓存（软引用）、ThreadLocal（弱引用）、回收通知（虚引用）  复习提示：**“强软弱虚四种引用，引用越弱越易被GC”** | [Editorial](./JVM/JVM中对象的生命周期和引用类型有哪些？如何影响垃圾回收？.md) |
| 垃圾回收 cms和g1的区别是什么？                               | 回收策略、垃圾收集目标、内存划分、STW停顿时间、回收过程、吞吐量、适用场景、废弃情况 | [Editorial](./JVM/垃圾回收cms和g1的区别是什么.md)            |
| 讲下JVM内存区域？                                            | **方法区**：存储类元数据，JDK 8 之后使用 **元空间（Metaspace）**。  **堆**：存储对象，GC 主要管理区域，分 **新生代 & 老年代**。  **虚拟机栈**：存储局部变量表、方法调用信息，递归深会导致 **StackOverflowError**。  **本地方法栈**：服务于 JNI 调用，溢出也会抛出 **StackOverflowError**。  **程序计数器**：记录当前线程执行的 **字节码指令地址**。 | [Editorial](./JVM/JVM内存区域.md)                            |
| JVM如何判断对象是否存活？                                    | **引用计数法**、**可达性分析算法**                           | [Editorial](./JVM/JVM如何判断对象是否存活？.md)              |
| 什么是三色标记算法？                                         | 三色标记法是一种垃圾回收标记算法，将所有对象分为白、灰、黑三种颜色： **白色表示未访问的对象**，可能是垃圾。 **灰色表示已访问但其引用对象还未扫描的对象**。 **黑色表示已访问且其引用对象也都扫描过的对象**。 GC时，初始所有对象为白色，GC Roots为灰色，然后不断扫描灰色对象，把它们变黑，并把它们引用的白色对象变成灰色，直到没有灰色对象为止。**最终白色对象就是可以回收的垃圾对象**。三色标记法可以支持并发标记，减少GC停顿时间，是CMS和G1等现代垃圾回收器常用的算法。 |                                                              |
| 并发标记中的写屏障与三色标记法的多标/漏标问题                |                                                              | [Editorial](./JVM/并发标记中的写屏障与三色标记法的多标漏标问题.md) |
| 新生代如果只有一个Eden+一个Survivor可以吗？                  | 新生代采用标记-复制算法，因此需要一个Eden区和两个Survivor区，垃圾回收时存活对象从Eden和一个Survivor区复制到另一个空的Survivor区，保证有一块区域始终为空用于安全复制；如果只有两个区域，使用标记整理算法，就会存在碎片和效率等问题。 |                                                              |
| YoungGC和FullGC的触发条件是什么？                            | YoungGC的触发条件比较简单，那就是当年轻代中的eden区分配满的时候就会触发。   FullGC的触发条件比较复杂也比较多，主要以下几种：  老年代空间不足 、 空间分配担保失败、 永久代空间不足 、  代码中执行`System.gc() `； |                                                              |
| 什么是STW                                                    | Java中Stop-The-World机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起。这是Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互。 | [Editorial](./JVM/什么是STW.md)                              |
| 垃圾回收算法                                                 | ● 单纯的从时间长短上面来看：标记-清除 < 标记-复制【新生代】 < 标记-整理【老年代】。   ● 单纯从结果来看：标记-整理 > 标记-复制 >= 标记-清除 |                                                              |
| ★ 你知道哪些 JVM 的 GC 机制？                                | Serial收集器（复制算法) 、 ParNew收集器 (复制算法) 、 Parallel Scavenge收集器 (复制算法) 、 Serial Old收集器 (标记-整理算法) 、 Parallel Old收集器 (标记-整理算法) 、 CMS(Concurrent Mark Sweep)收集器（标记-清除算法） 、 G1(Garbage First)收集器 (标记-整理算法) | [Editorial](https://download.csdn.net/blog/column/12681557/141176456) |
| JDK 11中新出的ZGC有什么特点？                                | 低延迟、高吞吐，但是平台兼容性较差，由于不分代，部分短生命周期对象可能回收效率略低。 | [Editorial](./JVM/JDK11中新出的ZGC有什么特点.md)             |
| Java 8 和 Java 11 的GC有什么区别？                           | Java 8 和 Java 11都是LTS版本的JDK，所以会有人经常问他们之间的区别。特别是在GC上面的差别。  首先，在垃圾收集器上面，Java 8 中默认的**Parallel Scavenge GC+Parallel Old GC**的，分别用来做新生代和老年代的垃圾回收。而在Java 11中默认采用的是**G1**进行整堆回收的（Java 9中就是默认的了）。  另外，Java 11中还新增了一种垃圾收集器，那就是**ZGC**，他可以在保证高吞吐量的同时保证最短的暂停时间。 |                                                              |
| 什么是逃逸分析？它是如何优化对象分配和同步的？               | 逃逸分析：判断对象作用域，决定对象分配位置和优化锁  优化点：栈上分配、标量替换、同步消除  典型例子：方法内临时对象、同步块优化  相关JVM参数：`-XX:+DoEscapeAnalysis`  复习提示：**“判断对象是否只在方法内使用，能否避免堆分配和无用同步”** | [Editorial](./JVM/什么是逃逸分析？它是如何优化对象分配和同步的？.md) |
| Java中的对象一定在堆上分配内存吗？                           | 不一定，在HotSpot虚拟机中，存在JIT优化的机制，JIT优化中可能会进行**逃逸分析**，当经过逃逸分析发现某一个**局部对象没有逃逸到线程和方法外**的话，那么这个对象就可能不会在堆上分配内存，而是进行**栈**上分配。 |                                                              |
| JVM是如何进行类的热加载和热替换的？有哪些常见实现方式和使用场景？ | - JVM热加载/热替换：动态加载、替换类字节码，无需重启JVM - 原生HotSwap支持有限（方法体），复杂变更需第三方工具 - 常用工具：JRebel、HotswapAgent、IDEA热加载、Spring Boot Devtools - 典型场景：开发调试、插件系统、服务平滑升级 - 复习提示：**“热替换=改代码不重启，结构变更需用Agent/插件”** | [Editorial](./JVM/JVM是如何进行类的热加载和热替换的？有哪些常见实现方式和使用场景？.md) |
| JVM的即时编译（JIT）机制是什么？有哪些优化手段？如何影响运行性能？ | - JIT：热点代码动态编译为机器码，提升执行效率 - 优化手段：方法内联、逃逸分析、锁优化、循环优化 - 影响：运行越久，性能越高效（预热期） - 典型参数：`-XX:+PrintCompilation`, `-XX:+TieredCompilation` - 复习提示：**“JIT=热点编译提升性能，方法内联+逃逸分析是核心”** | [Editorial](./JVM/JVM的即时编译（JIT）机制是什么？有哪些优化手段？如何影响运行性能？.md) |
| JVM是如何实现线程安全的？有哪些内存模型和关键字保障并发正确性？ | JVM线程安全依靠JMM+关键字（volatile、synchronized、final、原子类）  关注可见性、原子性、有序性  典型场景：单例模式、原子计数、高并发下的锁和无锁  复习提示：**“JMM三性，volatile可见性/synchronized互斥，原子类无锁并发”** | [Editorial](./JVM/JVM是如何实现线程安全的？有哪些内存模型和关键字保障并发正确性？) |
| JVM垃圾回收（GC）的分代模型是什么？各代的回收器如何协同工作？ | JVM分代：新生代（Eden+Survivor）、老年代、元空间  GC分为Minor GC（新生代）、Full GC（全堆/老年代）  对象“熬老”：多次GC后晋升老年代  典型回收器组合：ParNew/CMS、Parallel Scavenge/Parallel Old、G1  复习提示：**“分代GC分新老，复制算法快，晋升规则定，回收器协同优化效率”** | [Editorial](./JVM/JVM垃圾回收（GC）的分代模型是什么？各代的回收器如何协同工作？.md) |
| JVM常见的内存参数有哪些？如何调优不同场景下的JVM内存设置？   | - JVM常用参数：-Xms、-Xmx、-Xss、-XX:MetaspaceSize - 调优思路：结合业务类型、内存监控、GC日志，合理设置堆/栈/元空间 - 典型组合：高并发服务=大堆+G1，高吞吐=Parallel GC，线程多=小-Xss - 复习提示：**“根据应用特性设内存参数，堆/栈/元空间分清楚，监控+调优”** | [Editorial](./JVM/JVM常见的内存参数有哪些？如何调优不同场景下的JVM内存设置？.md) |
| JVM的Safepoint是什么？为什么需要Safepoint？有哪些典型触发场景？ | - Safepoint：JVM让所有线程统一挂起，便于全局操作（如GC、Dump）。 - 典型触发：GC、线程Dump、类卸载、Deoptimization等。 - 停顿长原因：线程长时间无Safepoint（常见于大循环）。 - 复习提示：**“Safepoint=全线程暂停点，保障GC等全局操作安全”** | [Editorial](./JVM/JVM的Safepoint是什么？为什么需要Safepoint？有哪些典型触发场景？.md) |
| JVM垃圾回收（GC）有哪些常见的回收器？它们各自的特点和适用场景是什么？ | - GC有串行、并行、并发、低延迟多种，按业务选型 - 响应时间敏感选CMS/G1，吞吐量优先选Parallel，高并发/大堆优先选G1、ZGC、Shenandoah - 复习提示：**“G1服务器首选，ZGC低延迟，CMS老年代并发，Parallel吞吐量优先”** | [Editorial](./JVM/JVM垃圾回收（GC）有哪些常见的回收器？它们各自的特点和适用场景是什么？.md) |
| JVM运行时数据区包含哪些部分？各自作用是什么？                | **五大区域**：PC寄存器、JVM栈、本地方法栈、堆、方法区（元空间）    **常量池**：方法区的一部分，存字面量和符号引用    **直接内存**：堆外，由 NIO 等框架使用    **OOM类型**：StackOverflowError, Java heap space, PermGen／Metaspace, Direct buffer memory    复习提示：**“PC懂指令；栈存帧；堆存对象；区分PermGen与Metaspace”** | [Editorial](./JVM/JVM运行时数据区包含哪些部分？各自作用是什么？.md) |
| JVM有哪些常见的类加载器？它们的加载顺序和作用是什么？        | - **三大内置加载器**：Bootstrap、Extension、Application   - **双亲委派**：先父后子，防篡改   - **自定义加载器**：插件隔离、热部署、加密加载   - 复习提示：**“启动扩展系统三层委派，自定义破委派灵活拓展”** | [Editorial](./JVM/JVM有哪些常见的类加载器？它们的加载顺序和作用是什么？.md) |
| 请举例说明一次实际的 JVM 参数调优过程和调整依据              | “收集（GC 日志+Heap Dump）→ 分析（晋升率+Gen 使用率）→ 策略（新生代、GC 算法、堆大小、晋升阈值）→ 小步验证→上线监控” | [Editorial](./JVM/请举例说明一次实际的JVM参数调优过程和调整依据.md) |
| Java对象的创建与内存分配过程是什么？TLAB是什么？             | **步骤**：加载→分配（Eden/老年代/TLAB）→设头→归零→构造    **TLAB**：线程本地分配，减少竞争    **大对象**：直接老年代或晋升    复习提示：**“TLAB 本地分配，Eden 碰撞快，老年代晋升慎”** | [Editorial](./JVM/Java对象的创建与内存分配过程是什么？TLAB是什么？.md) |
| JVM如何支持 Java 以外的语言特性（如 Kotlin、Scala 等）？     | - “统一字节码” + “invokedynamic” + “MethodHandle”   - 类型擦除与桥接方法   - 运行时库＋编译器代码生成支持多语言特性   - 复习提示：**“JVM 执行字节码，不关心源语言；invokedynamic 与 MethodHandle 是动态语言的利器”** | [Editorial](./JVM/JVM如何支持Java以外的语言特性（如Kotlin、Scala等）？.md) |
| 如何解读GC日志？常见GC日志参数有哪些？                       | - **开启日志**：`-XX:+PrintGCDetails`／`-Xlog:gc*`   - **解析要点**：时间戳、GC类型、空间变化、停顿时长   - **算法差异**：Parallel、CMS、G1 日志标签与阶段   - **调优指标**：频率、停顿、吞吐、年龄分布   - 复习口诀：     “看日志先识类型 → 空间前后对比 → 停顿时长 → 调参（代大小+算法+线程）” | [Editorial](./JVM/如何解读GC日志？常见GC日志参数有哪些？.md) |
| JVM如何保证类与字节码的安全性？类加载安全机制有哪些？        | - **验证**：魔数→版本→常量池→数据/控制流   - **委派**：先父后子，保核心不被篡改   - **ProtectionDomain** + **SecurityManager**：代码来源→权限检查   - **JAR 签名**：完整性验证   - **JPMS**：模块封装与可见性控制   - **隔离**：自定义加载器沙箱   - 复习口诀：     “验字节→委加载→域限权→签可信→模块封→隔离沙” | [Editorial](./JVM/JVM如何保证类与字节码的安全性？类加载安全机制有哪些？.md) |
| Java 内存模型（JMM）与 volatile 的可见性保证                 | JMM：主内存 vs 工作内存    happens-before：顺序、锁、volatile、线程启动/终止    volatile：可见+有序，不原子    synchronized/CAS/AQS：互斥与高并发原语    复习口诀：“先行发生规则定序，volatile 可见有序锁互斥” | [Editorial](./JVM/Java内存模型（JMM）与volatile的可见性保证.md) |
| synchronized 的实现原理和锁优化                              | “对象头 Mark Word + Monitor → 偏向／轻量级／重量级三态 → JIT 锁消除／锁粗化 → 参数调优（偏向、自旋）” | [Editorial](./JVM/synchronized的实现原理和锁优化.md)         |
| JVM 中的字符串常量池（String Constant Pool）及 `intern()` 机制是什么？它们对内存和 GC 有什么影响？ | **字符串常量池**：复用字面量和 intern 生成的字符串，节省内存。  **intern()**：将字符串放入常量池，返回池中引用。  **GC 影响**：JDK7+ 常量池在堆，未被引用的字符串可被 GC。频繁 intern 需防 OOM。  **口诀**：`“池中复用，intern 去重，堆上易回收，滥用会 OOM”` | [Editorial](./JVM/JVM中的字符串常量池及intern()机制是什么它们对内存和GC 有什么影响.md) |
| 什么是 GC Roots？它们如何决定对象的可达性，进而影响垃圾回收？ | **GC Roots**：栈引用、静态属性、常量、JNI、活跃线程    **可达性**：从 Roots 出发的引用链标记算法    **影响**：只要可达就不回收 → 静态缓存/单例易泄漏    **提示口诀**：  `“栈、静、常、JNI、线程 五大 Root → 图搜标记可达 → 不可达即回收”` | [Editorial](./JVM/什么是GCRoots？它们如何决定对象的可达性，进而影响垃圾回收？.md) |
| 什么是 JVM 直接内存（Direct Memory）？它的原理、典型应用及对 GC/内存管理的影响是什么？ | **直接内存**：堆外本地内存，NIO/Netty/高性能场景常用。  **管理方式**：GC 间接触发回收，受 MaxDirectMemorySize 限制。  **风险**：大量分配或回收不及时会导致直接内存 OOM。  **口诀**：`“堆外直连高效IO，GC间接管生命周期，参数控量防 OOM”` | [Editorial](./JVM/什么是JVM直接内存（DirectMemory）？它的原理典型应用及对GC内存管理的影响是什么？.md) |
| JVM 中的 Finalizer（finalize 方法）和清理机制是什么？为什么不推荐使用？如何安全地管理对象资源？ | **finalize()**：资源清理，但不安全，易泄漏  **不推荐**：不可控、不可预测、性能差  **推荐**：AutoCloseable + try-with-resources，JDK9+ 用 Cleaner  **口诀**：`“资源要手关，finalize 不可靠，try-with-resources 最安全”` | [Editorial](./JVM/JVM中的Finalizer（finalize方法）和清理机制是什么？为什么不推荐使用？如何安全地管理对象资源？.md) |
| JVM 的方法区、永久代（PermGen）与元空间（Metaspace）有什么区别？各自的作用与常见问题是什么？ | **方法区**：存类元数据/常量池/静态变量  **PermGen**：JDK8-，JVM进程内，易OOM  **Metaspace**：JDK8+，本地内存，物理内存限制  **口诀**：`“方法区元数据信息，PermGen易爆，Metaspace更大，一样可OOM”` | [Editorial](./JVM/JVM的方法区、永久代（PermGen）与元空间（Metaspace）有什么区别？各自的作用与常见问题是什么？.md) |
| JVM 的方法区、永久代（PermGen）与元空间（Metaspace）有什么区别？各自的作用与常见问题是什么？ | **GC调优误区**：只调堆、不分代、参数混用、忽略非堆、只看次数、乱用Full GC  **优化建议**：结合业务场景，分析GC日志，合理分代与参数，关注非堆区域  **口诀**：`“调优不迷信，参数看回收，日志细分析，场景定策略”` | [Editorial](./JVM/JVMGC调优中常见的误区与陷阱有哪些？如何避免？.md) |
| JVM 新生代（Young Generation）与老年代（Old Generation）是怎么划分的？对象在不同代的“晋升”与“回收”机制是什么？ | **新生代**：Eden、S0、S1，短命对象多，Minor GC 频繁  **老年代**：长寿对象、缓存、晋升/大对象  **晋升机制**：年龄、空间不足、大对象  **口诀**：`“朝生夕死新生代，历经磨难进老年，空间不足早晋升，大对象直接进老年”` | [Editorial](./JVM/JVM新生代（YoungGeneration）与老年代（OldGeneration）是怎么划分的？对象在不同代的“晋升”与“回收”机制是什么？.md) |
| 如何判断JVM中类和其他类是不是同一个类？                      | 比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。 |                                                              |
| 什么是TLAB                                                   | **TLAB**（Thread Local Allocation Buffer，线程本地分配缓冲区）是JVM（Java虚拟机）中为每个线程单独分配的一块内存缓冲区，用于加速对象的分配过程。 | [Editorial](./JVM/什么是TLAB.md)                             |
| JVM如何保证给对象分配内存过程的线程安全？                    | 采用乐观锁， JVM会采用CAS+失败重试的方式来避免线程问题。     | [Editorial](./JVM/JVM如何保证给对象分配内存过程的线程安全？.md) |
| 虚拟机中的堆一定是线程共享的吗？                             | 并不一定哦！  为了保证对象的内存分配过程中的线程安全性，HotSpot虚拟机提供了一种叫做TLAB(Thread Local Allocation Buffer)的技术。  在线程初始化时，虚拟机会为每个线程分配一块TLAB空间，只给当前线程使用，当需要分配内存时，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率。 |                                                              |
| 有哪些常用的JVM启动参数？                                    |                                                              | [Editorial](./JVM/有哪些常用的JVM启动参数？.md)              |
| 哪些语言有GC机制                                             | 很多编程语言都有垃圾回收（GC）机制，其中包括：  1、Java 2、C# 3、Python 4、Ruby 5、JavaScript 6、Kotlin 7、Swift 8、Go 9、R 10、Lua |                                                              |
| 一个对象的结构是什么样的？                                   |                                                              | [Editorial](./JVM/一个对象的结构是什么样的.md)               |
| JVM是如何创建对象的？                                        |                                                              | [Editorial](./JVM/JVM是如何创建对象的？.md)                  |
| 运行时常量池和字符串常量池的区别                             |                                                              | [Editorial](./JVM/运行时常量池和字符串常量池的区别.md)       |
| 什么是堆外内存？如何使用堆外内存？                           |                                                              | [Editorial](./JVM/什么是堆外内存？如何使用堆外内存？.md)     |
| FullGC多久一次算正常？                                       | 一般来说，日常情况，FullGC不应该超过一周一次的这个频率。     | [Editorial](./JVM/FullGC多久一次算正常？.md)                 |
| 内存泄漏和内存溢出的区别                                     | **内存泄漏**：内存“被浪费”，还被引用，回收不了;   **内存溢出**：内存“不够用”，分配失败，直接报错 | [Editorial](./JVM/内存泄漏和内存溢出的区别.md)               |
| 破坏双亲委派之后，能重写String类吗？                         | 破坏双亲委派机制后，理论上可以让自定义类加载器加载自己的 `java.lang.String` 类，但实际上无法真正重写JDK中的 String 类，因为JVM对核心类（如 String）有特殊保护，总是优先使用系统自带的实现，即使自定义了同名类也无法影响JVM内部和JDK API对 String 的使用。 |                                                              |
| 什么是Class常量池，和运行时常量池关系是什么？                | Class常量池是指Java类文件中用于存储各种字面量（如字符串、数值）和符号引用（如类、方法、字段等）的数据区，类加载后这些内容会被放入JVM的运行时常量池，运行时常量池是Class常量池在内存中的映射，支持类解析和动态链接，两者本质上是编译期和运行期的对应关系。 |                                                              |
| Java发生了OOM一定会导致JVM 退出吗                            | Java发生OOM（OutOfMemoryError）时未必一定导致JVM退出，如果异常没有被捕获或发生在无法继续运行的关键区域，例如线程创建或GC时，JVM可能会直接终止；但如果异常被程序捕获并妥善处理，JVM可以继续运行，只是相关操作会失败，因此是否退出取决于异常处理和具体场景。 |                                                              |
| 什么是AOT编译？和JIT有啥区别？                               | AOT编译（Ahead-of-Time Compilation）是指在程序运行前，直接将源码或字节码编译为机器码，提升启动速度和可预测性，而JIT（Just-In-Time Compilation）则是在程序运行过程中根据热点代码动态编译为机器码，优化执行效率；两者区别在于AOT提前编译、启动快但优化有限，JIT运行时优化、性能高但启动慢。 |                                                              |
| 说一说JVM的并发回收和并行回收                                | JVM的并发回收是指垃圾收集器在回收垃圾时，**应用线程与GC线程可以同时运行**，从而减少应用停顿时间，而并行回收则是由**多个GC线程并发执行垃圾回收任务**，但在回收期间会暂停所有应用线程，两者区别在于并发回收能提升响应性，适合低延迟场景，并行回收能加快垃圾回收速度，适合高吞吐场景。 |                                                              |
| Java一定就是平台无关的吗？                                   | Java并不绝对是平台无关的。虽然Java通过字节码和JVM实现了“一次编写，到处运行”的平台无关性，但实际运行仍依赖于具体平台的JVM实现，如果使用了**本地方法**（如JNI）、**操作系统相关特性**或不同JVM实现间有差异，仍可能出现平台相关问题，因此Java只是相对平台无关，并非绝对。 |                                                              |
| 什么情况会导致JVM退出？                                      | 导致JVM退出的常见情况包括：主线程执行完毕或调用 `System.exit()` 方法主动退出；发生致命错误如 `OutOfMemoryError`、`StackOverflowError`、无法恢复的内部错误；JVM遇到崩溃、虚拟机进程被外部强制终止；或运行期间加载了非法的类文件、初始化类失败等严重异常。通常只有在无法继续正常执行或被显式要求时，JVM才会退出。 |                                                              |
| 项目中如何选择垃圾回收器？为啥选择这个？                     |                                                              | [Editorial](./JVM/项目中如何选择垃圾回收器？为啥选择这个？.md) |
| 元空间满了（或溢出），可能是什么原因？                       | 1、类加载的太多了（最常见！）  2、类加载器泄漏  3、元空间太小 | [Editorial](./JVM/元空间满了（或溢出），可能是什么原因？.md) |
| 为什么JDK 1.8要废弃永久代，改用元空间                        | 永久代是堆上的一部分，大小受堆大小的限制，容易发生OOM。元空间在本地内存上，不受堆大小的限制，不容易发生OOM。 |                                                              |

## 【Spring】

| Problems                                                     | Hints                                                        | Solution                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 什么是Bean                                                   | 在Spring中，Bean其实就是被Spring容器管理的一个对象。你可以把它理解为：“Spring帮你创建、初始化、管理生命周期的Java对象。”通俗点说：以前你在代码里用new手动创建对象，现在你只要在类上加上@Component、@Service、@Controller等注解，或者在配置里声明，Spring就会**自动**帮你把这些类变成Bean，**统一进行管理和使用**。以后你只要用@Autowired等方式注入这个Bean，就可以直接用，不用自己去创建了。所以，Spring里的Bean就是由Spring帮你生成和管理的对象，方便你在项目里随时拿来用。 |                                                              |
| 为什么@configuration和@component里面的方法都可以使用@bean    | 早期的@configuration和@component界限没有划清，所以会混用，但是现在，只要是需要使用@bean，我们都选择@configuration，因为@configuration会为这个bean提供代理（这里解释一下代理：就是有一个管家管理这个bean，需要的时候就拿给你用；如果没有代理，这个bean可能被拿走就不会还回来了，下次又需要这个bean就需要再new一个，这也是我们常说的不保护单例），保护单例。 |                                                              |
| 依赖注入的意思是将Bean加入容器吗？                           | 不是！千万别搞混了。依赖注入是**当某个 Bean 需要用到其他 Bean 时，Spring 自动把需要的 Bean 注入（赋值）给它**，而不是让你自己手动创建依赖对象。  Bean加入容器（Bean的注册） 你通过`@Component`、`@Service`、`@Repository`、`@Controller`、`@Bean`等注解（或XML配置），把一个类的实例交给 Spring 容器管理，成为一个“Bean”。 | [Editorial](./Spring/依赖注入的意思是将Bean加入容器吗？.md)  |
| Bean和静态对象对比                                           | Spring Bean 由容器统一管理，支持依赖注入、生命周期控制和灵活配置，适合复杂业务和解耦；静态对象则是全局唯一、无法注入和扩展，适合简单工具和常量，但灵活性和可维护性较差，线程安全需要额外注意。 | [Editorial](./Spring/Bean和静态对象对比.md)                  |
| Spring的aop介绍一下                                          | 切面编程、动态代理实现                                       | [Editorial](./Spring/Spring的aop介绍一下.md)                 |
| 介绍一下AOP动态代理                                          | AOP动态代理是面向切面编程（AOP）的一种实现方式，**通过在运行时为目标对象创建代理对象**，以拦截方法调用并织入增强（如事务、日志、安全等）。这种代理是在程序运行时动态生成的，因此称为“动态代理”。 | [Editorial](./Spring/介绍一下AOP动态代理.md)                 |
| 定义注解实现切面编程                                         | 场景：日志记录、权限校验、参数校验、缓存处理、接口幂等性、事务控制、审计与埋点、限流与防刷；  Editorial有具体的案例； | [Editorial](./Spring/定义注解实现切面编程.md)                |
| 详细介绍一下：ProceedingJoinPoint                            | 是 AspectJ（和 Spring AOP）中用于**“环绕通知”**（@Around advice）的一个接口。它代表了连接点（JoinPoint），即你的切面（Aspect）所拦截的**方法调用**，并且允许你通过它来访问方法的信息、参数，甚至可以控制方法的执行（如是否继续执行原方法、改变参数、获取返回值等）。 | [Editorial](./Spring/详细介绍一下ProceedingJoinPoint.md)     |
| Spring的AOP在什么场景下会失效？                              | 主要失效场景是**自调用**、**private/static/final 方法**、**非 Spring 管理对象**和**AOP 配置问题**。如果遇到 AOP 不生效，建议检查调用方式和代理配置。 | [Editorial](./Spring/Spring的AOP在什么场景下会失效.md)       |
| spring三级缓存解决循环依赖问题？                             | **Spring 三级缓存机制通过提前暴露 Bean 的引用，使得循环依赖得以解决，同时保证 AOP 代理不丢失**。 | [Editorial](./Spring/spring三级缓存解决循环依赖问题.md)      |
| 如何使用spring实现事务？【深问：事务传播模型有哪些】         | 编程式事务（`TransactionTemplate`）、声明式事务（`@Transactional`） | [Editorial](./Spring/如何使用spring实现事务 )                |
| 什么时候事务会失效                                           | Spring 事务失效常见原因包括：方法不是 public、同类内部直接调用、对象未被 Spring 管理、异常类型不符合回滚规则、数据库不支持事务、传播属性设置不当、多线程或异步执行、未正确配置事务管理器，以及使用了错误的代理方式。 | [Editorial](./Spring/什么时候事务会失效.md)                  |
| 事务失效与AOP代理失效                                        |                                                              | [Editorial](./Spring/事务失效与AOP代理失效.md)               |
| 介绍一下@Async      **[ˈeɪˌsɪŋk]**                           | `@Async` 是 Spring 提供的异步方法执行注解。  它允许你将某个方法变成**异步方法**，即调用该方法时不会阻塞当前线程，而是交由 Spring 的线程池异步执行，提升应用的并发能力和响应速度。 | [Editorial](./Spring/介绍一下@Async.md)                      |
| 为什么有的任务要丢给mq去执行，而不是直接用@sync开个异步执行呢？ | 将任务交给消息队列（MQ）执行，而不是直接用@Async开异步线程，主要是为了提升系统的**可靠性**和**解耦能力**。@Async只是本地线程池异步，服务重启或线程池满时任务**容易丢失**，不适合需要保证可靠处理和**跨服务协作**的场景；而MQ具备**消息持久化**、**消费确认**、**失败重试**等机制，能够确保任务即便出现服务故障也不会丢失，更适合关键业务的异步处理和解耦，所以在实际生产中更推荐用MQ来承载重要的异步任务。 | [Editorial](./Spring/为什么有的任务要丢给mq去执行而不是直接用sync开个异步执行呢.md) |
| 为什么不建议直接使用Spring的@Async                           |                                                              | [Editorial](./Spring/为什么不建议直接使用Spring的@Async.md)  |
| 分布式事务详解与面试高频问题梳理                             | 一次业务操作会跨越多个数据库、服务、系统或消息队列。例如：订单服务写订单库，库存服务扣库存库，支付服务调支付网关。**如果这些操作不能保证"要么全部成功，要么全部失败"，就会出现数据不一致问题。** | [Editorial](./Spring/分布式事务详解)                         |
| springboot常用注解                                           | Bean相关的、依赖注入、读取配置、Web相关、其他注解            | [Editorial](./Spring/springboot常用注解.md)                  |
| MyBatis，#和$有什么区别                                      | **主要是SQL注入的问题**                                      | [Editorial](./Spring/MyBatissql注入有什么区别.md)            |
| 你说到了SQL注入，那你给我设计出一个SQL注入，具体说表中的字段，然后SQL语句是怎样的 | SQL 注入主要是由于 **拼接 SQL 语句** 造成的，攻击者可以利用它来 **绕过身份验证、窃取数据，甚至破坏数据库**。最有效的防范方法是 **使用参数化查询**，避免直接拼接用户输入到 SQL 语句中。 | [Editorial](./MySQL/SQL注入例子.md)                          |
| Bean 的生命周期                                              | 8大步                                                        | [Editorial](./Spring/Bean的生命周期.md)                      |
| Bean初始化                                                   | 记住**执行带有`@PostConstruct` 注解的方法**就可以了          |                                                              |
| Bean是否单例？                                               | Bean默认是单例的（singleton）。  只有显式设置@Scope("prototype")或scope="prototype"时，才会变成多例。 |                                                              |
| Bean的单例和非单例，生命周期是否一样                         | 不一样的，Spring Bean 的生命周期完全由 IoC 容器控制。Spring 只帮我们管理单例模式 Bean 的完整生命周期，对于 `prototype` 的 Bean，Spring 在创建好交给使用者之后，则不会再管理后续的生命周期。 |                                                              |
| Spring容器里存的是什么？                                     | 在Spring容器中，存储的**主要是Bean对象**。 Bean是Spring框架中的基本组件，用于表示应用程序中的各种对象。当应用程序启动时，Spring容器会根据配置文件或注解的方式创建和管理这些Bean对象。Spring容器会负责创建、初始化、注入依赖以及销毁Bean对象。 |                                                              |
| Bean注入和xml注入最终得到了相同的效果，它们在底层是怎样做的  | **最终实现效果相同**：无论 XML 还是注解，最终都生成 **BeanDefinition**，通过 **反射实例化 Bean 并注入依赖**。  **区别在于解析方式**：   **XML** 方式**使用 `BeanFactory` + `setter` 方法**进行注入。  **`@Autowired` 注解使用 `AutowiredAnnotationBeanPostProcessor`，直接通过反射赋值**，不会调用 setter。  **推荐使用注解方式**：代码更加简洁，支持 **Spring Boot 自动装配**，XML 适用于 **复杂 XML 配置管理**（如 Spring Cloud 配置中心）。 | [Editorial](./Spring/Bean注入与xml注入.md)                   |
| spring 里@Autowired 和 @Resource 注解有什么区别？            | 来源不同、注入方式、属性、依赖性、使用场景                   | [Editorial](./Spring/Spring的Autowired和Resource区别.md)     |
| Spring的IOC介绍一下                                          | **IOC（控制反转）** 是一种**设计思想**，用于管理对象的依赖关系。Spring 通过 **IOC 容器** 负责创建、管理和注入对象，而不是由代码手动创建对象。 | [Editorial](./Spring/Spring的IOC介绍一下.md)                 |
| 为什么Spring不建议使用基于字段的依赖注入                     | 测试困难、不可变性差、依赖关系不明显、重构和维护难、破坏封装 | [Editorial](./Spring/为什么Spring不建议使用基于字段的依赖注入.md) |
| Spring的事务，使用this调用是否生效？                         | 不能生效。因为Spring事务是通过代理对象来控制的，只有通过代理对象的方法调用才会应用事务管理的相关规则。当使用`this`直接调用时，是绕过了Spring的代理机制，因此不会应用事务设置 |                                                              |
| Spring MVC的工作流程描述一下                                 | 7大步：请求进入、寻找控制器、执行控制器、返回模型数据、解析视图、渲染视图、响应返回 | [Editorial](./Spring/SpringMVC的工作流程描述一下.md)         |
| Spring 中的 BeanFactory 和 ApplicationContext 有什么区别？   | ApplicationContext = BeanFactory + 企业级特性（如国际化、事件等），开发中优先用 ApplicationContext，BeanFactory 适合底层或特殊场景。 | [Editorial](./Spring/Spring中的BeanFactory和ApplicationContext有什么区别？.md) |
| Spring 中的单例 Bean 是线程安全的吗？为什么？                | Spring 单例 Bean 并不保证线程安全；与线程安全无关，需开发者自行保证。无状态 Bean 通常安全，有状态需加锁或避免状态共享。 | [Editorial](./Spring/Spring中的单例Bean是线程安全的吗？为什么？.md) |
| Spring 中的循环依赖是什么？Spring 是如何解决循环依赖的？     | Spring 循环依赖：A 依赖 B，B 又依赖 A。Spring 通过三级缓存（singletonObjects、earlySingletonObjects、singletonFactories）机制，提前暴露 Bean 引用，解决 setter/属性注入的循环依赖。构造器注入无法解决。 | [Editorial](./Spring/Spring中的循环依赖是什么？Spring是如何解决循环依赖的？.md) |
| 什么是 Spring 的依赖注入（DI）？有哪些常用的依赖注入方式？   | 依赖注入（DI）：Spring IoC 核心。构造器注入优先，Setter 适合可选依赖，字段注入不推荐。DI 解耦代码，便于测试和维护。 | [Editorial](./Spring/什么是Spring的依赖注入（DI）？有哪些常用的依赖注入方式？.md) |
| 三种依赖注入方式的底层是怎么实现的？                         | Spring的三种依赖注入方式底层都是通过**反射**实现的：构造器注入是在**实例化Bean时**通过调用**带参数的构造方法**注入依赖，Setter注入是**在Bean创建后**通过**反射调用setter方法**注入依赖，字段注入则是**在Bean创建后**直接通过**反射为字段赋值**，这三种方式最终都由Spring容器在Bean生命周期的不同阶段完成依赖注入。 | [Editorial](./Spring/三种依赖注入方式的底层是怎么实现的？.md) |
| Spring 的事务管理是如何实现的？声明式事务和编程式事务有何区别？ | Spring 事务管理：声明式（@Transactional，推荐，自动控制）和编程式（TransactionTemplate，手动控制）。事务传播行为很重要。大多数业务用声明式，复杂场景用编程式。 | [Editorial](./Spring/Spring的事务管理是如何实现的？声明式事务和编程式事务有何区别？.md) |
| Spring 中的 @Component、@Service、@Repository、@Controller 注解有什么区别？ | @Component 通用组件，@Service 业务服务，@Repository DAO 持久层（异常转换），@Controller Web 控制器（Spring MVC）。本质一样，主要是语义和层次区分。 | [Editorial](./Spring/Spring中的@Component、@Service、@Repository、@Controller注解有什么区别？.md) |
| Spring 中的 Bean 作用域（Scope）有哪些？它们的应用场景是什么？ | Spring Bean 作用域：singleton（单例，默认），prototype（多例），request/session/application/websocket（Web 环境）。常用 singleton，原型适合有状态对象，Web 场景用 request、session。 | [Editorial](./Spring/Spring中的Bean作用域（Scope）有哪些？它们的应用场景是什么？.md) |
| Spring 的 AOP（面向切面编程）是什么？有哪些常用的应用场景？  | Spring AOP：面向切面编程，横切关注点（如日志、事务、安全）自动织入方法执行，提升复用和解耦。常见注解 @Aspect、@Before、@After、@Around。 | [Editorial](./Spring/Spring的AOP（面向切面编程）是什么？有哪些常用的应用场景？.md) |
| Spring Boot 和 Spring Cloud 有什么区别？各自的主要功能是什么？ | Spring Boot：简化开发，自动配置、内嵌服务器、Starter。Spring Cloud：微服务基础设施，服务注册发现、配置中心、网关、熔断等。Cloud 基于 Boot，用于云原生/微服务架构。 | [Editorial](./Spring/SpringBoot和SpringCloud有什么区别？各自的主要功能是什么？.md) |
| Spring 中的条件注解（@Conditional）有什么作用？常见的条件注解有哪些？ | 条件注解：控制 Bean 是否装配（如 @ConditionalOnClass、@ConditionalOnMissingBean、@ConditionalOnProperty），常用于自动配置和环境切换，可自定义条件。 | [Editorial](./Spring/Spring中的条件注解（@Conditional）有什么作用？常见的条件注解有哪些？.md) |
| Spring 中的事件机制（ApplicationEvent）是什么？有哪些常见应用场景？ | Spring 事件机制（ApplicationEvent）：应用内异步/同步解耦通信，事件发布者 publish，监听器监听处理，常用于业务解耦、扩展、异步任务等场景。 | [Editorial](./Spring/Spring中的事件机制（ApplicationEvent）是什么？有哪些常见应用场景？.md) |
| Spring 的配置文件有哪些常用方式？如何实现配置的动态刷新？    | Spring 配置方式：properties、YAML、环境变量、配置中心。动态刷新常用 @RefreshScope + Spring Cloud Config/Nacos 等，支持不重启服务实时生效。 | [Editorial](./Spring/Spring的配置文件有哪些常用方式？如何实现配置的动态刷新？.md) |
| Spring 如何实现多环境（多 profile）配置？如何切换环境？      | 多环境配置：多 profile 文件（如 application-dev.properties），用 spring.profiles.active 指定激活环境，也可用 @Profile 控制 Bean 加载。支持命令行、环境变量、YAML 多块等切换方式。 | [Editorial](./Spring/Spring如何实现多环境（多profile）配置？如何切换环境？.md) |
| 如何在 Spring 中实现自定义注解？自定义注解一般有哪些使用场景？ | 自定义注解：@interface 定义 + @Target/@Retention + AOP/后处理配合使用。常用于统一日志、权限、参数校验、标记元数据等场景。 | [Editorial](./Spring/如何在Spring中实现自定义注解？自定义注解一般有哪些使用场景？.md) |
| Spring 中的 BeanPostProcessor 有什么作用？常见的应用场景有哪些？ | BeanPostProcessor：对 Bean 初始化前后进行扩展增强，常用于 AOP 代理、自动注解处理、自定义注解逻辑、属性修改等，是 Spring 容器的重要扩展点。 | [Editorial](./Spring/Spring中的BeanPostProcessor有什么作用？常见的应用场景有哪些？.md) |
| Spring 6.0和SpringBoot 3.0有什么新特性？                     | Spring6.0引入AOT（ Ahead-Of-Time ）编译。 **Java 17 是最低要求**，**Jakarta EE 9+ 命名空间迁移** Spring Boot 3.0强依赖Spring 6.0，具备上面所有特性。 引入Spring Native  有了Spring Native ，Spring可以不再依赖Java虚拟机，而是基于 GraalVM 将 Spring 应用程序编译成原生镜像（native image），提供了一种新的方式来部署 Spring 应用。这种部署Spring的方式是**云原生友好的**。  SpringNative的优点是编译出来的**原生 Spring 应用可以作为一个独立的可执行文件进行部署**，而不需要安装JVM，而且启动时间非常短、并且有更少的资源消耗。他的缺点就是构建时长要比JVM更长一些。 |                                                              |
| BeanFactory和FactroyBean的关系？                             | **BeanFactory**是Spring的核心IoC容器接口，用于管理所有Bean；**FactoryBean**是一个特殊的Bean，通过它可以定制和包装复杂的Bean实例化过程。 | [Editorial](./Spring/BeanFactory和FactroyBean的关系.md)      |
| spring用到了哪些设计模式                                     | 工厂模式、单例模式、代理模式、模板方法模式、观察者模式、策略模式、适配器模式、装饰者模式、责任链模式、建造者模式 | [Editorial](./Spring/Spring用到了哪些设计模式.md)            |
| Spring事务失效可能是哪些原因                                 | Spring事务失效主要是AOP代理机制未生效、异常未正确抛出、方法修饰符不对、自调用、数据库原因等导致的。 | [Editorial](./Spring/Spring事务失效可能是哪些原因.md)        |
| Spring Boot 如何让你的 bean 在其他 bean 之前加载             | 直接依赖某Bean ,也可以使用`@DependsOn("Bean")`；特别注意：Order只能控制同一个Bean类型中集合的顺序，不能控制不同Bean的初始化顺序 |                                                              |
| SpringBoot是如何实现main方法启动Web项目的？                  | Spring Boot 通过在 main 方法中调用 `SpringApplication.run`，自动完成了 Spring 容器初始化、嵌入tomcat启动和应用准备工作，无需传统的 web.xml 或外部容器部署，实现了“一键启动”Web 项目。 | [Editorial](./Spring/SpringBoot是如何实现main方法启动Web项目的？.md) |
| Spring中shutdownhook作用是什么？                             | Spring 中的 shutdown hook 主要用于保证**应用优雅关闭、资源正确释放**，避免资源泄漏和不完整的退出流程。对于长期运行的服务（如Web服务、微服务）尤其重要。 | [Editorial](./Spring/Spring中shutdownhook作用是什么.md)      |
| SpringBoot如何做优雅停机？                                   | 在 application.properties文件中添加一行代码：  `server.shutdown=graceful ` |                                                              |
| 缓存预热的作用                                               | 在系统启动或上线前提前将热点数据加载到缓存中，避免系统刚开始运行时大量请求直接访问数据库或后端服务，防止出现缓存穿透和后端压力骤增，从而提升系统的响应速度和稳定性，保障用户体验。 |                                                              |
| 如何在Spring启动过程中做缓存预热                             | 在Spring启动过程中做缓存预热，常用方式是在项目启动后，通过实现`ApplicationRunner`或`CommandLineRunner`接口，或监听`ApplicationReadyEvent`事件，加载需要的数据到缓存中，从而提升系统后续的访问性能。这些方法可以保证在Spring容器和相关Bean都初始化完成后进行缓存预热，避免依赖未就绪导致的问题。 | [Editorial](./Spring/如何在Spring启动过程中做缓存预热.md)    |
| @Lazy注解能解决循环依赖吗？                                  | `@Lazy` 注解可以在字段注入（setter注入或属性注入）时，**解决部分循环依赖问题**，但不是根本方案，尤其对构造器注入和原型作用域无效。 | [Editorial](./Spring/@Lazy注解能解决循环依赖吗.md)           |
| Spring_Boot_Starter 详解                                     |                                                              | [Editorial](./Spring/Spring_Boot_Starter详解.md)             |
| 如何自定义一个starter？                                      | 自定义一个 Spring Boot Starter，通常是新建一个以 `-spring-boot-starter` 结尾的模块，在其中编写自动配置类（用 `@Configuration` 注解并结合条件注解），必要时提供配置属性类，并在 `META-INF/spring.factories`（或 Spring Boot 3.x 的自动配置 imports）中注册自动配置类，最后将 starter 打包发布，业务项目只需引入该依赖即可实现自动装配和开箱即用。 | [Editorial](./Spring/如何自定义一个starter.md)               |
| Spring的事务在多线程下生效吗？为什么？                       | Spring 的事务（@Transactional）**在多线程下默认不生效**，原因如下： Spring 的事务是通过 AOP 代理实现的，事务的上下文（如数据库连接、事务状态）是**绑定在当前线程（ThreadLocal）**上的。只有在同一个线程中，Spring 才能感知和管理事务。当你在一个有事务的方法中开启新的线程（比如用 new Thread() 或线程池），新线程不会继承当前线程的事务上下文，因此在新线程中，@Transactional 注解不会生效，事务不会自动传播或共享。                                               不过，如果需要管理跨线程的事务，我们可以使用编程式事务，即自己用 **TransactionTemplate** 或**PlatformTransactionManager** 来控制事务的提交。 |                                                              |
| 如何根据配置动态生成Spring的Bean？                           | 1、`@Configuration`和`@Bean`，2、使用`@conditional`注解，3、使用 `BeanDefinitionRegistryPostProcessor` 或 `ImportBeanDefinitionRegistrar`，4、 使用 `@Profile`，5、利用工厂Bean | [Editorial](./Spring/如何根据配置动态生成Spring的Bean.md)    |
| 介绍下@Scheduled的实现原理以及用法                           | Spring 的 `@Scheduled` 注解通过 `ScheduledAnnotationBeanPostProcessor` 在启动时扫描所有 Bean，解析标注的方法和参数，然后把方法注册为定时任务，交给 `ThreadPoolTaskScheduler` 线程池按指定的周期自动执行。底层核心流程包括注解解析、任务注册和线程池调度，源码主要分布在 `ScheduledAnnotationBeanPostProcessor` 和 `ScheduledTaskRegistrar` 等类。 | [Editorial](./Spring/介绍下@Scheduled的实现原理以及用法.md)  |
| Spring默认支持循环依赖吗？如果发生如何解决？                 | Spring 框架默认支持单例 Bean 的 setter/字段注入循环依赖，利用三级缓存提前暴露 Bean 引用解决依赖环；但从 Spring Boot 2.6 开始，默认关闭了循环依赖支持（即 `spring.main.allow-circular-references=false`），如项目存在循环依赖需手动开启配置。在实际开发中建议优先规避循环依赖，或通过调整注入方式、优化设计来解决。 | [Editorial](./Spring/Spring默认支持循环依赖吗？如果发生如何解决？.md) |
| 同时使用 @Transactional 与 @Async 时，事务会不会生效？       | 1、如果`@Transactional` 与 `@Async`加在同一个方法上，那么事务会生效的。  2、如果`@Transactional`方法A调用 `@Async`方法B，那么A 抛异常了，A 自己会回滚，但是B 不会回滚；B 抛异常了 ， 但是A 也不会回滚。  3、如果`@Async`方法A调用` @Transactional` 方法B，那么A 抛异常了，B 不会回滚（如果 A 没有事务，自己也不会回滚的）；但是 B 抛异常了，B 自己会回滚。 |                                                              |
| 知道Spring Task吗，和XXL-JOB有啥区别？                       | Spring Task 是 Spring 框架自带的本地定时任务调度工具，适合简单周期任务，依赖于应用自身，功能有限。而 XXL-JOB 是分布式任务调度平台，支持任务统一管理、分布式执行、监控和重试，适用于企业级和复杂场景。实际选型要根据业务规模和需求决定。 | [Editorial](./Spring/知道SpringTask吗，和XXL-JOB有啥区别.md) |
| SpringBoot和传统的双亲委派有什么不一样吗？                   | 在 Spring Boot 中，使用 Maven 或 Gradle 构建项目时，lib/ 目录中的第三方依赖是**以 JAR 形式打包进主 JAR 内部，默认会生成一个包含所有依赖项的 fat jar**。 传统的 Application ClassLoader **只能从 外部 classpath 加载类**，**无法直接加载 JAR 包内嵌的其他 JAR（fat jar）**。 因此 Spring Boot 需要自定义类加载器。 为了支持 Fat JAR 运行模式，Spring Boot 使用 `LaunchedURLClassLoader` 替代 `AppClassLoader`，打破双亲委派机制，核心做法是： ● 先加载 **BOOT-INF/classes** 目录下的应用类（优先于 JDK 类）。 ● 再加载 **BOOT-INF/lib/** 目录下的依赖 JAR（传统 AppClassLoader 无法加载嵌套 JAR）。 ● 最后才交给父类加载器（即 JDK 提供的 AppClassLoader）。 |                                                              |
| 什么是fat jar？                                              | 在 Spring Boot 中，使用 Maven 或 Gradle 构建项目时，默认会生成一个包含所有依赖项的 fat jar。这种做法简化了应用的部署和运行，但也会导致 jar 文件过大，不利于网络传输和存储。 |                                                              |
| 如何在Spring中做缓存预热                                     | Spring启动时做缓存预热，可以选择监听 `ApplicationReadyEvent`、实现 `Runner` 接口、实现 `InitializingBean` 或使用 `@PostConstruct`。实际选型可根据业务需要和预热时机灵活选用。 | [Editorial](./Spring/如何再Spring中做缓存预热.md)            |
| Springboot自动装配机制原理（2.x版本）                        | 核心靠一个注解`@EnableAutoConfiguration`它其实就是导入了一个类`AutoConfigurationImportSelector`这个类会通过`SpringFactoriesLoader`这个类去扫描我们项目下面所有依赖包下的`META-INF/spring.factories`文件，里面列了一大堆配置类，像`DataSourceAutoConfiguration`、`WebMvcAutoConfiguration`之类的，springboot启动的时候，会把这些类**按需**加载进来，为什么说是按需，因为这些类通常配了各种条件注解`@ConditionalOnClass`（我们依赖里面没有这个类才加载）、`@ConditionalOnMissingBean`（我们没有配置，才帮我们配置）、`@ConditionalOnProperty`（配置文件开了这个开关，才加载）。 |                                                              |
| SpringBoot的启动流程是怎么样的？                             | 启动流程包含上下的**自动装配**与**配置加载优先级**           | [Editorial](./Spring/SpringBoot的启动流程是怎么样的.md)      |
| Springboot配置加载的顺序                                     | **“命令行 > 系统变量 > 环境变量 > profile配置 > 主配置 > jar外 > jar内 > 默认”** | [Editorial](./Spring/Springboot配置加载的顺序.md)            |

## 【Mybatis】

| Problems                                   | Hints                                                        | Solution                                                     |
| ------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| MyBatisPlus操作数据库详细学习手册          |                                                              | [Editorial](./Mybatis/MyBatisPlus操作数据库详细学习手册.md)  |
| LambdaQueryWrapper与QueryWrapper的区别     |                                                              | [Editorial](./Mybatis/LambdaQueryWrapper与QueryWrapper的区别.md) |
| 什么是ORM，有哪些常用框架？                | **Object Relational Mapping** ，简称ORM，翻译过来是**对象关系映射**。一般用于实现面向对象编程语言里的对象和数据库中的之间的转换。 | [Editorial](./Mybatis/什么是ORM，有哪些常用框架.md)          |
| MyBatis与Hibernate有何不同                 |                                                              | [Editorial](./Mybatis/MyBatis与Hibernate有何不同.md)         |
| Mybatis的优点有哪些                        |                                                              | [Editorial](./Mybatis/Mybatis的优点有哪些.md)                |
| Mybatis是如何实现字段映射的                | MyBatis 通过映射配置（如 XML 的 <resultMap> 或注解 @Results）实现字段映射，将数据库表的列名与 Java 对象的属性一一对应，可以自动处理列名与属性名不同的情况，从而实现数据库结果与 Java 实体的灵活转换。 | [Editorial](./Mybatis/Mybatis是如何实现字段映射的.md)        |
| Mybatis插件的运行原理                      | Mybatis插件的运行原理主要涉及3个关键接口：Interceptor、Invocation和Plugin。 | [Editorial](./Mybatis/Mybatis插件的运行原理.md)              |
| Mybatis的工作原理                          | MyBatis 的工作原理可以概括为：通过**配置文件**加载和初始化配置信息，使用**动态代理技术**实现接口方法与 SQL 映射，底层执行时仍然使用 **JDBC** 与数据库交互，但对外提供了更加面向对象和易于使用的 **API**。其核心优势在于**解耦**了 SQL 和代码，实现了参数和结果集的**自动映射**，并**提供了缓存**等高级特性。                                                                                                                 分为**两大步**，**七小步**：**初始化阶段**（配置文件解释，创建configuration，构建sqlSessionFactory），**执行阶段**（获取sqlSession，获取mapper代理，执行SQL代码，结果集映射）   获取Mapper代理使用的是JDK动态代理，所以我们需要创建Mapper接口 | [Editorial](./Mybatis/Mybatis的工作原理.md)                  |
| Mybatis的缓存机制                          |                                                              | [Editorial](./Mybatis/Mybatis的缓存机制.md)                  |
| Mybatis用的什么连接池                      | Pooled、UnPooled，但是我们一般不使用mybatis的连接池，使用druid，更多的是使用springboot自带的HikariCP连接池 | [Editorial](./Mybatis/Mybatis用的什么连接池.md)              |
| 为什么选择HikariCP连接池                   | 开箱即用，配置简单，与springboot项目完美契合                 | [Editorial](./Mybatis/为什么选择HikariCP连接池.md)           |
| Mybatis 是否支持延迟加载？实现原理是什么？ | MyBaits支持延迟加载，延迟加载允许在需要时按需加载关联对象，而不是在查询主对象时立即加载所有关联对象。这样做可以提高查询性能和减少不必要的数据库访问。 | [Editorial](./Mybatis/Mybatis是否支持延迟加载？实现原理是什么？.md) |
| Mybatis可以实现动态SQL么                   | 可以，动态SQL是指根据不同的条件生成不同的SQL语句，可以避免在编写SQL语句时出现重复的代码，提高代码的复用性和灵活性。 | [Editorial](./Mybatis/Mybatis可以实现动态SQL么.md)           |
| 使用MyBatis如何实现分页                    |                                                              | [Editorial](./Mybatis/使用MyBatis如何实现分页.md)            |
| RowBounds分页的原理是什么？                | 物理分页：RowBounds分页本质是在**内存中对查询结果集进行截取分页**，只有配合分页插件才可能生成物理分页SQL，否则数据量大时容易出现性能和内存问题。 | [Editorial](./Mybatis/RowBounds分页的原理是什么.md)          |
| PageHelper分页的原理是什么                 | 不常用，一般都是上mybatisplus                                | [Editorial](./Mybatis/PageHelper分页的原理是什么.md)         |
| MyBatis-Plus有什么用                       | 解耦业务代码与数据库的连接操作代码，让开发者可以只关注业务代码的编写；提供大量的CRUD封装操作、代码生成、结果映射、分页、条件构造，帮助开发人员编写sql代码； | [Editorial](./Mybatis/MyBatis-Plus有什么用.md)               |
| MyBatis-Plus的分页原理是什么               | MyBatis-Plus 的分页本质还是 offset/limit。还是有深分页的问题，可以使用游标分页来优化深分页。 | [Editorial](./Mybatis/MyBatis-Plus的分页原理是什么.md)       |



## 【操作系统】

| Problems                                                     | Hints                                                        | Solution                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Linux系统                                                    |                                                              | [Editorial](./Linux.md)                                      |
| 什么是文件句柄FileHandle                                     | 文件句柄（File Handle）是操作系统中用于访问文件的一种数据结构，通常是一个整数或指针。包括文件描述符（fd），文件状态标志，文件位置指针 | [Editorial](./操作系统/什么是文件句柄FileHandle.md)          |
| 介绍一下虚拟地址                                             |                                                              | [Editorial](./操作系统/介绍一下虚拟地址.md)                  |
| 进程与线程的区别?                                            | 本质区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位 。  定义、资源占用、通信方式、稳定性、应用场景                                                                                                   进程通信IPC（Inter-Process Communication） | [Editorial](./操作系统/进程与线程的区别.md)                  |
| 介绍一下Java里面的Future/Promise                             | CompletableFuture                                            | [Editorial](./操作系统/介绍一下Java里面的Future.md)          |
| 补充 - 协程                                                  | 协程是一种`用户态`的`轻量级线程`，其调度`完全由用户程序控制`，而不需要`内核`的参与。协程拥有自己的`寄存器上下文和栈`，但与其他协程`共享堆内存`。协程的切换开销非常小，因为只需要保存和恢复协程的上下文，而无需进行内核级的上下文切换。这使得协程在处理大量并发任务时具有非常高的效率。然而，协程需要程序员显式地进行调度和管理，相对于线程和进程来说，`其编程模型更为复杂`。 |                                                              |
| 虚拟线程与协程的联系                                         |                                                              | [Editorial](./操作系统/虚拟线程与协程的联系.md)              |
| 为什么进程崩溃不会对其他进程产生很大影响?                    | **进程隔离**（每个进程都有自己独立的内存空间），**内存保护机制**（内存管理单元MMU和虚拟内存技术，防止进程访问不属于自己的内存区域），**用户态与内核态的隔离**，**进程通信需要操作系统的参与。** | [Editorial](./操作系统/为什么进程崩溃不会对其他进程产生很大影响.md) |
| 有哪些进程调度算法 ?                                         | 先来先服务 、短作业优先、最短剩余时间优先、时间片轮转、优先级调度、多级反馈队列 | [Editorial](./操作系统/有哪些进程调度算法.md)                |
| 死锁发生条件是什么？                                         | 互斥条件 、 持有并等待条件 、 不可剥夺条件 、 环路等待条件   |                                                              |
| 如何避免死锁？                                               | 避免死锁问题就只需要破环其中一个条件就可以，最常见的并且可行的就是**使用资源有序分配法，来破环环路等待条件**。 | [Editorial](./操作系统/如何避免死锁.md)                      |
| 介绍一下操作系统内存管理                                     | 操作系统设计了虚拟内存，每个进程都有自己的独立的虚拟内存，我们所写的程序不会直接与物理内打交道。**内存管理单元（MMU）** |                                                              |
| 介绍copy on write                                            | 写时复制，当多个进程或线程共享同一块数据时，**只有在有写操作时才真正复制数据**，否则大家共享同一份数据副本。 | [Editorial](./操作系统/介绍copyonwrite.md)                   |
| Linux操作系统中哪个命令可以**查看端口**被哪个应用占用？      | 可以使用`lsof`命令或`netstat`命令查看端口被哪个应用占用。` lsof -i :端口号` 或则 `netstat -tulnp | grep 端口号` |                                                              |
| 如果服务应用部署在 Linux 上，**CPU 打满后**，想查看哪个进程导致的，用什么命令？ | 1. 先用 top 或 htop 找到 CPU 占用高的进程对应的 PID。                                                                             2. 可以用 ps aux \| grep <PID> 再进一步查看进程详情。                                                                               3. 若需查看是哪个线程占用 CPU，可结合 top -H -p <PID> 查看该进程内各线程的 CPU 使用情况。 | [Editorial](./操作系统/如果服务应用部署在Linux上，CPU打满后，想查看哪个进程导致的，用什么命令.md) |
| 如果想查看是**进程的哪个线程**，用什么命令？                 | `top -H -p <进程PID>`; [top：系统资源实时监控工具 -H：按线程显示 -p <PID>：只查看（指定PID）进程及其线程] | [Editorial](./操作系统/如果想查看是进程的哪个线程，用什么命令.md) |
| **想查看代码中哪个位置导致的 CPU 高，该怎么做？Java 应用怎么排查 CPU 或内存占用率过高的问题？** | - Linux 层定位进程和线程，转换线程ID为16进制。 - 用 jstack、arthas 等工具定位具体代码位置。 - 内存问题用 jmap、MAT、VisualVM。 - 线上强烈推荐使用 Arthas，简单高效。 | [Editorial](./操作系统/想查看代码中哪个位置导致的CPU高，该怎么做？Java应用怎么排查CPU或内存占用率过高的问题.md) |
| linux如何查看线程和进程状态                                  | Linux 查看进程和线程状态常用命令有：ps、top、pstree、以及通过 /proc 目录查看详细信息。 | [Editorial](./操作系统/linux如何查看线程和进程状态.md)       |
| **讲一下银行家算法**                                         | 银行家算法通过安全性检查，动态决定资源分配，避免死锁，但实现较复杂，适合对资源需求可预知的系统。 | [Editorial](./操作系统/讲一下银行家算法.md)                  |
| 操作系统里面的分段与分页                                     | 分段和分页是操作系统**虚拟内存管理**的两种方式。分段是根据程序的**逻辑结构**（如代码段、数据段、堆栈段）将内存划分为不等长的段，有利于实现模块化和保护，但**容易产生外部碎片**；分页则是将**内存和虚拟地址空间都划分为固定大小的页**，解决了外部碎片问题，提高了内存利用率，但可能产生内部碎片。现代操作系统**常用分页**，有些系统会**结合分段和分页**，兼顾灵活性和高效性。 | [Editorial](./操作系统/操作系统里面的分段与分页.md)          |
| 负载（Load）和CPU利用率之间有什么区别                        | **负载（Load）**表示系统中正在运行和等待CPU处理的**进程数**，是**衡量系统整体压力**的指标；CPU**利用率**则反映CPU实际在忙于处理任务的百分比，表示**CPU的工作强度**。二者不同：高负载说明有很多任务在等待CPU，但CPU利用率不一定高，可能有进程在等待其他资源；高CPU利用率表示CPU很忙，但负载不一定高，可能只有少数任务在密集计算。 | [Editorial](./操作系统/负载（Load）和CPU利用率之间有什么区别.md) |
| 什么是全双工和半双工                                         |                                                              | [Editorial](./操作系统/什么是全双工和半双工.md)              |
| 什么是操作系统的时间片                                       | 操作系统的**时间片**是指在多任务处理（尤其是采用时间片轮转调度算法的操作系统）中，分配给每个进程（或线程）连续运行的一小段时间。每个进程在获得CPU后，只能运行一个时间片长度，时间片用完后，系统会强制切换到下一个进程。这样可以保证所有进程都能被公平调度，提高系统响应速度和资源利用率。时间片越短，系统切换越频繁，响应越快，但切换开销也越大；时间片越长，切换少但响应可能变慢。 |                                                              |
| 什么是操作系统的多级缓存                                     | 操作系统的**多级缓存**【指的是 **CPU中的缓存** ，而不是普通的**主内存RAM**】是指将缓存分为多个层次（如一级缓存L1、二级缓存L2、三级缓存L3等），每一级缓存容量和速度不同，用于提高CPU访问内存的效率。CPU首先在速度最快、容量最小的L1缓存中查找数据，找不到再到L2、L3，最后才访问**主内存【RAM】**。多级缓存设计可以显著减少CPU等待数据的时间，提高系统性能。 |                                                              |
| 什么是MESI缓存一致性协议                                     | 该协议确保在多核或多处理器系统中，各个处理器的缓存中的数据与主内存保持一致，避免“缓存一致性”问题。 | [Editorial](./操作系统/什么是MESI缓存一致性协议.md)          |
| GPU和CPU区别                                                 | **CPU核心数少、GPU核心数多；CPU适合做各种复杂任务，GPU适合做重复性的计算任务。** |                                                              |
| 线程的实现方式有哪些                                         | **使用内核线程实现、使用用户线程实现以及使用用户线程加轻量级进程混合实现。** |                                                              |
| IO多路复用和多线程有什么区别                                 |                                                              | [Editorial](./操作系统/IO多路复用和多线程有什么区别.md)      |
| 为什么按位与运算要比取模运算高效                             | **按位与运算（&）是计算机底层的基本操作，直接在二进制位上进行，由简单的逻辑门实现（AND 门），硬件电路非常简单，非常快速。他的时间复杂度是 O(1)，处理每个位的操作在一个时钟周期内完成。**   而取模运算涉及除法操作，而除法操作比加法、减法和按位运算要复杂得多。因为在许多处理器架构中，除法运算通过迭代或流水线等复杂机制实现，导致其执行时间较长。虽然现代编译器对取模运算也进行了一定的优化，但由于其底层实现的复杂性，优化效果不如按位与运算明显。 |                                                              |
| 什么是页缓存Page Cache，他的读写过程是怎么样的？有什么优缺点 | **为了提升磁盘的读写效率，操作系统在磁盘之上，通过了一个page cache（页缓存），页缓存其实是内存的一种，他就是可以将数据缓存到内存中，从而减少对磁盘的实际读写操作。** | [Editorial](./操作系统/什么是PageCache，他的读写过程是怎么样的？有什么优缺点.md) |
| 给你一个文本文件，每一行包含一个 QQ号码，请用linux命令进行去重 | `sort -u filename.txt -o filename.txt `  ●sort：将文件的内容按字典顺序排序。 ●-u：表示去重（unique），会在排序后移除重复的行。 ●filename.txt：是包含 QQ 号码的文件名。 ●-o filename.txt：将去重后的内容直接写回到原文件。 |                                                              |
| 什么是“孤儿进程”，什么是“僵尸进程”                           | 所谓孤儿，就是无父无母了，那么孤儿进程指的就是**一个父进程没有**了，即已经退出或者终止了，但是这个进程本身还在运行的情况。     如果一个进程**已经退出**了，但是他还**存在于进程表**的话，那么这个进程就是僵尸进程。（虽然这些进程已经执行完毕，但它们的退出状态还没有被父进程回收。） |                                                              |
| 软链接和硬链接的区别                                         |                                                              | [Editorial](./操作系统/软链接和硬链接的区别.md)              |
| Linux下rm正在写入的文件会发生什么                            |                                                              | [Editorial](./操作系统/Linux下rm正在写入的文件会发生什么.md) |

## 【计算机网络】

| Problems                                                | Hints                                                        | Solution                                                     |
| ------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| OSI七层模型                                             | 端口号是传输层的东西，如果一个请求只走到网络层，就不需要端口号 | [Editorial](./计算机网络/OSI七层模型.md)                     |
| 计算机网络的五层架构                                    | 物理－数据链路－网络－传输－应用                             | [Editorial](./计算机网络/计算机网络的五层架构.md)            |
| 报文和字节流分别是什么？                                | 报文：短信这种，一条一条的，有边界。  字节流：打电话，不知道什么时候结束，没有边界，一直发送。 | [Editorial](./计算机网络/报文和字节流分别是什么.md)          |
| TCP协议的流量控制和拥塞控制                             | TCP的流量控制是基于窗口机制实现的： 在建立连接时， 发送方和接收方都会建立一个缓存区，在两端进行通信时，数据包头部会有一个窗口字段，标识了接收端剩余的缓存空间。发送方根据窗口字段的值去判断发送数据的大小，从而避免了缓存溢出。<br/>TCP的拥塞控制算法包含了： 慢启动，拥塞避免，快速重传，快速恢复 <br />**慢启动**指的是发送数据的量从较低的起始值，如一个报文段慢慢指数增长 **拥塞避免**是指当拥塞的窗口小于阈值时，又指数增长降低为线性增长 **快速重传**是指超过三次重复确认即视为传输失败，立即重传 **快速恢复**是指发生快速重传后，立刻减低窗口阈值，并进行拥塞避免的线性增长算法，避免因为拥塞阻碍了重传。 |                                                              |
| http、https、tcp、udp报文结构详讲                       | 像项目里面的自定义tcp协议，是不会走https的，直接通过tcp这种传输层传输，绕过了应用层。netty框架非常适合这样的传输（可以见项目文件的**自定义TCP**） | [Editorial](./计算机网络/http、https、tcp、udp报文结构详讲.md) |
| HTTP 与 HTTPS 协议的区别？                              | 安全、端口、加密方式、证书、完整性、身份认证、SEO、适用场景  | [Editorial](./计算机网络/http与https的区别.md)               |
| HTTP 协议版本比较：HTTP/1.0、HTTP/1.1、HTTP/2 和 HTTP/3 |                                                              | [Editorial](./计算机网络/HTTP协议版本比较.md)                |
| FTP详讲                                                 | File Transfer Protocol，文件传输协议                         | [Editorial](./计算机网络/FTP详讲.md)                         |
| 套接字就是socket吗？是干嘛的                            | 是的，"套接字"就是Socket，它是网络通信的基础组件。 Socket是计算机网络中实现通信的一种软件抽象，它提供了一个**标准接口**，使应用程序能够通过网络发送和接收数据。可以把Socket理解为网络通信的"插座"，它是应用程序与网络协议栈之间的接口。 | [Editorial](./计算机网络/套接字就是socket吗？是干嘛的.md)    |
| HTTP原理是什么？                                        | HTTP（超文本传输协议）是应用层协议 、 HTTP 是基于 TCP 协议来实现的 、 一个完整的 HTTP 请求从请求行开始 、 HTTP 是一种无状态协议，这意味着每个请求都是独立的 、 HTTP 可以传输多种类型的数据，包括文本、图像、音频、视频等 | [Editorial](./计算机网络/HTTP原理是什么.md)                  |
| 为什么需要HTTP/2，他解决了什么问题？                    | HTTP/2主要是解决HTTP中存在的效率问题。它主要引入了**二进制分帧、多路复用、header压缩、以及服务端推送的新特性**，大大的提升了效率。  而且，在HTTP/2中还解决了一个重要的问题，**那就是HTTP的队头阻塞问题。**（目前主要是https在使用） |                                                              |
| HTTP/2存在什么问题，为什么需要HTTP/3？                  |                                                              | [Editorial](./计算机网络/HTTP2存在什么问题，为什么需要HTTP3.md) |
| 什么是HTTP/3的QUIC协议                                  | 一种完全基于UDP的协议                                        | [Editorial](./计算机网络/什么是HTTP3的QUIC协议.md)           |
| TCP和UDP区别是什么？                                    | 连接、服务对象、可靠性、 拥塞控制、流量控制 、首部开销、传输方式 | [Editorial](./计算机网络/TCP和UDP区别是什么？.md)            |
| TCP三次握手与四次挥手                                   | 目的：建立可靠的连接，保证双方收发能力正常。                 | [Editorial](./计算机网络/TCP三次握手与四次挥手.md)           |
| TCP协议里的TIME_WAIT状态是什么？                        | TIME_WAIT 状态的存在是为了确保网络连接的可靠关闭。只有主动发起关闭连接的一方（即主动关闭方）才会有 TIME_WAIT 状态。 | [Editorial](./计算机网络/TCP协议里的TIME_WAIT状态是什么？.md) |
| UDP怎么保证可靠性？                                     | 连接迁移 、 重传机制 、 前向纠错 、 拥塞控制                 | [Editorial](./计算机网络/UDP怎么保证可靠性？.md)             |
| 网络有什么常用的通信协议？                              | **HTTP**：用于在**Web浏览器**和**Web服务器**之间传输超文本的协议，是目前最常见的**应用层**协议。  **HTTPS**：在HTTP的基础上添加了**SSL/TLS**加密层，用于在不安全的网络上安全地传输数据。  **TCP**：面向连接的**传输层**协议，提供可靠的数据传输服务，保证数据的顺序和完整性。  **UDP**：无连接的**传输层**协议，提供了数据包传输的简单服务，适用于实时性要求高的应用。  **IP**：**网络层**协议，用于在网络中传输数据包，定义了数据包的格式和传输规则。 |                                                              |
| 前后端交互用的是什么协议？                              | 用HTTP和HTTPS协议比较多。前端通过HTTP协议向服务器端发送请求，服务器端接收请求并返回相应的数据，实现了前后端的交互。HTTP协议简单、灵活，适用于各种类型的应用场景。 |                                                              |
| HTTP 常见状态码有哪些？                                 | 1XX：提示信息；2XX：成功；3XX：重定向；4XX：报文有误；5XX：服务器内部错误 | [Editorial](./计算机网络/HTTP常见状态码有哪些？.md)          |
| Dns基于什么协议实现？udp 还是 tcp？                     | DNS(域名系统) 基于UDP协议实现，DNS使用UDP协议进行域名解析和数据传输。 |                                                              |
| 为什么是udp？                                           | **低延迟** 、**简单快速**、**轻量级**                        |                                                              |
| http的特点是什么？                                      | 基于文本、可扩展性、灵活性、无状态                           | [Editorial](./计算机网络/http的特点是什么.md)                |
| http无状态体现在哪？                                    | HTTP的无状态体现在每个请求之间**相互独立**，服务器不会保留之前请求的状态信息。每次客户端向服务器发送请求时，服务器都会独立处理该请求，不会记住之前的请求信息或状态。 | [Editorial](./计算机网络/http无状态体现在哪.md)              |
| Cookie和session的区别是什么？                           | 存储位置、安全性、存储容量                                   | [Editorial](./计算机网络/Cookie和session的区别是什么？.md)   |
| 介绍一下JWT                                             | JWT（Json Web Token）是一个字符串，由三部分组成：Header、Payload、Signature。 JWT的内容主要在**Payload**部分，可以直接被解析（**不需要密钥就能解析，但不能验证真实性**）。 | [Editorial](./计算机网络/介绍一下JWT.md)                     |
| 服务器处理并发请求有哪几种方式？                        | 单线程web服务器方式 、 多进程/多线程web服务器 、 I/O多路复用web服务器 、 多路复用多线程web服务器 | [Editorial](./计算机网络/服务器处理并发请求有哪几种方式？.md) |
| 为什么要有I/O多路复用机制                               | 在高并发服务器（如Web服务器）编程中，通常需要同时处理成百上千个网络连接。如果每个连接都用一个线程或进程，系统资源消耗很大，效率低下。因此，需要一种机制能在**单个线程**内，高效监控和管理多个网络连接（socket）的读写状态，这就是**I/O多路复用**。 | [Editorial](./计算机网络/为什么要有IO多路复用机制.md)        |
| 说一下select，poll，epoll的区别？                       | `select`、`poll` 和 `epoll` 都是 **I/O 多路复用** 机制，用于 **同时监听多个文件描述符（FD）**，当某个 FD **可读/可写** 时通知应用程序。   `select`、`poll` 适用于小规模连接，**O(N) 复杂度**，随 FD 数量增加性能下降。  **现代 Linux 服务器推荐 epoll**，性能最佳！🚀 | [Editorial](./计算机网络/说一下select_poll_epoll的区别.md)   |
| https是如何防范中间人的攻击？                           | 加密、身份校验机制                                           | [Editorial](./计算机网络/https是如何防范中间人的攻击.md)     |
| 描述一下打开百度首页后发生的网络过程                    |                                                              | [Editorial](./计算机网络/描述一下打开百度首页后发生的网络过程.md) |
| 什么是ddos攻击？怎么防范？                              | 分布式拒绝服务（DDoS）攻击是通过大规模互联网流量淹没目标服务器或其周边基础设施，以破坏目标服务器、服务或网络正常流量的恶意行为。 | [Editorial](./计算机网络/什么是ddos攻击？怎么防范？.md)      |
| 如何查看网络连接情况？                                  | 常用 netstat、lsof、ifconfig、ip、ping 等命令，可快速查看 Linux 网络连接和状态。 | [Editorial](./计算机网络/如何查看网络连接情况.md)            |
| ARP 与 RARP 的区别是什么                                | ARP（Address Resolution Protocol）和RARP（Reverse Address Resolution Protocol）都是网络通信协议，用于将IP地址和MAC地址进行转换。 |                                                              |
| 路由器与交换机的区别是什么                              | 交换机主要工作在数据链路层（第二层），路由器工作在网络层（第三层）  交换机转发所依据的对象是物理地址，也就是MAC地址，而路由器转发所依据的对象时网络地址，也就是IP地址。  交换机主要用于组建局域网，而路由主要功能是将由交换机组好的局域网相互连接起来，或者接入互联网。 【光猫见Editorial】 | [Editorial](./计算机网络/光猫.md)                            |
| ping的原理是什么                                        | ping 的原理是通过发送 ICMP（Internet Control Message Protocol）回显请求（Echo Request）报文到目标主机，并等待对方回复 ICMP 回显应答（Echo Reply）报文，从而测试网络连通性及响应时间。它可以简单有效地判断本机与目标主机之间的网络是否正常。 |                                                              |
| ping为什么不需要端口                                    | **ping是一个应用层直接使用网络层协议的例子，不涉及到传输层，所以不需要指定端口号。** | [Editorial](./计算机网络/ping为什么不需要端口号.md)          |
| 什么是IPV6？和IPV4有什么区别？                          | IPv6（Internet Protocol version 6） 是一种用于网络地址分配和数据包路由的新一代互联网协议，是 IPv4 的升级版。 它由 IETF（互联网工程任务组）设计，主要目的是解决 IPv4 地址枯竭问题，并提升网络性能和安全性。 【IPV4只支持约42亿个ip，也就是2^32】 |                                                              |
| 什么是正向代理和反向代理？                              | **正向代理**是客户端通过代理服务器访问目标服务器，代理服务器代表用户发起请求，主要用于突破访问限制或保护用户隐私；**反向代理**则是代理服务器位于目标服务器前端，用户的请求先到代理服务器，由其转发给后端服务器，主要用于负载均衡、安全防护和隐藏真实服务器信息。 |                                                              |
| 什么是跨域访问问题，如何解决                            | 跨域访问问题是指浏览器出于安全策略（**同源策略**），阻止网页向不同域名的服务器请求资源，导致前端无法直接访问其他域的接口。常见解决办法包括服务器端**设置 CORS（跨域资源共享）响应头**、使用 **JSONP**、**反向代理**等方式，从而允许合法的跨域数据交换。 | [Editorial](./计算机网络/跨域问题.md)                        |
| 什么是CDN，为什么他可以做缓存？                         | CDN（内容分发网络）是一种分布式服务器系统，通过将内容缓存到全球各地的节点，使用户可以从距离最近的服务器获取数据，从而加速访问速度并减轻源站压力。CDN 能做缓存，是因为它会将静态资源如图片、视频、网页等临时存储在边缘节点，用户请求时直接返回缓存内容，无需每次都访问源站，大幅提升性能和可用性。 |                                                              |

## 【场景题】

| Problems                                                     | Hints                                                        | Solution                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 设计一个群聊系统                                             | 如果让我设计一个群聊系统，我会从前后端分离、消息实时性、数据持久化和系统扩展性几个方面来考虑。前端通过WebSocket与后端建立长连接，实现消息的实时双向推送。后端负责用户的注册登录、身份认证、群组和成员管理，以及消息的接收和分发。消息在到达服务器后会先进行权限校验，然后被存储到数据库中，保证消息历史可追溯。<br>数据库设计会包括用户表、群组表、群成员表和消息表，分别管理用户信息、群信息、成员关系和消息内容。对于离线用户，服务器会在其上线时推送未读消息，保证消息不丢失。为了提升高并发下的性能，我会考虑使用Redis做缓存和消息队列，并通过服务分层和负载均衡提升系统的可扩展性和稳定性。此外，系统还需要关注安全性，比如消息传输加密和权限校验，来保障用户数据的隐私和安全。 |                                                              |
| 数据库设计会包括用户表、群组表、群成员表和消息表，分别管理用户信息、群信息、成员关系和消息内容。对于离线用户，服务器会在其上线时推送未读消息，保证消息不丢失。为了提升高并发下的性能，我会考虑使用Redis做缓存和消息队列，并通过服务分层和负载均衡提升系统的可扩展性和稳定性。此外，系统还需要关注安全性，比如消息传输加密和权限校验，来保障用户数据的隐私和安全。针对 MySQL的千万级订单表（大表）新增字段 | 分两个版本进行讨论，首先是5.6：由于mysql5.6的在线DDL能力较弱，很多场景会触发锁表甚至重建全表，需要谨慎处理；1、mysql5.6的`alert table`会锁表，选择业务顶峰期进行操作；2、减少锁表的时间：新增字段尽量允许为空，且默认值为空，并且不要用`after 某字段`（不要指定字段插入到具体某个位置，默认插入末尾）；3、备份和预演；4、分区表优化；5、可以考虑使用在线工具辅助，实现"无锁"在线变更字段；6、做好监控与回滚。                                                                                                                                  然后是8.x的版本，所有的注意事项与上面的一样，只是8.x的版本支持`algorithm = inplace`或`algorithm = instant`在线变更（秒级完成变更） |                                                              |
| 每天凌晨2点同步1000多个商家数据，单个任务5-10秒，失败重试3次，线程池如何设计？ |                                                              | [Editorial](./场景题/每天凌晨2点同步1000多个商家数据，单个任务5-10秒，失败重试3次，线程池如何设计？.md) |
| 限流算法有哪些？                                             | 计数器、滑动窗口、令牌桶、漏桶、滑动窗口日志                 | [Editorial](./场景题/限流算法有哪些.md)                      |
| redis，nginx，netty 是依赖什么做的这么高性能？               | ✅**Redis**：单线程但**超快**，因 `epoll + 高效数据结构`。  ✅ **Nginx**：`epoll + sendfile` 提供**超高吞吐量**，适合 Web 服务器。  ✅ **Netty**：`epoll + ByteBuf` 提供**高并发网络通信**，用于 RPC、微服务。 | [Editorial](./场景题/redis_nginx_netty是依赖什么做的这么高性能.md) |
| 如何实现高并发下的唯一订单号生成？                           | **分布式唯一ID生成方案**：数据库自增（易冲突）、UUID（不可读）、Redis自增（高并发）、雪花算法（趋势递增/高性能）  **高并发推荐**：Redis自增或雪花算法，注意时钟回拨和高可用  **记忆口诀**：自增易阻塞，UUID难查找，Redis快雪花妙，唯一有序最重要 | [Editorial](./场景题/如何实现高并发下的唯一订单号生成？.md)  |
| 什么是时钟回拨，如何解决？                                   | 检测拒绝回拨、依赖单调递增时钟、融合自增序列、外部时间源     | [Editorial](./场景题/什么是时钟回拨，如何解决.md)            |
| 高并发场景下如何保证接口的幂等性？                           | **幂等性含义**：同一操作多次执行结果相同    **场景**：支付回调、订单创建、消息消费    **常用方案**：唯一请求号（幂等号）、数据库唯一约束、token机制、乐观锁    **高并发建议**：前端生成幂等号，后端Redis/DB去重，注意性能与存储清理 | [Editorial](./场景题/高并发场景下如何保证接口的幂等性？.md)  |
| 查询操作需要做幂等性处理吗？如果用户一直查询，那么数据库的压力岂不是很大？ | 不需要；使用**mybatis自带的一二级缓存**，就可以防止这种情况。使用redis缓存太麻烦了，还需要与数据库做同步，然后配合前端**按钮禁用**+**限流** |                                                              |
| 高并发下如何实现分布式锁？常见方案和优缺点分析               | - **分布式锁方案**：数据库锁（简单低效）、Redis锁（高性能高并发）、ZooKeeper锁（强一致性） - **高并发推荐**：Redis锁+唯一标识+自动过期，或Redisson - **记忆口诀**：数据库易瓶颈，Redis快需防误删，ZooKeeper强一致 | [Editorial](./场景题/高并发下如何实现分布式锁？常见方案和优缺点分析.md) |
| 高并发场景下如何防止重复提交？                               | **防重提交方案**：幂等Token、接口Token机制、数据库唯一约束、前端防抖/节流  **高并发推荐**：幂等号+Redis存储，数据库唯一约束兜底  **记忆口诀**：幂等号拦重复，Token校验防误触，DB唯一兜底忙 | [Editorial](./场景题/高并发场景下如何防止重复提交？.md)      |
| 高并发下如何实现异步消息削峰填谷？                           | **削峰填谷原理**：用消息队列缓冲高并发请求，慢慢消费  **常见模型**：生产-消费模型 + 限流排队  **高并发建议**：异步写队列+多消费者+幂等消费+死信队列  **记忆口诀**：高峰进队列，后台慢处理，幂等防重复，死信防丢失 | [Editorial](./场景题/高并发下如何实现异步消息削峰填谷？.md)  |
| 高并发下如何保证数据一致性？常见一致性方案与适用场景         | - **一致性模型**：强一致性、最终一致性、弱一致性 - **常用方案**：分布式事务（2PC/TCC/SAGA）、消息中间件+补偿、乐观锁/悲观锁 - **高并发建议**：最终一致性+幂等+补偿，关键业务用强一致 - **记忆口诀**：强一致慢安全，最终一致高性能，幂等补偿保周全 | [Editorial](./场景题/高并发下如何保证数据一致性？常见一致性方案与适用场景.md) |
| 高并发场景下如何合理利用多级缓存？                           | **多级缓存架构**：本地缓存（低延迟）+分布式缓存（高容量）+数据库（最终兜底）  **高并发建议**：优先读本地，未命中再查分布式，再查数据库  **常见问题**：一致性、容量、更新策略、缓存预热  **记忆口诀**：本地快，分布广，分级兜底保高并，更新一致少烦恼 | [Editorial](./场景题/高并发场景下如何合理利用多级缓存？.md)  |
| 高并发下如何实现热点数据和热点Key的优化防护？                | - **热点Key识别与优化**：监控分析+分片分流+本地缓存+静态化+限流降级 - **高并发建议**：热点分片、本地预热、请求排队、静态内容、限流兜底 - **记忆口诀**：分片分流解热点，本地缓存降压力，静态限流兜底忙 | [Editorial](./场景题/高并发下如何实现热点数据和热点Key的优化防护？.md) |
| 高并发下如何设计高可用与自动故障转移机制？                   | **高可用目标**：无单点、自动切换、弹性伸缩、持续服务  **常用方案**：负载均衡+多实例、主从/主备切换、集群、副本、健康检查  **高并发建议**：分层高可用（服务/缓存/数据库）、自动故障转移、监控告警  **记忆口诀**：负载均衡分流忙，主备切换保不停，集群副本抗风险，健康自愈少故障 | [Editorial](./场景题/高并发下如何设计高可用与自动故障转移机制？.md) |
| 高并发系统下如何实现高效**日志采集与追踪**？                 | 高效日志采集与追踪系统的核心在于：异步无侵入采集、高性能传输队列、分布式存储与检索优化、全链路追踪能力。通过合理的架构设计和优化手段，可以在保障业务性能的同时，实现高并发系统的可观测性和问题快速定位。 | [Editorial](./场景题/高并发系统下如何实现高效日志采集与追踪？.md) |
| 分布式系统中如何保证消息的可靠投递？                         | 存消息要持久，发确认要等全，消费记得要幂等，异常补偿别放松！ | [Editorial](./场景题/分布式系统中如何保证消息的可靠投递？.md) |
| 如何应对高并发下的数据库事务一致性问题？                     |                                                              | [Editorial](./场景题/如何应对高并发下的数据库事务一致性问题？.md) |
| 如何排查和解决Java线上系统的内存泄漏问题？                   |                                                              | [Editorial](./场景题/如何排查和解决Java线上系统的内存泄漏问题？.md) |
| 请你设计秒杀系统，你会考虑哪些问题？                         | 1、高并发瞬时流量 2、热点数据 3、数据量大 4、库存的正确扣减 5、黄牛抢购 6、重复下单 7、对普通交易的影响 |                                                              |
| 如何解决秒杀问题？                                           |                                                              | [Editorial](./场景题/如何解决秒杀问题.md)                    |
| 订单到期关闭如何实现                                         | **定时任务**（推荐，适合时间精确度要求不高的场景） 、 **Redisson**（推荐，可以用） | [Editorial](./场景题/订单到期关闭如何实现.md)                |
| 定时消息对比延迟消息                                         |                                                              | [Editorial](./场景题/定时消息对比延迟消息.md)                |
| 每天100w次登录请求，4C8G机器如何做JVM调优？                  | 堆内存配置、垃圾收集器选择、添加必要的日志                   | [Editorial](./场景题/每天100w次登录请求4C8G机器如何做JVM调优.md) |
| 如果你的业务量突然提升100倍QPS你会怎么做？                   | 异常情况：被ddos攻击了；正常情况：临时的突发流量、长久性的突发流量 | [Editorial](./场景题/如果你的业务量突然提升100倍QPS你会怎么做.md) |
| 如何设计一个高并发系统                                       |                                                              | [Editorial](./场景题/如何设计一个能够支持高并发的系统.md)    |
| 介绍一下限流、降级、熔断                                     |                                                              | [Editorial](./场景题/介绍一下限流降级熔断.md)                |
| 不用redis分布式锁，如何防止用户重复点击？                    |                                                              | [Editorial](./场景题/不用redis分布式锁如何防止用户重复点击.md) |
| 让你设计一个订单号生成服务，该怎么做?                        | 唯一性、数据量、可读性、基因法（考虑后期分表）、可扩展性、高性能、高可用 | [Editorial](./场景题/订单生成服务.md)                        |
| 如何设计一个购物车功能？                                     | **SKUID** 是指 **库存单位标识（Stock Keeping Unit Identifier）**，是用于唯一标识商品的一种编码。 | [Editorial](./场景题/如何设计一个购物车功能.md)              |
| 如果让你实现消息队列，会考虑哪些问题？                       |                                                              | [Editorial](./场景题/如果让你实现消息队列会考虑哪些问题.md)  |
| 如何用Redis实现朋友圈点赞功能？                              |                                                              | [Editorial](./场景题/如何用Redis实现朋友圈点赞功能.md)       |
| Redis的zset实现排行榜，实现分数相同按照时间顺序排序，怎么做？ |                                                              | [Editorial](./场景题/reids中zset做排行榜.md)                 |
| 如何实现"查找附近的人"功能？                                 | 使用Redis的GEOADD命令将用户经纬度信息存储在一个指定的键值中，然后再使用Redis的`GEORADIUS`命令可以查询指定经纬度附近一定范围内的用户信息就能简单实现这个功能了。 [Redis中的GEO介绍](./Redis/什么是GEO有什么用.md) |                                                              |
| 消息队列使用拉模式好还是推模式好？为什么？                   |                                                              | [Editorial](./场景题/消息队列使用拉模式好还是推模式好为什么.md) |
| 如果让你实现一个RPC框架，会考虑用哪些技术解决哪些问题?       |                                                              | [Editorial](./场景题/如果让你实现一个RPC框架，会考虑用哪些技术解决哪些问题.md) |
| Kafka，单分区单消费者实例，如何提高吞吐量                    | 1、异步消费 2、增加消费的线程数 3、消息压缩或组合 4、调整Kafka参数 | [Editorial](./场景题/Kafka单分区单消费者实例如何提高吞吐量.md) |
| 一个订单，在11:00超时关闭，但在11:00也支付成功了，怎么办？   |                                                              | [Editorial](./场景题/一个订单在超时关闭但在也支付成功了怎么办.md) |
| 一个支付单，多个渠道同时支付成功了怎么办？                   |                                                              | [Editorial](./场景题/一个支付单，多个渠道同时支付成功了怎么办？.md) |
| 你是如何进行SQL调优的                                        |                                                              | [Editorial](./场景题/你是如何进行SQL调优的.md)               |
| 不使用synchronized和Lock如何设计一个线程安全的单例？         | **饿汉**，其实都是通过定义静态的成员变量，以保证instance可以在类初始化的时候被实例化。  **静态内部类**，这种方式和饿汉方式只有细微差别，只是做法上稍微优雅一点。这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。但是，原理和饿汉一样。  **枚举**，其实，如果把枚举类进行反编译，你会发现他也是使用了static final来修饰每一个枚举项。  还可以用**CAS** |                                                              |
| 40亿个QQ号，限制1G内存，如何去重？                           |                                                              | [Editorial](./场景题/40亿个QQ号限制1G内存如何去重.md)        |
| 说一说多级缓存是如何应用的？                                 | 客户端缓存->CDN->Nginx->Guaua->Redis                         |                                                              |
| 从B+树的角度分析为什么单表2000万要考虑分表                   |                                                              | [Editorial](./场景题/从B+树的角度分析为什么单表2000万要考虑分表.md) |
| InnoDB为什么不用跳表，Redis为什么不用B+树？                  | InnoDB选择B+树是因为它是**磁盘型数据库**，首要目标是**减少磁盘I/O**。B+树的"矮胖"特性（通常3-4层就能存储百万级数据）使得查询操作只需少量磁盘访问。同时，B+树节点可以完美匹配磁盘页大小（16KB），一次I/O能加载多个键值。另外，B+树所有数据都在叶节点且叶节点相连，使得范围查询特别高效，这对关系型数据库的场景至关重要。  相比之下，Redis选择跳表是因为它是**内存数据库**，不需考虑磁盘I/O优化。跳表的主要优势在于实现简单（约300行代码vs B+树的复杂实现），内存利用率高（按需分配索引层级），以及修改操作不需要复杂的重平衡。Redis作者也明确表示了对实现简洁性的偏好。 | [Editorial](./场景题/InnoDB为什么不用跳表Redis为什么不用B+树.md) |
| 线上接口如果响应很慢如何去排查定位问题呢？                   | 直接上Arthas定位耗时的接口                                   |                                                              |
| 怎么做数据对账                                               |                                                              | [Editorial](./场景题/怎么做数据对账.md)                      |
| MySQL千万级大表如何做数据清理                                |                                                              | [Editorial](./场景题/MySQL千万级大表如何做数据清理.md)       |
| MySQL 里有 2000W 数据，Redis 中只存 20W 的数据，如何保证 Redis 中的数据都是热点数据? | 数据预热、热点数据更新、缓存过期策略、缓存淘汰策略           | [Editorial](./场景题/MySQL里有2000W数据Redis中只存20W的数据如何保证Redis中的数据都是热点数据.md) |
| 用了一锁二查三更新，为啥还出现了重复数据                     |                                                              | [Editorial](./场景题/用了一锁二查三更新为啥还出现了重复数据.md) |
| 一个接口3000QPS，接口RT为200MS，预估需要几台机器             |                                                              | [Editorial](./场景题/一个接口3000QPS接口RT为200MS预估需要几台机器.md) |
| 在100M内存下存储一亿个整数，其范围在１到2亿，如何快速判断给定到一个整数值是否存在？ |                                                              | [Editorial](./场景题/在100M内存下存储一亿个整数其范围在1到2亿如何快速判断给定到一个整数值是否存在.md) |
| 数据库逻辑删除后，怎么做唯一性约束？                         |                                                              | [Editorial](./场景题/数据库逻辑删除后怎么做唯一性约束.md)    |
| 如果单表数据量大，只能考虑分库分表吗？                       |                                                              | [Editorial](./场景题/如果单表数据量大只能考虑分库分表吗.md)  |
| 如何实现缓存的预热                                           | **启动预热**：适合本地缓存  **定时任务**：保证缓存数据时效性  **懒加载**：灵活，适合分散访问模式  **缓存加载器**：自动加载和刷新，简化预热逻辑 | [Editorial](./场景题/如何实现缓存的预热.md)                  |
| 跨库join如何实现                                             |                                                              | [Editorial](./场景题/跨库join如何实现.md)                    |
| 应用占用内存持续增长，但是堆内存、元空间都没变化，可能是什么原因？ |                                                              | [Editorial](./场景题/应用占用内存持续增长但是堆内存元空间都没变化可能是什么原因.md) |
| 4C8G机器系统指标参考范围                                     |                                                              | [Editorial](./场景题/4C8G机器系统指标参考范围.md)            |
| 4C8G 16台和 8C16G 8台，不考虑成本的情况怎么选？              |                                                              | [Editorial](./场景题/4C8G16台和8C16G8台不考虑成本的情况怎么选.md) |
| 如何预估一个系统的QPS                                        |                                                              | [Editorial](./场景题/如何预估一个系统的QPS.md)               |
| 如果要存IP地址，用什么数据类型比较好                         |                                                              | [Editorial](./场景题/如果要存IP地址，用什么数据类型比较好.md) |
| 如何实现敏感词过滤？                                         | 字符串匹配、字典树、AC自动机                                 |                                                              |
| 为啥不要在事务中做外部调用？                                 |                                                              | [Editorial](./场景题/为啥不要在事务中做外部调用.md)          |
| 如何做平滑的数据迁移?                                        |                                                              | [Editorial](./场景题/如何做平滑的数据迁移?.md)               |
| 如何实现一个抢红包功能？                                     |                                                              | [Editorial](./场景题/如何实现一个抢红包功能.md)              |
| 分布式事务与加锁的顺序对比                                   |                                                              | [Editorial](./场景题/分布式事务与加锁的顺序对比.md)          |
| 加分布式锁之后影响并发了怎么办？                             |                                                              | [Editorial](./场景题/加分布式锁之后影响并发了怎么办.md)      |
| 数据库乐观锁、悲观锁与 Redis 分布式锁的区别与使用场景        |                                                              | [Editorial](./场景题/数据库乐观锁悲观锁与Redis分布式锁的区别与使用场景.md) |
| 为什么很多公司不允许数据库物理删除delete数据                 |                                                              | [Editorial](./场景题/为什么很多公司不允许数据库物理删除delete数据.md) |
| 为什么不用分布式锁来实现秒杀？                               |                                                              | [Editorial](./场景题/为什么不用分布式锁来实现秒杀？.md)      |
| 为什么不直接用原生的 `BlockingQueue` 做消息队列？            |                                                              | [Editorial](./场景题/为什么不直接用原生的BlockingQueue做消息队列.md) |
| SpringEvent和 MQ的区别及适用场景                             |                                                              | [Editorial](./场景题/SpringEvent和MQ的区别及适用场景.md)     |
| 如何实现百万级排行榜功能？                                   |                                                              | [Editorial](./场景题/如何实现百万级排行榜功能.md)            |
| 为什么一定要做限流？不应该服务好客户吗？加机器不行吗？       |                                                              | [Editorial](./场景题/为什么一定要做限流？不应该服务好客户吗？加机器不行吗？.md) |
| 大型电商的订单系统，如何设计分库分表方案？                   |                                                              | [Editorial](./场景题/大型电商的订单系统如何设计分库分表方案.md) |
| 你认为分布式架构一定比单体架构要好吗                         |                                                              | [Editorial](./场景题/你认为分布式架构一定比单体架构要好吗.md) |
| Redis如果挂了你怎么办                                        |                                                              | [Editorial](./场景题/Redis如果挂了你怎么办.md)               |
| 代码中使用长事务，会带来哪些问题？                           |                                                              | [Editorial](./场景题/代码中使用长事务，会带来哪些问题？.md)  |
| Redis的内存如果用满了，会挂吗？                              |                                                              | [Editorial](./场景题/Redis的内存如果用满了，会挂吗？.md)     |
| 给第三方提供接口调用，需要注意些什么                         | 对外接口设计，核心是安全、通用、清晰、可扩展、自我保护，配合详细文档和错误体系，让第三方用着省心，自己维护也省力 | [Editorial](./场景题/给第三方提供接口调用，需要注意些什么.md) |
| 应用启动后前几分钟，Load、RT、CPU等飙高，如何定位，可能的原因是什么？ |                                                              | [Editorial](./场景题/应用启动后前几分钟LoadRTCPU等飙高如何定位可能的原因是什么.md) |
| 分库分表时每个城市人口不均，如何实现数据均匀分布？           |                                                              | [Editorial](./场景题/分库分表时每个城市人口不均，如何实现数据均匀分布？.md) |
| 项目中，日志打印成为瓶颈，该如何优化？                       |                                                              | [Editorial](./场景题/项目中，日志打印成为瓶颈，该如何优化？.md) |
| 登录拉黑功能实现：拉黑用户 & 踢下线                          |                                                              | [Editorial](./场景题/登录拉黑功能实现拉黑用户踢下线.md)      |
| 调用第三方接口支付时，第三方显示支付成功，但调用方显示支付失败，可能原因分析 |                                                              | [Editorial](./场景题/调用第三方接口支付时，第三方显示支付成功，但调用方显示支付失败，可能原因分析.md) |
| 读取一千个文件，一个线程读取和开十个线程读取，哪种方式效率高？ |                                                              | [Editorial](./场景题/读取一千个文件，一个线程读取和开十个线程读取，哪种方式效率高.md) |
| a,b 联合索引，select b where a = xx 无法走索引覆盖的原因     |                                                              | [Editorial](./场景题/索引失效问题.md)                        |
| 大量的手机号码被标记成骚扰电话，如何高效存储与查询？         |                                                              | [Editorial](./场景题/大量的手机号码被标记成骚扰电话，如何高效存储与查询.md) |
| 商品加入购物车时断网，重新联网后如何同步？                   |                                                              | [Editorial](./场景题/商品加入购物车时断网，重新联网后如何同步.md) |
| 不用大于号小于号，如何判断两个正整数的大小？                 |                                                              | [Editortial](./场景题/不用大于号小于号，如何判断两个正整数的大小.md) |
| 外卖系统，一天一千万条数据，用户需要查到近30天的数据，商家也要查询到30天的数据，怎么设计表 |                                                              | [Editorial](./场景题/外卖系统，一天一千万条数据，用户需要查到近30天的数据，商家也要查询到30天的数据，怎么设计表.md) |
| 进入电梯里断网后又恢复刚开始为什么网络慢？                   | 电梯断网后刚恢复时网络慢，主要是**TCP拥塞控制慢启动**和**无线网络重新协商**导致的，随着连接稳定与拥塞窗口恢复，网络速度才会逐步提升。 | [Editorial](./场景题/进入电梯里断网后又恢复刚开始为什么网络慢.md) |
| 一个表有用户和时间两个列，现有3个需求：根据用户查；根据日期查；根据日期和用户查；问怎么建立索引？ |                                                              | [Editorial](./场景题/一个表有用户和时间两个列，现有3个需求根据用户查根据日期查根据日期和用户查问怎么建立索引.md) |
| 黑名单网址过滤系统设计与数据结构选择                         |                                                              | [Editorial](./场景题/黑名单网址过滤系统设计与数据结构选择.md) |
| 全国的酒店价格（千万级）需要在某个瞬间比如7点发生变动，怎样高性能准点去进行变更 |                                                              | [Editorial](./场景题/全国的酒店价格（千万级）需要在某个瞬间比如7点发生变动，怎样高性能准点去进行变更.md) |
| 服务器有多个节点，线上出现用户进入**缓慢**，监控服务器**cpu和缓存没有什么压力**，可以从哪些方面排查？ |                                                              | [Editorial](./场景题/服务器有多个节点，线上出现用户进入缓慢，监控服务器cpu和缓存没有什么压力，可以从哪些方面排查.md) |
| 账户里面只有十块钱，同时发来两笔订单一共大于十块钱，怎么保证**不超花** |                                                              | [Editorial](./场景题/账户里面只有十块钱同时发来两笔订单一共大于十块钱怎么保证不超花.md) |
| 项目中需要应用发布和ddl变更，需要如何保证不出错              | DDL（Data Definition Language，数据定义语言）, DDL 主要用于定义和**更改数据库表结构**，而不是用于操作表中的具体数据（**数据的增删改查属于 DML**）。 | [Editorial](./场景题/项目中需要应用发布和ddl变更，需要如何保证不出错.md) |
| 有100个优惠券，有几千万流量，怎么保证服务器不跨掉，怎么保证最前面的人能抢到这个券 |                                                              | [Editorial](./场景题/有100个优惠券，有几千万流量，怎么保证服务器不跨掉，怎么保证最前面的人能抢到这个券.md) |
| 秒杀场景下，怎么加库存                                       |                                                              | [Editorial](./场景题/秒杀场景下，怎么加库存.md)              |
| 5分钟内最多允许用户尝试登录3次，如果错误次数超过限制，需要对该用户进行锁定。如何实现 |                                                              | [Editorial](./场景题/5分钟内最多允许用户尝试登录3次，如果错误次数超过限制，需要对该用户进行锁定。如何实现.md) |
| 两个不相关的网站A和B，如何实现A登录B也能自动登录             |                                                              | [Editorial](./场景题/两个不相关的网站A和B，如何实现A登录B也能自动登录.md) |
| MQ出现消息乱序了如何解决？                                   |                                                              | [Editorial](./场景题/MQ出现消息乱序了如何解决.md)            |
| 在for循环中调用数据库，有什么缺点？如何优化？                |                                                              | [Editorial](./场景题/在for循环中调用数据库，有什么缺点？如何优化？.md) |
| MySQL单表一千万条数据怎么做分页查询？                        |                                                              | [Editorial](./场景题/MySQL单表一千万条数据怎么做分页查询.md) |
| MySQL千万级数据量，查询如何做优化                            |                                                              | [Editorial](./场景题/MySQL千万级数据量，查询如何做优化.md)   |
| 什么是数据归档，一般是怎么做的                               |                                                              | [Editorial](./场景题/什么是数据归档，一般是怎么做的.md)      |
| 第三方接口不稳定经常超时，如何处理三方接口异常不影响自己接口 |                                                              | [Editorial](./场景题/第三方接口不稳定经常超时，如何处理三方接口异常不影响自己接口.md) |
| Redis、MySQL和MongoDB的区别是什么，各自适用场景呢            |                                                              | [Editorial](./场景题/Redis、MySQL和MongoDB的区别是什么，各自适用场景呢.md) |
| Redis实现分布式锁，加锁的时候，redis不可用了咋整？           |                                                              | [Editorial](./场景题/Redis实现分布式锁，加锁的时候，redis不可用了咋整.md) |
| 如果让你实现短链服务，如何生成不重复的短链地址               |                                                              | [Editorial](./场景题/如果让你实现短链服务，如何生成不重复的短链地址.md) |
| MySQL如果突然断电，会发生数据丢失吗                          |                                                              | [Editorial](./场景题/MySQL如果突然断电，会发生数据丢失吗.md) |
| 防止接口被恶意刷流量，除了限流还应在代码层面做哪些防护       |                                                              | [Editorial](./场景题/防止接口被恶意刷流量，除了限流还应在代码层面做哪些防护.md) |
| 库存扣减、创建订单，如何拆成TCC？                            |                                                              | [Editorial](./场景题/库存扣减、创建订单，如何拆成TCC.md)     |
| Redis保存库存的时候，如何避免被Redis清理掉                   |                                                              | [Editorial](./场景题/Redis保存库存的时候，如何避免被Redis清理掉.md) |
| 如果token被窃取了，是不是就能伪造登陆了？                    |                                                              | [Editorial](./场景题/如果token被窃取了，是不是就能伪造登陆了.md) |
| 如果有1TB的数据需要排序，但只有32GB的内存如何排序处理？      |                                                              | [Editorial](./场景题/如果有1TB的数据需要排序，但只有32GB的内存如何排序处理.md) |
| 如何从1TB的搜索日志中找出搜索量最高的10个关键词?             |                                                              | [Editorial](./场景题/如何从1TB的搜索日志中找出搜索量最高的10个关键词.md) |
| 用@Scheduled执行定时任务，如何避免集群的并发问题             |                                                              | [Editorial](./场景题/用@Scheduled执行定时任务，如何避免集群的并发问题.md) |
| 下单支付过程，点击跳转支付，输入密码，支付完成后跳转到订单页，整个过程可能会有什么问题？架构方面做哪些设计？ |                                                              | [Editorial](./场景题/下单支付过程，点击跳转支付，输入密码，支付完成后跳转到订单页，整个过程可能会有什么问题？架构方面做哪些设计.md) |
| 有一张上百万条数据的单表，从前端页面、Java后台、数据库三个层面做查询优化 | **分层优化+分页+索引，避免全表/深分页操作，缓存热点，提升整体查询效率。** | [Editorial](./场景题/有一张上百万条数据的单表，从前端页面、Java后台、数据库三个层面做查询优化.md) |
| 假设还有很多内存，有什么情况还会频繁fullgc                   | **一句话总结：即使内存很大，也可能因为碎片、大对象、元空间、频繁System.gc()等问题导致频繁Full GC。** | [Editorial](./场景题/假设还有很多内存，有什么情况还会频繁fullgc.md) |
| 压测600没问题，上线后300就扛不住了，可能是什么原因？         |                                                              | [Editorial](./场景题/压测600没问题，上线后300就扛不住了，可能是什么原因.md) |
| Redis和MySQL的一次普通查询，RT在什么范围内是合理的？         |                                                              | [Editorial](./场景题/Redis和MySQL的一次普通查询，RT在什么范围内是合理的.md) |
| 5亿条数据放到布隆过滤器中，大概需要多大内存？如何估算？      |                                                              | [Editorial](./场景题/5亿条数据放到布隆过滤器中，大概需要多大内存？如何估算.md) |
| 为了避免丢消息问题需要落表，如何设计这张消息表               |                                                              | [Editorial](./场景题/为了避免丢消息问题需要落表，如何设计这张消息表.md) |
| 有一个银行系统，对实时性要求比较高，你会怎么选择垃圾回收器   | 在实时性与吞吐之间做选择，显然我们要选择STW最小的。 **银行等高实时性系统应优先选择ZGC、Shenandoah（JDK 11/12+），或G1（JDK 7+），以最小化GC停顿时间，保证系统低延迟响应。** | [Editorial](./场景题/有一个银行系统，对实时性要求比较高，你会怎么选择垃圾回收器.md) |
| 百万级会员的用户平台，如何实现快到期的会员的消息提醒         | **百万级会员到期提醒，核心在于到期时间索引筛选+分布式异步推送+防疲劳控制+落表幂等重试+监控告警，整体流程简单高效、可扩展，完全不需要复杂的分库分表设计。** | [Editorial](./场景题/百万级会员的用户平台，如何实现快到期的会员的消息提醒.md) |
| A线程获取Redis分布式锁，但那一刻做了主从的切换，B线程能获取到锁吗？ | **Redis主从切换时，如果主从数据未及时同步，锁的唯一性就无法保证，B线程有可能拿到本不属于它的锁。** | [Editorial](./场景题/A线程获取Redis分布式锁，但那一刻做了主从的切换，B线程能获取到锁吗.md) |
| 如果设计一个缓存，需要考虑哪些方面                           | 设计缓存时需综合考虑**数据结构、并发安全、容量与淘汰、过期机制、持久化、高可用、数据一致性、性能监控**等多方面，选型和实现都需贴合实际业务需求和技术栈。 | [Editorial](./场景题/如果设计一个缓存，需要考虑哪些方面.md)  |
| 扫表任务，如何写SQL可以避免出现跳页的情况                    | **扫表任务分页时用“游标分页”而不是OFFSET/LIMIT，条件形如 id > last_max_id order by id limit N，可彻底避免跳页问题。** | [Editorial](./场景题/扫表任务，如何写SQL可以避免出现跳页的情况.md) |
| 阿里出的Java开发手册看过吗，对哪条规约印象深刻？             |                                                              | [Editorial](./场景题/阿里出的Java开发手册看过吗，对哪条规约印象深刻？.md) |
| 购物车中如何解决重复下单的问题                               |                                                              | [Editorial](./场景题/购物车中如何解决重复下单的问题.md)      |
| 让你实现一个短链服务，你会考虑哪些问题?                      |                                                              | [Editorial](./场景题/让你实现一个短链服务，你会考虑哪些问题.md) |

## 【线上问题排查】

| Problems                                                     | Hints                                                        | Solution                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 线上问题排查伪代码总览                                       | 包含Arthas排查和JVM工具排查                                  | [Editorial](./线上问题排查/线上问题排查伪代码总览.md)        |
| JVM中有哪些常见的性能监控与排查工具？各自适用哪些场景？ 【重要】 | JDK自带工具：jps、jstack、jmap、jstat、jinfo、VisualVM、JConsole  生产/复杂场景：JMC、MAT、Arthas、YourKit/JProfiler  典型用途：查线程死锁（jstack）、查内存泄漏（jmap+MAT）、实时GC监控（jstat/VisualVM）、线上低开销采集（JMC）  复习提示：**“jps找进程、jstack查线程、jmap导内存、VisualVM/JMC图形化分析”** | [Editorial](./线上问题排查/JVM中有哪些常见的性能监控与排查工具？各自适用哪些场景？.md) |
| 线程Dump（jstack）详解                                       | 线程Dump，又叫**线程快照**，是指将JVM进程中所有线程的当前运行状态、调用栈信息一次性导出。通过分析线程Dump，可以排查死锁、线程阻塞、线程数暴涨、CPU占用高等问题，是定位Java线上问题的利器。 | [Editorial](./线上问题排查/线程Dump（jstack）详解.md)        |
| jmap导出线程dump与jstack导出线程dump一样吗                   | 不完全一样                                                   | [Editorial](./线上问题排查/jmap导出线程dump与jstack导出线程dump一样吗.md) |
| 什么是JVM内存溢出（OOM）和内存泄漏？如何定位和解决？         | OOM：JVM分配内存失败，常见于堆、元空间、栈  内存泄漏：无用对象仍被引用，无法回收  排查思路：分析日志、heap dump、监控曲线、代码审查  解决方法：优化代码、合理配置参数、用工具分析  复习提示：**“OOM看异常类型，heap dump查根因，注意静态变量和大对象引用”** | [Editorial](./线上问题排查/什么是JVM内存溢出（OOM）和内存泄漏？如何定位和解决？.md) |
| 生产环境下如何监控JVM健康状态？常见监控指标有哪些？          | 关键监控：堆内存、GC（次数/耗时/停顿）、线程、类加载、Metaspace、CPU   - 工具链：JMX（JConsole/JMC）、Prometheus+Grafana、APM、ELK   - 告警：堆使用率＞80%、GC 停顿过长、线程饱和、业务指标异常   - 复习口诀：**“堆／GC／线程／Metaspace／CPU＋业务埋点，视图+告警+演练”** | [Editorial](./线上问题排查/生产环境下如何监控JVM健康状态？常见监控指标有哪些？.md) |
| JVM 中线程栈（Stack）溢出（StackOverflowError、OutOfMemoryError: unable to create new native thread）是怎么发生的？如何排查与优化？ | **线程栈溢出**：单线程栈满 = StackOverflowError；系统线程数满 = unable to create new native thread  **排查方法**：递归/线程池/线程数量  **优化手段**：递归转迭代、合理分配线程池、控制线程数  **口诀**：`“单栈爆栈是递归，线程数爆是池管，jstack定位，参数调优”` | [Editorial](./线上问题排查/JVM中线程栈（Stack）溢出（StackOverflowError、OutOfMemoryErrorunabletocreatenewnativethread）是怎么发生的？如何排查与优化？.md) |



## 【Arthas】

| Problems             | Hints                                                        | Solution                                      |
| -------------------- | ------------------------------------------------------------ | --------------------------------------------- |
| Arthas使用指南       |                                                              | [Editorial](./Arthas/Arthas.md)               |
| Arthas如何定位的问题 |                                                              | [Editorial](./Arthas/Arthas如何定位的问题.md) |
| Arthas案例分析       | 我们的电商订单服务在双十一活动期间突然出现 CPU 使用率飙升至 95%，API 响应时间从正常的 200ms 增加到 2000ms+，影响了用户下单体验。监控系统发出大量告警，但日志中没有明显错误信息。 | [Editorial](./Arthas/Arthas案例分析.md)       |



## 【中间件】

| Problems                                                     | Hints                                                        | Solution                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 中间件基础知识总结                                           | - 中间件是“系统粘合剂”，帮助各模块解耦协作、提升扩展性和可维护性。 - 常见类型：Web服务器、消息队列、缓存、数据库中间件、服务注册与发现。 - 作用关键词：解耦、复用、扩展、高可用、分布式协作。  解耦、异步、削峰 | [Editorial](./中间件/中间件基础知识总结.md)                  |
| Kafka、RabbitMQ和RocketMQ都有哪些区别，应用场景列举？        | kafka是**异步刷盘**，极端情况数据会丢失；但是rocketmq是**同步刷盘**，更安全 | [Editorial](./中间件/Kafka、RabbitMQ和RocketMQ都有哪些区别，应用场景列举.md) |
| 如何设计一个支持“限流（Rate Limiting）”功能的中间件？为什么在分布式系统中限流如此重要？ | - **限流的作用**：防止系统过载，保障服务可用性和公平性。 - **常见算法**：固定窗口、滑动窗口、令牌桶、漏桶。 - **分布式难点**：状态一致性、性能瓶颈、数据同步。 - **场景记忆法**：把限流理解为“超市排队+中央排号机”。 | [Editorial](./中间件/如何设计一个支持“限流（RateLimiting）”功能的中间件？为什么在分布式系统中限流如此重要？.md) |
| 如何实现“服务的健康检查（Health Check）”中间件？它在微服务架构中有何意义？ | - **健康检查的作用**：提升系统稳定性、自动容错与流量管理。 - **常见类型**：Liveness、Readiness、自定义业务检查。 - **微服务意义**：防止流量打到异常实例，辅助自动恢复，提升可观测性。 - **记忆法**：“航班起飞前的安全检查”——活着≠准备好了。 | [Editorial](./中间件/如何实现“服务的健康检查（HealthCheck）”中间件？它在微服务架构中有何意义？.md) |
| 在中间件中如何实现“请求追踪（Request Tracing）”？它为何是分布式系统开发的关键？ | **作用**：请求追踪帮助定位分布式系统中的性能瓶颈与故障。  **关键点**：生成唯一Trace ID，全链路传递，日志聚合。  **常见工具**：OpenTelemetry、Jaeger、Zipkin。  **场景记忆法**：快递单号追踪包裹轨迹。 | [Editorial](./中间件/在中间件中如何实现“请求追踪（RequestTracing）”？它为何是分布式系统开发的关键？.md) |

## 【Kafka】

| Problems                                                 | Hints                                                        | Solution                                                     |
| -------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Kafka实现demo                                            | 一个主题下面有一个或多个分区                                 | [Editorial](./Kafka/Kafka实现demo.md)                        |
| 为什么要使用消息队列？                                   | 目的：解耦、异步、削峰填谷 ；优点：可靠性好、扩展性好、灵活性高 |                                                              |
| Kafka 为什么这么快？                                     | Kafka 的高性能来源于顺序写磁盘、零拷贝、分区并行、批处理、简单的 Broker 设计和高效的索引结构。这些设计使 Kafka 能够支撑超高吞吐量和低延迟的消息传递，非常适合大数据和流式处理场景。 | [Editorial](./Kafka/Kafka为什么这么快.md)                    |
| Kafka的架构是怎么样的？                                  | Producer（生产者）、broker（Kafka集群）和 consumer（消费者） 组成。 | [Editorial](./Kafka/Kafka的架构是怎么样的.md)                |
| Kafka如何保证消息不丢失？                                |                                                              | [Editorial](./Kafka/Kafka如何保证消息不丢失？.md)            |
| 为什么Kafka没办法100%保证消息不丢失？                    | Kafka通过**副本机制、持久化、ACK确认**等手段大大降低了消息丢失风险，但受限于分布式系统的复杂性、硬件和人为因素，无法做到100%消息不丢失，只能最大程度保证高可靠性。在关键场景下，建议合理配置参数、监控系统状态并结合业务幂等性设计来进一步降低丢失风险。 | [Editorial](./Kafka/为什么Kafka没办法100保证消息不丢失.md)   |
| Kafka怎么保证消费只消费一次的?                           | Kafka 能通过**幂等生产者**和**事务机制**，结合**消费端处理**与 **offset 提交**的原子性，配合业务幂等设计，实现“仅消费一次”的效果；但实际应用中，通常需要保证消息处理和 offset 提交一致，或者通过业务层去重来避免重复消费。 | [Editorial](./Kafka/Kafka怎么保证消费只消费一次的.md)        |
| 什么是Kafka的重平衡机制？                                | Kafka 的重平衡机制是指在消费者组中新增或删除消费者时，Kafka 集群会重新分配主题分区给各个消费者，以保证每个消费者消费的分区数量尽可能均衡。 | [Editorial](./Kafka/什么是Kafka的重平衡机制？.md)            |
| 什么是Kafka的渐进式重平衡？                              |                                                              | [Editorial](./Kafka/什么是Kafka的渐进式重平衡.md)            |
| MQ的重平衡会带来哪些问题？                               | STW，重复消费，消息堆积                                      | [Editorial](./Kafka/MQ的重平衡会带来哪些问题.md)             |
| Kafka如何实现顺序消费？                                  |                                                              | [Editorial](./Kafka/Kafka如何实现顺序消费.md)                |
| Kafka 几种选举过程简单介绍一下？                         | Kafka 的选举过程主要包括**控制器选举**、**分区 Leader 选举**和**同步副本集（ISR）选举**：控制器选举决定哪个 Broker 负责集群管理，分区 Leader 选举确保每个分区有可靠的主副本处理读写请求，而 ISR 选举则保障分区副本的数据一致性和高可用性，这些机制共同提升了 Kafka 的稳定性和容错能力。 | [Editorial](./Kafka/Kafka几种选举过程简单介绍一下.md)        |
| Kafka 消息的发送过程简单介绍一下？                       | Kafka 消息发送过程是：生产者将消息按照主题和分区选择策略，序列化后发送到目标分区的 Leader 副本，Leader接收并顺序写入本地日志，随后根据副本同步策略将消息同步到其他副本，待达到应答条件后返回发送结果给生产者，从而完成一次消息发送。 **ISR（In-Sync Replicas，同步副本）** | [Editorial](./Kafka/Kafka消息的发送过程简单介绍一下.md)      |
| Kafka 高水位了解过吗？为什么 Kafka 需要 Leader Epoch？   | Kafka 的高水位（High Watermark）用于标记分区中**所有副本都已同步的最新消息位置**，保障消息**不丢失**和**数据一致性**；而 Leader Epoch 是用来**区分不同 Leader 任期**，**防止分区 Leader 切换时因旧 Leader 产生的数据写入丢失或混乱，从而确保数据可靠性和正确的消息顺序**。 | [Editorial](./Kafka/Kafka高水位了解过吗？为什么Kafka需要LeaderEpoch.md) |
| Kafka 为什么有 Topic 还要用 Partition?                   | Topic是逻辑上的消息分类，而Partition是物理上的消息分区。通过将Topic分成多个Partition，可以实现**提升吞吐量、负载均衡、以及增加可扩展性。** | [Editorial](./Kafka/Kafka为什么有Topic还要用Partition.md)    |
| 介绍一下Kafka的ISR机制？                                 | ISR，是`In-Sync Replicas`，**同步副本**的意思。  在Kafka中，每个主题分区可以有多个副本(replica)。ISR是与主副本（Leader Replica）保持同步的副本集合。ISR机制就是用于**确保数据的可靠性和一致性的**。  当消息被写入Kafka的分区时，它首先会被写入Leader，然后Leader将消息复制给ISR中的所有副本。只有当ISR中的所有副本都成功地接收到并确认了消息后，主副本才会认为消息已成功提交。这种机制确保了数据的可靠性和一致性。 |                                                              |
| Kafka支持事务消息吗？如何实现的？                        |                                                              | [Editorial](./Kafka/Kafka支持事务消息吗？如何实现的.md)      |
| Kafka为什么依赖Zookeeper，有什么用？为什么后面又不用了？ | Kafka最初依赖Zookeeper，是因为需要分布式协调、元数据管理和容错能力，Zookeeper能很好地满足这些需求。随着技术发展，Kafka通过KRaft模式自研了分布式协调和元数据管理能力，所以后续版本可以不再依赖Zookeeper。 | [Editorial](./Kafka/Kafka为什么依赖Zookeeper，有什么用？为什么后面又不用了？.md) |
| Kafka的消费者数量和分区数量可以不同吗？会发生什么？      | Kafka中消费者数与分区数可以不一样。**通常推荐消费者数不超过分区数**，这样每个消费者都会有分区可消费，否则多余的消费者会闲置无法分配分区。而从Kafka 4.0开始引入了共享组机制，允许多个消费者并行消费同一个分区并逐条确认消息，从而显著提升吞吐和消费灵活性，解决了消费者大于分区数时的闲置问题。 | [Editorial](./Kafka/Kafka的消费者数量和分区数量可以不同吗？会发生什么.md) |
| Kafka如何实现批量消费                                    | Kafka批量消费常通过`@KafkaListener`结合自定义的`ConcurrentKafkaListenerContainerFactory`实现，关键是设置`factory.setBatchListener(true)`**开启批量监听**，**并将ack模式配置为手动提交（MANUAL_IMMEDIATE）**，避免自动提交带来的消息丢失风险。监听方法中应在确保所有消息都处理成功后再手动提交offset，切忌在finally或未全部处理成功时提交，以保证消息可靠性和不丢失。 | [Editorial](./Kafka/Kafka如何实现批量消费.md)                |
| Kafka的批量消费如何确保消息不丢？                        | 在Kafka批量消费场景下，最容易丢消息的原因是**自动提交offset**和**在finally中手动提交offset**导致未成功处理的消息被标记为已消费。为避免丢消息，应使用手动提交，并确保所有消息处理成功后再提交offset。如果有失败则不提交offset，让消息重投，通过消费端的幂等性设计保证消息重复处理不会造成问题。这样可以有效防止消息丢失，即使带来消息重复，也比丢消息更安全可靠。 | [Editorial](./Kafka/Kafka的批量消费如何确保消息不丢？.md)    |
| Kafka如果丢消息了，可能的原因是什么？                    | Kafka消息丢失主要有三类场景：一是**生产者端**未开启消息确认或未处理发送失败，导致消息在网络或Broker故障时丢失；二是**Broker端**由于未持久化或主从同步不及时，或仅有单节点部署，Broker宕机时消息会丢失；三是**消费者端**如果在消息未成功处理就自动提交offset，也会导致消息丢失。此外，如果消息长时间未被消费，超过保存时间也会被删除。实际生产环境中，建议通过合理配置acks、主从同步、异常回调及offset手动提交等方式，最大限度降低消息丢失风险。 | [Editorial](./Kafka/Kafka如果丢消息了，可能的原因是什么.md)  |
| 介绍一下Kafka的死信队列                                  | 死信队列（Dead Letter Queue，DLQ）是消息中间件中的一种**错误处理机制**，用于处理无法被正常消费的消息。当消息因为各种原因（如**反序列化失败**、**业务处理异常**、**超过重试次数**等）无法被正常处理时，这些消息会被转发到死信队列，以便后续分析和处理。 【Kafka没有内置的死信队列】 | [Editorial](./Kafka/介绍一下Kafka的死信队列.md)              |
| kafka集群                                                | 业务代码和单机的业务代码一模一样，但是配置文件要修改         | [Editorial](./Kafka/kafka集群.md)                            |

## 【定时任务】

| Problems                                              | Hints                                                        | Solution                                                     |
| ----------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| xxl-job入门案例                                       |                                                              | [Editorial](./定时任务/xxljob入门案例.md)                    |
| cron表达式详解                                        |                                                              | [Editorial](./定时任务/cron表达式详解.md)                    |
| xxl-job如何保证一任务只会触发一次？                   | xxl-job通过**分布式调度**和**任务锁机制**来保证任务只会触发一次。调度中心会为每个任务分配唯一的执行器，并采用数据库或分布式锁进行任务状态管理，确保同一时间只有一个执行器能够获取到执行权，避免任务重复触发。同时，任务触发和回调都有幂等设计，进一步保证任务只会被执行一次。 | [Editorial](./定时任务/xxl-job如何保证一任务只会触发一次.md) |
| xxl-job 支持分片任务吗？实现原理是什么？              | xxl-job支持分片任务，通过**“分片广播”**调度策略实现。调度中心在触发任务时会将任务拆分为多个分片并分配到不同的执行器，每个分片携带分片参数，执行器根据分片参数只处理自己负责的数据部分，这样可以实现任务的并行处理和负载均衡，提高执行效率。 | [Editoiral](./定时任务/xxl-job支持分片任务的原理.md)         |
| 为什么定时任务可以定时执行？                          | 操作系统提供的定时器                                         | [Editorial](./定时任务/为什么定时任务可以定时执行.md)        |
| Java中实现定时任务的几种方式                          | Timer类和TimerTask类、 ScheduledExecutorService类、 DelayQueue | [Editorial](./定时任务/Java中实现定时任务的几种方式.md)      |
| Java中Timer实现定时调度的原理是什么                   | `TaskQueue` 、`TimerThread`                                  | [Editorial](./定时任务/Java中Timer实现定时调度的原理是什么.md) |
| 介绍一下ScheduledExecutorService                      |                                                              | [Editorial](./定时任务/介绍一下ScheduledExecutorService.md)  |
| 什么是时间轮？                                        | 时间轮算法是一种高效的定时任务调度机制，通过将时间划分为固定槽位并以轮盘方式轮询，实现任务的延迟执行和周期触发。通过引入**round标识**和**分层时间轮**，可以灵活支持更长时间的延迟任务并提升调度效率。分层时间轮将任务分级管理，细粒度时间轮负责精确触发，粗粒度时间轮负责长周期管理，广泛应用于高性能框架如Netty、Kafka等，用于超时检测、消息过期清理等场景。 | [Ediotiral](./定时任务/什么是时间轮.md)                      |
| 实现一个定时任务，可以用什么数据结构及算法？          | 小顶堆、时间轮算法、链表（使用较少）                         | [Editorail](./定时任务/实现一个定时任务可以用什么数据结构及算法.md) |
| 知道MapReduce动态分片任务吗？好处是什么？原理是什么？ |                                                              | [Editorial](./定时任务/MapReduce动态分片任务.md)             |



## 【设计模式】

| Problems                         | Hints                                                        | Solution                                                    |
| -------------------------------- | ------------------------------------------------------------ | ----------------------------------------------------------- |
| 设计模式总结                     |                                                              | [Editorial](./设计模式/设计模式总结.md)                     |
| 设计模式七大原则                 | 单一职责、开闭、里氏替换、依赖倒置、接口隔离、迪米特、合成/聚合复用原则 | [Editorial](./设计模式/设计模式七大原则.md)                 |
| 讲一下工厂模式                   | **简单工厂**是由一个工厂类根据参数决定实例化哪种产品，适合产品种类少、变化不大的场景；                                         **工厂方法**是将创建产品的职责交给子类，每个具体工厂生产一种具体产品，利于扩展；（一个产品）                                   **抽象工厂**则能创建一族相关产品，保证产品之间的一致性，适用于产品族多且需要统一风格的场合。 （多个产品） |                                                             |
| 工厂方法模式与抽象工厂模式的区别 | **工厂方法模式**只负责生产一种产品，由具体子类决定产品的创建细节；而**抽象工厂模式**可以生产多个相关产品族，通过不同的实现类创建一组相互关联的产品。简单来说，工厂方法模式关注“单一产品的创建”，而抽象工厂模式关注“产品族的整体创建和约束”。  **单一产品的不同品牌，整套产品的不同风格** | [Editorial](./设计模式/工厂方法模式与抽象工厂模式的区别.md) |
| 你在工作中是如何使用设计模式的   |                                                              | [Editorial](./设计模式/你在工作中是如何使用设计模式的.md)   |
| 单例模式的创建                   |                                                              | [Editorial](./设计模式/单例模式的创建.md)                   |

## 【EasyExcel】

| Problems                                   | Hints | Solution                                                     |
| ------------------------------------------ | ----- | ------------------------------------------------------------ |
| EasyExcel的基础使用                        |       | [Editorial](./EasyExcel/EasyExcel的基础使用.md)              |
| 针对EasyExcel表的导入，如何对数据进行校验? |       | [Editorial](./EasyExcel/针对EasyExcel表的导入，如何对数据进行校验.md) |
| 讲一讲EasyExcel的源码                      |       | [Editorial](./EasyExcel/讲一讲EasyExcel的源码.md)            |
| 如何使用EasyExcel实现动态表头和合并单元格  |       | [Editorial](./EasyExcel/如何使用EasyExcel实现动态表头和合并单元格.md) |
| EasyExcel实现百万级数据从Excel导入到数据库 |       | [Editorial](./EasyExcel/EasyExcel实现百万级数据从Excel导入到数据库？.md) |
| EasyExcel实现百万级数据导出                |       | [Editorial](./EasyExcel/EasyExcel实现百万级数据导出.md)      |



## 【Netty】

| Problems                           | Hints                                                        | Solution                                                   |
| ---------------------------------- | ------------------------------------------------------------ | ---------------------------------------------------------- |
| Netty常见API                       |                                                              | [Editorial](./Netty/Netty常见API.md)                       |
| Netty的工作流程                    |                                                              | [Editorial](./Netty/Netty的工作流程.md)                    |
| 为什么Netty适合做网络编程          | **Netty**适合做网络编程，主要因为它具备**高性能、强扩展性和易用性**。它采用**异步事件驱动模型**，能高效处理大量并发连接，极大提升服务器性能；同时对底层网络通信进行了高度封装，开发者只需关注业务逻辑，简化了开发流程。此外，Netty支持多种协议和自定义编解码，能够灵活应对各种复杂网络应用场景，因此被广泛用于**高性能服务器和分布式系统**开发。 | [Editorial](./Netty/为什么Netty适合做网络编程.md)          |
| Netty性能好的原因是什么？          | 首先，它采用了**异步非阻塞IO模型**，能够高效处理大量并发连接，极大提升服务器的吞吐量；其次，**高效的内存管理**（如内存池和零拷贝技术）减少了数据复制和资源消耗；再次，**灵活的线程模型**允许根据业务需求优化并发处理能力；此外，**高性能的编解码框架**和**连接管理机制**进一步降低了系统开销。**这些优势让Netty在高并发、高性能网络场景下表现极为出色。** | [Editorial](./Netty/Netty性能好的原因是什么.md)            |
| Netty的零拷贝是怎么实现的          | **Netty的零拷贝主要通过Direct Buffer、FileRegion和sendfile机制实现。**  它使用**Direct Buffer**将数据直接分配在物理内存中，避免了JVM堆与操作系统内核之间的数据复制；通过**FileRegion**对象结合底层的sendfile系统调用，能够直接将文件内容从磁盘传输到网络通道，减少了用户态与内核态的数据拷贝次数。**这样有效提升了数据传输效率，降低了系统资源消耗。** | [Editorial](./Netty/Netty的零拷贝是怎么实现的.md)          |
| 能不能说一说Netty的无锁化设计？    | **Netty的无锁化设计主要体现在其高效的线程模型和事件驱动架构。** 它通过**多线程分工**（如Boss和Worker线程分离）、**线程绑定Channel**和**任务队列化处理**，最大限度地避免了多个线程同时竞争共享资源，减少了锁的使用和上下文切换开销。**这种无锁化或少锁化的设计极大提升了并发性能和系统吞吐量，使Netty能够高效支撑高并发场景。** | [Editorial](./Netty/能不能说一说Netty的无锁化设计.md)      |
| Netty的线程模型是怎么样的          | **Netty的线程模型采用Boss和Worker线程分离的设计。** 其中，**Boss线程负责监听和接收客户端连接请求**，而**Worker线程则专注于处理已建立连接的IO读写操作**。这种分工方式有效避免了资源竞争，提高了系统的并发处理能力。此外，Netty还支持自定义线程池和多种线程模型（如单线程和多线程模式），能够灵活适配不同业务场景，实现高效的网络通信。 | [Editorial](./Netty/Netty的线程模型是怎么样的.md)          |
| Netty如何解决TCP粘包、拆包的问题的 | Netty 通过在 `ChannelPipeline` 中引入各种解码器来自动处理 TCP 的粘包和拆包问题，这些解码器能够根据特定规则（如换行符、分隔符、长度字段等）将收到的字节流切割成完整的消息，确保上层业务 handler 处理的始终是完整的数据包，从而彻底解决了 TCP 粘包和拆包带来的困扰。 | [Editorial](./Netty/Netty如何解决TCP粘包、拆包的问题的.md) |
| Netty的Buffer为什么好用            | 在网络编程中底层操作几乎都是对**字节流**的操作，虽然Java NIO提供了ByteBuffer，但其易用性和灵活性有限。netty在ByteBuffer的基础上实现了更强大和更友好的ByteBuf；优势：1、**动态扩容**，支持自动扩容与缩容，像使用 ArrayList 一样无忧添加数据。2、**原生 ByteBuffer 需要手动 flip 切换读写模式**，容易出错。ByteBuf 采用读写双指针，读写互不干扰，无需 flip，极大简化操作。3、读完一部分数据后，**可以回收已读空间**，提升缓冲区利用率。4、**提供多种实现类型**，适配不同的场景； | [Editorial](./Netty/Netty的Buffer为什么好用.md)            |
| 说说 Netty 的对象池技术            | **Netty的对象池技术主要用于提升内存管理效率和系统性能。** 它通过复用如缓冲区（ByteBuf）、Channel等频繁创建和销毁的对象，**减少了对象的垃圾回收压力和内存分配开销**。Netty内部实现了高效的对象池机制，比如**PooledByteBuf**，可以实现对象的快速分配与释放，显著提升数据处理能力。**这种对象池设计让Netty在高并发、高性能场景下表现更加稳定和高效。** | [Editorial](./Netty/说说Netty的对象池技术.md)              |
| Netty有哪些序列化协议              | **Netty支持多种序列化协议，常见的有Java原生序列化、JSON、XML、Protobuf、Hessian、Thrift、MsgPack等。** 开发者可以根据业务需求灵活选择或自定义编解码器，实现不同协议的数据序列化和反序列化。**这些丰富的序列化协议支持，使Netty能够适配各种分布式和高性能网络应用场景。** | [Editorial](./Netty/Netty有哪些序列化协议.md)              |
| Netty中用了哪些设计模式            | Netty 中广泛应用了多种经典设计模式，包括**单例模式**（如全局唯一的策略实例）、**工厂模式**（如各种 Factory 用于对象创建）、**责任链模式**（ChannelPipeline 实现链式处理）、**观察者模式**（ChannelFuture 的异步回调监听）、**策略模式**（如 EventExecutorChooser、SelectStrategy 的动态算法选择）、**装饰者模式**（如 WrappedByteBuf 增强功能）等。通过灵活运用这些设计模式，Netty 实现了高性能、高扩展性和高可维护性的网络通信框架架构，大大提升了开发效率和代码质量。 | [Editorial](./Netty/Netty中用了哪些设计模式.md)            |

## 【Mqtt】

| Problems       | Hints                                  | Solution                              |
| -------------- | -------------------------------------- | ------------------------------------- |
| Mqtt面试题总览 | MQTT 默认的 QoS 等级是 0（最多一次）。 | [Editorial](./Mqtt/Mqtt面试题总览.md) |
| Mqtt入门案例   |                                        | [Editorial](./Mqtt/Mqtt入门案例.md)   |
| Mqtt报文结构   |                                        | [Editorial](./Mqtt/Mqtt报文结构.md)   |

## 【分布式】

| Problems                                       | Hints                                                        | Solution                                                     |
| ---------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 什么是分布式系统？和集群的区别？               | **分布式**是指在多台不同的服务器中部署**不同**的服务模块，通过远程调用协同工作，对外提供服务。        **集群**是指在多台不同的服务器中部署**相同应用或服务模块**，构成一个集群，通过负载均衡设备对外提供服务。 |                                                              |
| 什么是分布式系统的一致性？                     | **分布式系统的一致性指的是多个节点在面对数据更新或请求时，能够保证对外表现为一个整体，所有节点的数据状态保持一致，用户无论访问哪个节点都能获得相同的结果**。常见一致性模型有强一致性、弱一致性和最终一致性，其中**最终一致性最常用于分布式架构**，强调系统在一段时间后各节点状态趋于一致，是高可用分布式系统的重要特性和设计难点。 | [Editorial](./分布式/什么是分布式系统的一致性.md)            |
| 什么是分布式BASE理论？                         | 分布式BASE理论是一种应对分布式系统中一致性与可用性权衡的设计理念，其核心是“基本可用”（Basically Available）、“软状态”（Soft State）和“最终一致性”（Eventually Consistent）。与强一致性相比，BASE理论允许部分系统在短时间内出现不一致，但保证系统整体高可用，最终状态趋于一致，常用于高并发、大规模分布式应用，是CAP理论一致性与可用性权衡的实际工程化方案。 |                                                              |
| 什么是拜占庭将军问题                           | 拜占庭将军问题是分布式系统中的经典**一致性难题**，描述的是多个分布式节点在存在恶意或故障节点情况下，如何通过信息传递在不可靠网络中达成一致决策。它强调即使部分节点故障或故意发送错误信息，系统整体仍能保证一致性，是区块链、分布式数据库等高容错系统设计的重要理论基础。 |                                                              |
| 分布式锁有几种实现方式？                       | 其中数据库的实现可以依赖悲观锁以及数据库表记录来实现，通过Redis的实现可以考虑使用setnx、redission以及redlock实现。使用 Zookeeper 主要是依赖他提供的临时有序节点来实现。 |                                                              |
| 什么是柔性事务？                               | 柔性事务（也叫**最终一致性事务**或**分布式事务的柔性方案**）是分布式系统中为提升可用性和性能，而对传统强一致性事务进行“放宽”处理的一种事务方案。它不追求操作过程中的强一致性（如传统的ACID事务），而是允许各参与节点在一定时间内状态不一致，但最终会达到一致的结果。柔性事务常用补偿、重试、确认等机制实现，比如常见的TCC（Try-Confirm-Cancel）、消息队列事务、Saga模式等，广泛应用于微服务和高并发场景下的分布式系统设计。 |                                                              |
| 如何基于MQ实现分布式事务                       | 基于MQ实现分布式事务，通常通过事务消息、补偿机制、TCC或Saga模式等方案，核心是利用消息队列的可靠投递和异步解耦，确保各服务间的数据最终一致性但不追求强一致性。 | [Editorial](./分布式/如何基于MQ实现分布式事务.md)            |
| 如何基于本地消息表实现分布式事务？             | 本地消息表方案通过将业务操作和消息写入本地事务中，结合异步投递和幂等机制，实现各服务间的数据最终一致性，是分布式事务中常用且简单可靠的解决方案。 | [Editorial](./分布式/如何基于本地消息表实现分布式事.md)      |
| 什么是最大努力通知？                           | 最大努力通知（Best Effort Notification）是一种分布式系统中的**消息通知策略**，指的是通知方在完成本地操作后，尽最大努力将消息发送给对方，但不保证消息一定能被对方收到或处理成功。通常会采用**重试机制**，但如果多次发送仍失败，系统不会强制保证通知结果，只是尽力而为。因此最大努力通知适用于对一致性要求不高、允许部分消息丢失的场景，可以提升系统的可用性和性能。 |                                                              |
| 最大努力通知&事务消息&本地消息表三者区别是什么 | 最大努力通知只保证尽力发送，不保证一致性；事务消息通过MQ的机制实现业务和消息的强一致性；本地消息表用本地事务和异步投递方式实现最终一致性，适合没有事务消息支持的MQ场景。 | [Editorial](./分布式/最大努力通知&事务消息&本地消息表三者区别是什么.md) |
| 分布式ID生成方案都有哪些？                     | 分布式ID生成方案主要有数据库自增、UUID、雪花算法、号段模式、Redis自增等，实际选择应根据业务需求、性能、可扩展性和唯一性等因素综合考虑。 | [Editorial](./分布式/分布式ID生成方案都有哪些.md)            |
| 什么是雪花算法，怎么保证不重复的？             |                                                              | [Editorial](./分布式/什么是雪花算法，怎么保证不重复的.md)    |
| 什么是负载均衡，有哪些常见算法？               | 负载均衡是指在多台服务器或节点之间合理分配用户请求或数据流量，从而提升系统的处理能力、可靠性和可用性。它能**防止某一节点过载，保证整体服务的稳定和高效**。常见的负载均衡算法有**轮询**（Round Robin）、**加权轮询**（Weighted Round Robin）、**最少连接**（Least Connections）、**源地址哈希**（IP Hash）、**随机算法**（Random）、**一致性哈希**等，不同算法适用于不同业务场景和流量分布需求。 |                                                              |
| 如何解决接口幂等的问题？                       | **一锁**：第一步，先加锁。可以加分布式锁、或者悲观锁都可以。但是一定要是一个互斥锁！**二判**：第二步，进行幂等性判断。可以基于状态机、流水表、唯一性索引等等进行重复操作的判断。**三更新**：第三步，进行数据的更新，将数据进行持久化。 |                                                              |
| 实现一个分布式锁需要考虑哪些问题？             |                                                              | [Editorial](./分布式/实现一个分布式锁需要考虑哪些问题.md)    |
| 定时任务扫表的缺点有什么？                     | 定时任务扫表的主要缺点是**存在延迟**和**资源浪费**：由于依赖周期性扫描，消息处理不是实时的，可能导致业务延迟；频繁扫描还会造成数据库压力和性能下降，尤其在消息量大或表数据积累较多时，影响系统稳定性。此外，异常情况下可能出现消息遗漏或重复投递，需额外设计幂等和补偿机制。 | [Editorial](./分布式/定时任务扫表的缺点.md)                  |
| 锁和分布式锁的核心区别是什么？                 | 锁是单机范围的并发控制手段，而分布式锁用于多个服务器或节点之间的资源互斥，通常依赖外部存储实现。 |                                                              |



## 【微服务】

| Problems                          | Hints                                                        | Solution                                            |
| --------------------------------- | ------------------------------------------------------------ | --------------------------------------------------- |
| 分布式和微服务的区别是什么？      | 微服务是分布式的一种，微服务就是分布式                       | [Editorial](./微服务/分布式和微服务的区别是什么.md) |
| SOA和微服务之间的主要区别是什么？ | SOA【面向服务架构】强调企业级集成和标准化，服务粒度较大；微服务强调高内聚、自治和去中心化，服务粒度更细，适合敏捷开发和云原生架构。 |                                                     |
| 介绍一下限流、降级、熔断          | **限流**用于控制流量，保护系统资源；**降级**是在系统压力或故障时关闭部分功能，保证核心业务；**熔断**是在下游服务异常时切断调用，防止故障蔓延和系统雪崩。三者共同提升系统的稳定性和高可用性。 | [Editorial](./微服务/介绍一下限流、降级、熔断.md)   |



## 【其他】

| Problems                                                     | Hints                                                        | Solution                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url | `分治 + hashmap `                                            | [Editorial](./其他/查找相同url.md)                           |
| 介绍一下cap理论                                              | CAP 原则又称 CAP 定理, 指的是在一个分布式系统中, Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性）, **三者不可得兼** | [Editorial](./其他/介绍一下cap理论.md)                       |
| 怎么才能在一个Java项目里面实现引入，怎么实现配置，引入的依赖为什么会生效 | 通过maven引入，在pom.xml这个配置文件里面添加需要的依赖，<dependencies>这个标签下面添加，默认使用中央仓库下载依赖，如果需要使用私有厂库，可以修改<repositories>下面的仓库url。当我们构建项目时，如`mvn compile`或`mvn package`的时候，会自动从厂库里面下载依赖到本地。 | [Editorial](./其他/怎么才能在一个Java项目里面实现引入，怎么实现配置，引入的依赖为什么会生效.md) |

## 【SQL题目】

| Problems                                                     | Hints                                                        | Repeat |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------ |
| [175. 组合两个表](https://leetcode.cn/problems/combine-two-tables/) | 使用`left join`连接两个表，但是后面的条件查询不能用`where`，必须用`on` |        |
| [181. 超过经理收入的员工](https://leetcode.cn/problems/employees-earning-more-than-their-managers/) | 一张表可以拆分成两张表使用                                   |        |
| [182. 查找重复的电子邮箱](https://leetcode.cn/problems/duplicate-emails/) | 学习`group by`与`having`组合                                 |        |
| [183. 从不订购的客户](https://leetcode.cn/problems/customers-who-never-order/) | 三种写法，`not exists` 、`not in` 、`left join`              | Yes    |
| [196. 删除重复的电子邮箱](https://leetcode.cn/problems/delete-duplicate-emails/) |                                                              | Yes    |
| [197. 上升的温度](https://leetcode.cn/problems/rising-temperature/) | 日期类，前面日期 - 后面日期的天数 `datediff(w1.recordDate, w2.recordDate) = 1` | Yes    |
| [511. 游戏玩法分析 I](https://leetcode.cn/problems/game-play-analysis-i/) | `group by`按照一个标准聚合，然后在select的后面可以使用`min(), ave(), max(), sum()` |        |
| [577. 员工奖金](https://leetcode.cn/problems/employee-bonus/) | sql语句的判空为`is null`                                     |        |
| [584. 寻找用户推荐人](https://leetcode.cn/problems/find-customer-referee/) |                                                              |        |
| [607. 销售员](https://leetcode.cn/problems/sales-person/)    |                                                              |        |
| [610. 判断三角形](https://leetcode.cn/problems/triangle-judgement/) | `select x, y, z ,  case when x+y>z and x+z>y and y+z>x then 'Yes' else 'No' end as 'triangle'  from triangle` 新增一个字段的语法 | Yes    |
| [619. 只出现一次的最大数字](https://leetcode.cn/problems/biggest-single-number/) |                                                              | Yes    |
| [626. 换座位](https://leetcode.cn/problems/exchange-seats/)  |                                                              | Yes    |
| [627. 变更性别](https://leetcode.cn/problems/swap-salary/)   |                                                              | Yes    |
| [1045. 买下所有产品的客户](https://leetcode.cn/problems/customers-who-bought-all-products/) |                                                              | Yes    |
| [1050. 合作过至少三次的演员和导演](https://leetcode.cn/problems/actors-and-directors-who-cooperated-at-least-three-times/) |                                                              | Yes    |
| [1070. 产品销售分析 III](https://leetcode.cn/problems/product-sales-analysis-iii/) |                                                              | Yes    |
|                                                              |                                                              |        |
|                                                              |                                                              |        |
|                                                              |                                                              |        |
|                                                              |                                                              |        |
|                                                              |                                                              |        |
|                                                              |                                                              |        |
|                                                              |                                                              |        |
|                                                              |                                                              |        |
|                                                              |                                                              |        |
|                                                              |                                                              |        |
|                                                              |                                                              |        |
|                                                              |                                                              |        |
|                                                              |                                                              |        |
|                                                              |                                                              |        |
|                                                              |                                                              |        |
|                                                              |                                                              |        |
|                                                              |                                                              |        |
|                                                              |                                                              |        |
|                                                              |                                                              |        |
|                                                              |                                                              |        |
|                                                              |                                                              |        |
|                                                              |                                                              |        |

