# ☕ Java面试基础知识笔记

---

## 1️⃣ Java的面向对象特性

- **封装（Encapsulation）**  
  属性和实现细节隐藏，只暴露必要接口，保证数据安全。
- **继承（Inheritance）**  
  子类自动继承父类属性和方法，实现代码复用。
- **多态（Polymorphism）**  
  同一方法在不同对象上有不同表现，父类引用指向子类对象。
- **抽象（Abstraction）**  
  通过抽象类或接口，仅暴露功能定义，屏蔽具体实现。

---

## 2️⃣ final关键字的作用

- **修饰变量**：只能赋值一次，值不可变。

- **修饰方法**：方法不能被子类重写。

- **修饰类**：类不能被继承。

- 在 Java 中，**final** 关键字不能用于修饰接口。

  ### 原因说明

  - **final** 关键字的含义是“最终的，不能被继承或重写”。
  - 接口的设计目的是用来被类实现（implement）的，接口本身就是为继承和实现而存在的。
  - 如果允许接口被 final 修饰，则意味着该接口不能被实现，违背了接口存在的意义。

  ### 编译器报错示例

  ```java
  final interface MyInterface {   // 编译错误
      void doSomething();
  }
  ```
  会报错：`modifier 'final' not allowed here`

  ### 结论

  - **接口不能被 final 修饰。**
  - 只能用 final 修饰类、方法和变量（常量）。

  #### 相关拓展

  - 可以用 `final` 修饰接口中的变量（默认为 public static final）。
  - 接口中的方法默认是 `public abstract`，不允许加 `final`。

  如有更多 Java 关键字相关问题欢迎继续提问！

---

## 3️⃣ 重载（Overload） vs 重写（Override）

- **重载（Overload）**  
  - 同一类中，方法名相同，参数列表不同（数量或类型不同）。
  - 返回值可以不同，但不能仅靠返回值区分。
- **重写（Override）**  
  - 父子类之间，方法名和参数列表必须相同。
  - 返回值类型可以是父类返回类型的子类型。
  - 用于运行时多态。

---

## 4️⃣ Java异常体系

- **Error**  
  严重问题，如内存溢出，通常无法恢复处理。
- **Exception**  
  可捕获和处理的异常。
  - **受检异常（Checked Exception）**：必须捕获或声明抛出，如 `IOException`。
  - **非受检异常（Unchecked Exception）**：不强制处理，运行时错误，如 `NullPointerException`。

---

## 5️⃣ HashMap原理

- **JDK1.7及以前**：数组 + 链表
- **JDK1.8及以后**：数组 + 链表/红黑树
- **put操作**：计算哈希，定位桶，冲突时链表/树遍历，替换或插入新节点。
  - 1.7头插法，1.8尾插法
  - 链表长度≥8且数组长度≥64转红黑树
- **get操作**：根据哈希值查找，找到返回value，未找到返回null。
- **哈希冲突**：通过链表或红黑树解决
- **扩容机制**：超过阈值自动扩容，重新分布数据

---

## 6️⃣ 线程安全问题及解决方案

- **线程安全问题**  
  多线程同时访问共享数据，导致数据不一致、竞态条件、可见性问题。
- **常见解决办法**
  - **synchronized**：加锁，保证原子性和可见性
  - **Lock接口**：如 `ReentrantLock`，更灵活
  - **原子类**：如 `AtomicInteger`
  - **volatile**：保证可见性

---

## 7️⃣ synchronized关键字

- **作用**：实现线程同步，保证同一时间只有一个线程访问共享资源。
- **用法**
  - 修饰实例方法：锁定当前对象
  - 修饰静态方法：锁定Class对象
  - 修饰代码块：显示指定锁对象
- **底层原理**：依赖JVM的对象监视器（Monitor），支持偏向锁、轻量级锁、重量级锁等优化。

---

## 8️⃣ volatile关键字 及 与 synchronized 的区别

- **volatile**  
  - 只保证变量的**可见性**，不保证原子性
  - 通过内存屏障实现，性能高，不加锁
  - 适合状态标记、简单变量
- **synchronized**
  - 保证**可见性+原子性+互斥性**
  - 存在锁竞争，性能开销较大
  - 适合复杂的临界区操作

---

## 9️⃣ volatile和synchronized为什么都要有

- **synchronized**功能更强大，但**性能开销大**
- **volatile**仅保证可见性，**性能更高**
- 能用`volatile`就不用`synchronized`，只有需要原子性时才用`synchronized`
- 各自适用**不同场景**，选择更合适的实现可以获得更好的性能和安全性

---

> 🌟 **面试Tips**：  
> - 答题关键字要突出，结构清晰，结合实际场景举例，能加分！  
> - 记得结合实际项目经验，简明扼要表达你的理解！

---