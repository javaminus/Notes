# 设计模式总结（面试向）

本总结文档覆盖了23种经典设计模式。每种模式包括：基本解释、中文场景举例、Java代码实现，并对优缺点进行简要总结。最后对所有设计模式进行了对比分析，帮助面试复习和理解。

------

## 1. 单例模式（Singleton）

**定义**  
确保一个类只有一个实例，并提供一个全局访问点。

**场景举例**  
比如在一个应用中，全局只需要一个日志管理器对象来收集和输出日志，防止重复创建多个实例。

**Java 示例**

```java
// 日志管理器单例
public class LogManager {
    private static final LogManager instance = new LogManager();
    private LogManager() {}
    public static LogManager getInstance() {
        return instance;
    }
    public void log(String message) {
        System.out.println("Log: " + message);
    }
}
// 使用
LogManager.getInstance().log("系统启动");
```

**总结**

- 优点：节省资源，统一管理。
- 缺点：并发下实现复杂，扩展性差。
- 适用场景：配置信息、线程池、日志对象等。

------

## 2. 工厂方法模式（Factory Method）

**定义**  
定义一个创建对象的接口，让子类决定实例化哪一个类。

**场景举例**  
在一个快递系统中，不同的快递公司（如顺丰、圆通）有不同的快递单对象，通过工厂方法决定创建哪种快递单。

**Java 示例**

```java
// 快递单接口和两种快递单
interface ExpressOrder { void printOrder(); }
class SFOrder implements ExpressOrder {
    public void printOrder() { System.out.println("顺丰快递单"); }
}
class YTOOrder implements ExpressOrder {
    public void printOrder() { System.out.println("圆通快递单"); }
}

// 工厂接口和实现
interface OrderFactory {
    ExpressOrder createOrder();
}
class SFFactory implements OrderFactory {
    public ExpressOrder createOrder() { return new SFOrder(); }
}
class YTOFactory implements OrderFactory {
    public ExpressOrder createOrder() { return new YTOOrder(); }
}
// 使用
OrderFactory factory = new SFFactory();
factory.createOrder().printOrder(); // 输出：顺丰快递单
```

**总结**

- 优点：扩展性好，新增产品容易。
- 缺点：类数量增多，结构复杂。
- 适用场景：需要多种产品时。

------

## 3. 抽象工厂模式（Abstract Factory）

**定义**  
提供一个创建一系列相关或相互依赖对象的接口。

**场景举例**  
比如桌面软件需要支持Windows和Mac系统，每个平台下有不同风格的按钮和文本框。

**Java 示例**

```java
// 按钮和文本框接口
interface Button { void paint(); }
interface TextField { void draw(); }

// Windows风格
class WinButton implements Button { public void paint() { System.out.println("Win按钮"); } }
class WinTextField implements TextField { public void draw() { System.out.println("Win文本框"); } }
// Mac风格
class MacButton implements Button { public void paint() { System.out.println("Mac按钮"); } }
class MacTextField implements TextField { public void draw() { System.out.println("Mac文本框"); } }

// 抽象工厂及实现
interface GUIFactory {
    Button createButton();
    TextField createTextField();
}
class WinFactory implements GUIFactory {
    public Button createButton() { return new WinButton(); }
    public TextField createTextField() { return new WinTextField(); }
}
class MacFactory implements GUIFactory {
    public Button createButton() { return new MacButton(); }
    public TextField createTextField() { return new MacTextField(); }
}
// 使用
GUIFactory factory = new MacFactory();
factory.createButton().paint(); // 输出：Mac按钮
factory.createTextField().draw(); // 输出：Mac文本框
```

**总结**

- 优点：产品族一致性，易于扩展。
- 缺点：新增产品族困难。
- 适用场景：多个产品族时。

------

## 4. 建造者模式（Builder）

**定义**  
将一个复杂对象的构建与其表示分离，使同样的构建过程可以创建不同的表示。

**场景举例**  
比如制作一份套餐，包括主食、饮料和甜点，可以根据客户需求灵活组合。

**Java 示例**

```java
// 套餐对象
class Meal {
    private String main;
    private String drink;
    private String dessert;
    public void setMain(String main) { this.main = main; }
    public void setDrink(String drink) { this.drink = drink; }
    public void setDessert(String dessert) { this.dessert = dessert; }
    public String toString() {
        return "主食: " + main + ", 饮料: " + drink + ", 甜点: " + dessert;
    }
}
// 套餐建造者
class MealBuilder {
    private Meal meal = new Meal();
    public MealBuilder buildMain(String main) { meal.setMain(main); return this; }
    public MealBuilder buildDrink(String drink) { meal.setDrink(drink); return this; }
    public MealBuilder buildDessert(String dessert) { meal.setDessert(dessert); return this; }
    public Meal build() { return meal; }
}
// 使用
Meal meal = new MealBuilder().buildMain("牛排").buildDrink("可乐").buildDessert("蛋糕").build();
System.out.println(meal); // 输出：主食: 牛排, 饮料: 可乐, 甜点: 蛋糕
```

**总结**

- 优点：封装性好，便于控制细节。
- 缺点：类数量增多。
- 适用场景：复杂对象构建。

------

## 5. 原型模式（Prototype）

**定义**  
通过复制已有实例来创建新对象，而不是通过new。

**场景举例**  
比如绘图软件中复制图形，复制出来的图形和原来的内容一样但可以独立修改。

**Java 示例**

```java
// 图形原型
class Shape implements Cloneable {
    private String color;
    public Shape(String color) { this.color = color; }
    public void setColor(String color) { this.color = color; }
    public String getColor() { return color; }
    public Shape clone() throws CloneNotSupportedException {
        return (Shape) super.clone();
    }
}
// 使用
Shape original = new Shape("红色");
Shape copy = original.clone();
copy.setColor("蓝色");
System.out.println(original.getColor()); // 红色
System.out.println(copy.getColor()); // 蓝色
```

**总结**

- 优点：性能优越，动态加载。
- 缺点：复杂对象克隆困难。
- 适用场景：对象创建成本高。

------

## 6. 适配器模式（Adapter）

**定义**  
将一个类的接口转换成客户端期望的另一个接口。

**场景举例**  
比如手机充电接口有Type-C和Micro-USB两种，适配器可以让Type-C充电器给Micro-USB接口的手机充电。

**Java 示例**

```java
// 目标接口
interface Charger { void charge(); }
// 被适配类
class TypeCCharger {
    public void typeCCharge() { System.out.println("Type-C充电"); }
}
// 适配器
class MicroUSBAdapter implements Charger {
    private TypeCCharger charger;
    public MicroUSBAdapter(TypeCCharger charger) { this.charger = charger; }
    public void charge() { charger.typeCCharge(); }
}
// 使用
Charger charger = new MicroUSBAdapter(new TypeCCharger());
charger.charge(); // 输出：Type-C充电
```

**总结**

- 优点：兼容性强，复用性高。
- 缺点：过多适配器增加复杂度。
- 适用场景：系统集成。

------

## 7. 装饰器模式（Decorator）

**定义**  
动态地给对象添加一些额外的职责。

**场景举例**  
比如咖啡店卖咖啡，可以加奶、加糖，每加一种配料算一次装饰。

**Java 示例**

```java
// 咖啡接口
interface Coffee { String getDescription(); double cost(); }
// 原味咖啡
class SimpleCoffee implements Coffee {
    public String getDescription() { return "原味咖啡"; }
    public double cost() { return 10; }
}
// 装饰抽象类
abstract class CoffeeDecorator implements Coffee {
    protected Coffee coffee;
    public CoffeeDecorator(Coffee coffee) { this.coffee = coffee; }
}
// 加奶
class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) { super(coffee); }
    public String getDescription() { return coffee.getDescription() + "+奶"; }
    public double cost() { return coffee.cost() + 2; }
}
// 使用
Coffee coffee = new MilkDecorator(new SimpleCoffee());
System.out.println(coffee.getDescription() + " 价格：" + coffee.cost()); // 输出：原味咖啡+奶 价格：12.0
```

**总结**

- 优点：灵活组合，扩展性强。
- 缺点：多层装饰难以理解。
- 适用场景：动态扩展功能。

------

## 8. 代理模式（Proxy）

**定义**  
为其他对象提供一种代理以控制对这个对象的访问。

**场景举例**  
公司上网需要走代理服务器，所有员工通过代理访问外部网络，代理可以做权限控制和日志记录。

**Java 示例**

```java
// 主题接口
interface Internet {
    void access(String site);
}
// 真实主题
class RealInternet implements Internet {
    public void access(String site) { System.out.println("访问：" + site); }
}
// 代理
class InternetProxy implements Internet {
    private RealInternet realInternet = new RealInternet();
    public void access(String site) {
        if ("baidu.com".equals(site)) {
            System.out.println("禁止访问：" + site);
        } else {
            realInternet.access(site);
        }
    }
}
// 使用
Internet internet = new InternetProxy();
internet.access("baidu.com"); // 输出：禁止访问：baidu.com
internet.access("github.com"); // 输出：访问：github.com
```

**总结**

- 优点：控制对象访问，增强功能。
- 缺点：增加系统复杂度。
- 适用场景：安全控制、延迟加载。

------

## 9. 外观模式（Facade）

**定义**  
为子系统中的一组接口提供一个一致的界面。

**场景举例**  
比如在智能家居系统中，一键“离家”操作会关闭灯光、空调和门锁，用户只需调用一个总控接口。

**Java 示例**

```java
class Light { void off() { System.out.println("灯关了"); } }
class AirConditioner { void off() { System.out.println("空调关了"); } }
class DoorLock { void lock() { System.out.println("门锁了"); } }
// 外观
class SmartHomeFacade {
    private Light light = new Light();
    private AirConditioner ac = new AirConditioner();
    private DoorLock doorLock = new DoorLock();
    public void leaveHome() {
        light.off();
        ac.off();
        doorLock.lock();
    }
}
// 使用
SmartHomeFacade home = new SmartHomeFacade();
home.leaveHome();
// 输出：灯关了 空调关了 门锁了
```

**总结**

- 优点：简单易用，降低耦合。
- 缺点：不利于子系统扩展。
- 适用场景：为复杂子系统提供简单接口。

------

## 10. 桥接模式（Bridge）

**定义**  
将抽象部分与实现部分分离，使它们可以独立变化。

**场景举例**  
比如消息推送系统有多种消息类型（如短信、邮件），也有多种发送渠道（如阿里云、腾讯云），类型和渠道可以自由组合。

**Java 示例**

```java
interface MessageSender { void send(String message); }
class AliyunSender implements MessageSender { public void send(String m) { System.out.println("阿里云：" + m); } }
class TencentSender implements MessageSender { public void send(String m) { System.out.println("腾讯云：" + m); } }
// 抽象
abstract class Message {
    protected MessageSender sender;
    public Message(MessageSender sender) { this.sender = sender; }
    public abstract void send(String content);
}
class EmailMessage extends Message {
    public EmailMessage(MessageSender sender) { super(sender); }
    public void send(String content) { sender.send("邮件: " + content); }
}
// 使用
Message msg = new EmailMessage(new AliyunSender());
msg.send("面试通知"); // 输出：阿里云：邮件: 面试通知
```

**总结**

- 优点：抽象和实现独立变化。
- 缺点：增加系统复杂度。
- 适用场景：多个维度变化。

------

## 11. 组合模式（Composite）

**定义**  
将对象组合成树形结构以表示“部分-整体”的层次结构。

**场景举例**  
公司组织结构，一个部门下有子部门和员工，打印整个组织时可以递归输出。

**Java 示例**

```java
interface Organization {
    void show();
}
class Employee implements Organization {
    private String name;
    public Employee(String name) { this.name = name; }
    public void show() { System.out.println("员工：" + name); }
}
class Department implements Organization {
    private String name;
    private List<Organization> children = new ArrayList<>();
    public Department(String name) { this.name = name; }
    public void add(Organization org) { children.add(org); }
    public void show() {
        System.out.println("部门：" + name);
        for (Organization org : children) org.show();
    }
}
// 使用
Department dept = new Department("技术部");
dept.add(new Employee("小明"));
dept.add(new Employee("小红"));
dept.show();
// 输出：部门：技术部 员工：小明 员工：小红
```

**总结**

- 优点：树形结构灵活，统一管理。
- 缺点：设计复杂。
- 适用场景：表示层次结构。

------

## 12. 模板方法模式（Template Method）

**定义**  
定义一个操作中的算法骨架，将一些步骤延迟到子类中实现。

**场景举例**  
比如制作泡茶和泡咖啡步骤类似，但冲泡和加料方式不同。

**Java 示例**

```java
abstract class Beverage {
    public final void prepare() {
        boilWater();
        brew();
        pourInCup();
        addCondiments();
    }
    void boilWater() { System.out.println("烧水"); }
    abstract void brew();
    void pourInCup() { System.out.println("倒进杯子"); }
    abstract void addCondiments();
}
class Tea extends Beverage {
    void brew() { System.out.println("泡茶叶"); }
    void addCondiments() { System.out.println("加柠檬"); }
}
// 使用
Beverage tea = new Tea();
tea.prepare();
// 输出：烧水 泡茶叶 倒进杯子 加柠檬
```

**总结**

- 优点：代码复用，流程控制。
- 缺点：灵活性受限。
- 适用场景：流程固定但部分可变。

------

## 13. 策略模式（Strategy）

**定义**  
定义一系列算法，将每一个算法封装起来，并使它们可以互换。

**场景举例**  
比如电商网站有多种优惠计算方式（满减、打折、返券），可以灵活切换。

**Java 示例**

```java
interface DiscountStrategy { double calculate(double price); }
class FullReductionStrategy implements DiscountStrategy {
    public double calculate(double price) { return price > 100 ? price - 20 : price; }
}
class PercentageStrategy implements DiscountStrategy {
    public double calculate(double price) { return price * 0.9; }
}
class Context {
    private DiscountStrategy strategy;
    public Context(DiscountStrategy strategy) { this.strategy = strategy; }
    public double getFinalPrice(double price) { return strategy.calculate(price); }
}
// 使用
Context context = new Context(new FullReductionStrategy());
System.out.println(context.getFinalPrice(120)); // 输出：100.0
```

**总结**

- 优点：算法可切换，扩展性好。
- 缺点：客户端必须知晓所有策略。
- 适用场景：同一问题多种处理方式。

------

## 14. 责任链模式（Chain of Responsibility）

**定义**  
使多个对象有机会处理请求，避免请求的发送者和接收者耦合。

**场景举例**  
比如请假审批流程，班主任、年级主任、校长，都有机会审批。

**Java 示例**

```java
abstract class Approver {
    protected Approver next;
    public void setNext(Approver next) { this.next = next; }
    public abstract void approve(int days);
}
class Teacher extends Approver {
    public void approve(int days) {
        if (days <= 1) System.out.println("班主任批准");
        else if (next != null) next.approve(days);
    }
}
class Principal extends Approver {
    public void approve(int days) {
        if (days > 1) System.out.println("校长批准");
        else if (next != null) next.approve(days);
    }
}
// 使用
Teacher teacher = new Teacher();
Principal principal = new Principal();
teacher.setNext(principal);
teacher.approve(2); // 输出：校长批准
```

**总结**

- 优点：降低耦合，灵活分配职责。
- 缺点：链过长效率低。
- 适用场景：多个对象可处理同一请求。

------

## 15. 状态模式（State）

**定义**  
允许对象在内部状态改变时改变其行为。

**场景举例**  
比如电梯有开门、关门、运行、停止等不同状态，每种状态下响应操作不同。

**Java 示例**

```java
interface ElevatorState { void handle(); }
class OpenState implements ElevatorState { public void handle() { System.out.println("电梯开门"); } }
class CloseState implements ElevatorState { public void handle() { System.out.println("电梯关门"); } }
class Elevator {
    private ElevatorState state;
    public void setState(ElevatorState state) { this.state = state; }
    public void operate() { state.handle(); }
}
// 使用
Elevator elevator = new Elevator();
elevator.setState(new OpenState());
elevator.operate(); // 输出：电梯开门
```

**总结**

- 优点：状态切换明确，封装性强。
- 缺点：类数量多。
- 适用场景：对象状态多变。

------

## 16. 观察者模式（Observer）

**定义**  
对象间一对多依赖，一个对象状态变化时自动通知依赖对象。

**场景举例**  
比如微信公众号推送，用户订阅后，一旦公众号有新消息就会收到通知。

**Java 示例**

```java
interface Subscriber { void update(String msg); }
class User implements Subscriber {
    private String name;
    public User(String name) { this.name = name; }
    public void update(String msg) { System.out.println(name + " 收到消息：" + msg); }
}
class WeChatOfficialAccount {
    private List<Subscriber> subs = new ArrayList<>();
    public void subscribe(Subscriber sub) { subs.add(sub); }
    public void notifySubs(String msg) { for (Subscriber sub : subs) sub.update(msg); }
}
// 使用
WeChatOfficialAccount account = new WeChatOfficialAccount();
account.subscribe(new User("小明"));
account.subscribe(new User("小红"));
account.notifySubs("新活动上线");
// 输出：小明 收到消息：新活动上线 小红 收到消息：新活动上线
```

**总结**

- 优点：解耦，提高灵活性。
- 缺点：通知顺序不确定。
- 适用场景：事件通知、订阅。

------

## 17. 备忘录模式（Memento）

**定义**  
在不破坏封装性的前提下，捕获并外部化对象的内部状态。

**场景举例**  
比如编辑器的撤销功能，保存历史内容，支持回滚。

**Java 示例**

```java
class Editor {
    private String content;
    public void setContent(String content) { this.content = content; }
    public String getContent() { return content; }
    public Memento save() { return new Memento(content); }
    public void restore(Memento m) { this.content = m.getContent(); }
}
class Memento {
    private String content;
    public Memento(String content) { this.content = content; }
    public String getContent() { return content; }
}
// 使用
Editor editor = new Editor();
editor.setContent("第一版");
Memento mem = editor.save();
editor.setContent("第二版");
editor.restore(mem);
System.out.println(editor.getContent()); // 输出：第一版
```

**总结**

- 优点：状态恢复，封装性好。
- 缺点：资源消耗大。
- 适用场景：撤销操作、历史记录。

------

## 18. 命令模式（Command）

**定义**  
将请求封装为对象，从而可用不同参数化、排队、记录等。

**场景举例**  
比如遥控器控制灯的开关，把“开灯”“关灯”封装为命令对象。

**Java 示例**

```java
interface Command { void execute(); }
class Light {
    public void on() { System.out.println("灯打开"); }
    public void off() { System.out.println("灯关闭"); }
}
class LightOnCommand implements Command {
    private Light light;
    public LightOnCommand(Light light) { this.light = light; }
    public void execute() { light.on(); }
}
class RemoteControl {
    private Command command;
    public void setCommand(Command command) { this.command = command; }
    public void pressButton() { command.execute(); }
}
// 使用
Light light = new Light();
Command command = new LightOnCommand(light);
RemoteControl remote = new RemoteControl();
remote.setCommand(command);
remote.pressButton(); // 输出：灯打开
```

**总结**

- 优点：解耦，支持撤销/重做。
- 缺点：类数量增多。
- 适用场景：事务、日志请求。

------

## 19. 访问者模式（Visitor）

**定义**  
表示一个作用于某对象结构中的各元素的操作。

**场景举例**  
比如公司年终评优，对员工和经理有不同的评估方法。

**Java 示例**

```java
interface Staff { void accept(Visitor visitor); }
class Employee implements Staff {
    public void accept(Visitor visitor) { visitor.visit(this); }
}
class Manager implements Staff {
    public void accept(Visitor visitor) { visitor.visit(this); }
}
interface Visitor {
    void visit(Employee e);
    void visit(Manager m);
}
class PerformanceVisitor implements Visitor {
    public void visit(Employee e) { System.out.println("员工评优"); }
    public void visit(Manager m) { System.out.println("经理评优"); }
}
// 使用
Staff emp = new Employee();
Visitor visitor = new PerformanceVisitor();
emp.accept(visitor); // 输出：员工评优
```

**总结**

- 优点：添加新操作方便。
- 缺点：元素变动难。
- 适用场景：数据结构稳定，操作易变。

------

## 20. 解释器模式（Interpreter）

**定义**  
给定一个语言，定义其文法表示，并提供解释器。

**场景举例**  
比如简单的计算器，能解析“1+2”或“3-1”这种表达式。

**Java 示例**

```java
interface Expression { int interpret(); }
class Number implements Expression {
    private int value;
    public Number(int value) { this.value = value; }
    public int interpret() { return value; }
}
class Add implements Expression {
    private Expression left, right;
    public Add(Expression left, Expression right) { this.left = left; this.right = right; }
    public int interpret() { return left.interpret() + right.interpret(); }
}
// 使用
Expression exp = new Add(new Number(1), new Number(2));
System.out.println(exp.interpret()); // 输出：3
```

**总结**

- 优点：易扩展，灵活。
- 缺点：效率低，复杂度高。
- 适用场景：语法解释、规则校验。

------

## 21. 中介者模式（Mediator）

**定义**  
用一个中介对象封装一系列对象交互。

**场景举例**  
比如聊天室，所有用户发消息都通过聊天室中介传递，用户之间不直接通信。

**Java 示例**

```java
interface ChatRoom {
    void showMsg(String user, String msg);
}
class ChatRoomImpl implements ChatRoom {
    public void showMsg(String user, String msg) {
        System.out.println(user + "：" + msg);
    }
}
class User {
    private String name;
    private ChatRoom chatRoom;
    public User(String name, ChatRoom chatRoom) {
        this.name = name; this.chatRoom = chatRoom;
    }
    public void send(String msg) { chatRoom.showMsg(name, msg); }
}
// 使用
ChatRoom room = new ChatRoomImpl();
User user = new User("小明", room);
user.send("大家好"); // 输出：小明：大家好
```

**总结**

- 优点：降低耦合，集中控制。
- 缺点：中介者复杂。
- 适用场景：复杂对象交互。

------

## 22. 迭代器模式（Iterator）

**定义**  
顺序访问集合对象元素，无需暴露集合内部表示。

**场景举例**  
比如遍历图书馆的书架，逐本取书而不关心书的存储细节。

**Java 示例**

```java
class BookShelf implements Iterable<String> {
    private List<String> books = new ArrayList<>();
    public void addBook(String book) { books.add(book); }
    public Iterator<String> iterator() { return books.iterator(); }
}
// 使用
BookShelf shelf = new BookShelf();
shelf.addBook("Java编程思想");
shelf.addBook("设计模式");
for (String book : shelf) {
    System.out.println("书籍：" + book);
}
// 输出：书籍：Java编程思想 书籍：设计模式
```

**总结**

- 优点：遍历统一，封装性好。
- 缺点：类数量增加。
- 适用场景：集合遍历。

------

## 23. 享元模式（Flyweight）

**定义**  
运用共享技术有效支持大量细粒度对象。

**场景举例**  
比如棋盘游戏中，黑子和白子对象可以共享，成千上万个棋子只维护坐标和颜色引用。

**Java 示例**

```java
interface Chess { void display(int x, int y); }
class ChessPiece implements Chess {
    private String color;
    public ChessPiece(String color) { this.color = color; }
    public void display(int x, int y) {
        System.out.println(color + "棋子落在（" + x + "," + y + ")");
    }
}
class ChessFactory {
    private Map<String, Chess> pool = new HashMap<>();
    public Chess getChess(String color) {
        if (!pool.containsKey(color)) pool.put(color, new ChessPiece(color));
        return pool.get(color);
    }
}
// 使用
ChessFactory factory = new ChessFactory();
Chess black1 = factory.getChess("黑");
Chess black2 = factory.getChess("黑");
Chess white = factory.getChess("白");
black1.display(1, 2);
black2.display(2, 3);
white.display(4, 5);
// 输出：黑棋子落在（1,2） 黑棋子落在（2,3） 白棋子落在（4,5）
```

**总结**

- 优点：节省内存，提升性能。
- 缺点：系统复杂度提高。
- 适用场景：大量相似对象。

------

# 设计模式对比与总结

| 分类   | 模式                                                         | 主要作用           | 优点               | 缺点                 | 场景举例           |
| ------ | ------------------------------------------------------------ | ------------------ | ------------------ | -------------------- | ------------------ |
| 创建型 | 单例、工厂、抽象工厂、建造者、原型                           | 对象创建           | 封装对象创建过程   | 柔性与复杂度权衡     | 配置、工厂类       |
| 结构型 | 适配器、装饰器、代理、外观、桥接、组合、享元                 | 对象/类结构        | 降低耦合、可扩展   | 结构复杂可能变高     | UI、缓存           |
| 行为型 | 策略、模板方法、观察者、命令、责任链、状态、访问者、备忘录、解释器、中介者、迭代器 | 对象行为，职责分配 | 分担职责，灵活扩展 | 类增多、理解难度提升 | 事件驱动、业务规则 |

**综合建议：**

- 创建型关注对象实例化，结构型关注对象组合，行为型关注对象职责分配和交互。
- 选择模式时优先考虑实际问题，避免过度设计。
- 熟悉各模式优缺点及适用场景，灵活组合使用。

------

**面试Tips：**

- 能结合实际项目举例说明模式应用。
- 熟悉常见模式的UML结构和代码实现。
- 了解设计模式之间的关系与区别。



# 设计模式的五大原则，通常指的是面向对象设计原则（SOLID），它们是提高代码可维护性、扩展性和灵活性的核心指导思想。具体如下：

---

### 1. 单一职责原则（SRP, Single Responsibility Principle）

**定义**：一个类只做一件事，只有一个引起它变化的原因。  
**解释**：每个类应该有且只有一个职责，如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会影响到其他职责。

---

### 2. 开闭原则（OCP, Open-Closed Principle）

**定义**：对扩展开放，对修改关闭。  
**解释**：软件实体（类、模块、函数等）应该在不修改原有代码的基础上，通过扩展的方式来实现新功能。这有利于系统的稳定和灵活。

---

### 3. 里氏替换原则（LSP, Liskov Substitution Principle）

**定义**：子类对象能够替换父类对象，并且程序功能不被影响。  
**解释**：任何基类出现的地方，子类都可以替换，并且保证原有功能不出错。遵循该原则可以保证继承体系的健壮性。

---

### 4. 接口隔离原则（ISP, Interface Segregation Principle）

**定义**：不应强迫客户依赖它们不用的方法。  
**解释**：一个类对另一个类的依赖应该建立在最小的接口上。即多个专门的接口优于一个总接口，避免“胖接口”。

---

### 5. 依赖倒置原则（DIP, Dependency Inversion Principle）

**定义**：高层模块不应该依赖低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。  
**解释**：通过面向接口编程，减少高层模块对具体实现的依赖，提高系统灵活性和可扩展性。

---

#### 总结
- **SRP（单一职责）**：只做一件事
- **OCP（开闭原则）**：扩展开放，修改关闭
- **LSP（里氏替换）**：子类可替换父类
- **ISP（接口隔离）**：用小而专的接口
- **DIP（依赖倒置）**：依赖抽象不依赖细节

这五大原则是理解和运用设计模式的基础。



# 设计模式面试追问题目与答案

## 目录
- [创建型模式](#创建型模式)
- [结构型模式](#结构型模式)
- [行为型模式](#行为型模式)
- [设计模式通用问题](#设计模式通用问题)

## 创建型模式

### 单例模式
**问：单例模式有哪些实现方式？它们各有什么优缺点？**

答：单例模式的常见实现方式：
1. **饿汉式**：类加载时就初始化实例
   - 优点：线程安全，实现简单
   - 缺点：不支持延迟加载，可能造成资源浪费

2. **懒汉式**（线程不安全）：第一次使用时才初始化
   - 优点：支持延迟加载
   - 缺点：线程不安全

   > 懒汉式单例（Lazy Singleton）实现通常是指在第一次使用实例时才创建对象，而不是在类加载时立即创建。最常见的实现方式如下：
   >
   > ```java
   > public class Singleton {
   >     private static Singleton instance;
   > 
   >     private Singleton() {}
   > 
   >     public static Singleton getInstance() {
   >         if (instance == null) {
   >             instance = new Singleton();
   >         }
   >         return instance;
   >     }
   > }
   > ```
   >
   > **线程不安全的原因：**
   >
   > 在多线程环境下，假设有两个线程A和B同时调用`getInstance()`方法：
   >
   > 1. 线程A进入`if (instance == null)`判断时，发现`instance`为null，于是准备创建实例。
   > 2. 线程B此时也进入了`if (instance == null)`判断，同样发现`instance`为null，也准备创建实例。
   > 3. 这样两个线程就会分别创建各自的`Singleton`实例，导致**单例失效**。
   >
   > **本质原因**：  
   > 懒汉式实现没有同步措施，无法保证“只创建一个实例”这一单例模式的核心要求。在多线程环境下，多个线程“看到”的`instance`变量还没被初始化，于是都去创建，导致多个实例。
   >
   > **如何解决？**
   > - 可以使用`synchronized`关键字对`getInstance()`方法进行同步，或者采用“双重检查锁定（DCL）”等线程安全的单例实现方式。
   >
   > **线程安全实现示例：**
   >
   > ```java
   > public class Singleton {
   >     private static Singleton instance;
   > 
   >     private Singleton() {}
   > 
   >     public static synchronized Singleton getInstance() {
   >         if (instance == null) {
   >             instance = new Singleton();
   >         }
   >         return instance;
   >     }
   > }
   > ```
   > 或者采用DCL：
   >
   > ```java
   > public class Singleton {
   >     private static volatile Singleton instance;
   > 
   >     private Singleton() {}
   > 
   >     public static Singleton getInstance() {
   >         if (instance == null) {
   >             synchronized (Singleton.class) {
   >                 if (instance == null) {
   >                     instance = new Singleton();
   >                 }
   >             }
   >         }
   >         return instance;
   >     }
   > }
   > ```
   >
   > **总结：**  
   > 懒汉式单例实现由于没有加锁，在多线程并发访问时可能会创建多个实例，因此是线程不安全的。

3. **懒汉式**（同步方法）：在方法上加synchronized
   - 优点：线程安全，支持延迟加载
   - 缺点：每次获取实例都会同步，性能较差

4. **双重检查锁定**：使用`双重检查`和`volatile`关键字
   - 优点：线程安全，延迟加载，性能较好
   - 缺点：实现较复杂，Java 5以前的JMM存在问题

5. **静态内部类**：使用类加载机制保证线程安全
   - 优点：线程安全，延迟加载，实现简单

   - 缺点：不能传参

   - > 静态内部类实现单例模式是一种常用且优雅的方式。它利用了Java类加载机制的特性：**只有在真正使用时才会加载静态内部类**，从而实现了延迟加载和线程安全。
     >
     > 下面是标准的静态内部类实现单例模式的写法：
     >
     > ```java
     > public class Singleton {
     >     // 私有构造方法，防止外部实例化
     >     private Singleton() {}
     > 
     >     // 静态内部类，只在第一次调用 getInstance() 时加载
     >     private static class Holder {
     >         private static final Singleton INSTANCE = new Singleton();
     >     }
     > 
     >     // 提供全局访问点
     >     public static Singleton getInstance() {
     >         return Holder.INSTANCE;
     >     }
     > }
     > ```
     >
     > ### 说明
     > - **线程安全**：JVM保证类的初始化过程是线程安全的，所以不会出现多线程并发创建对象的情况。
     > - **延迟加载**：只有在调用`getInstance()`时，才会加载`Holder`类并初始化`INSTANCE`。
     > - **实现简单**：无需显示加锁或写复杂代码。
     >
     > ### 缺点
     > - **不能传参**：只能用无参构造创建实例，无法根据需要传递参数给单例对象。
     >
     > ---
     >
     > **总结**：  
     > 静态内部类方式，既保证了线程安全，又实现了延迟加载，代码简洁，是实际开发中推荐使用的单例实现方式。

6. **枚举**：使用Java枚举实现
   - 优点：线程安全，防止反序列化和反射攻击，最简洁

   - 缺点：不支持延迟加载，枚举类无法继承其他类

   - > 在Java中，使用枚举（`enum`）实现单例模式是最推荐的方式之一。其实现方式非常简单，只需要定义一个包含单个元素的枚举类型即可。
     >
     > **实现示例：**
     >
     > ```java
     > public enum Singleton {
     >     INSTANCE;
     > 
     >     // 你可以在这里定义需要的方法和成员变量
     >     public void doSomething() {
     >         System.out.println("Doing something...");
     >     }
     > }
     > ```
     >
     > **使用方式：**
     >
     > ```java
     > Singleton.INSTANCE.doSomething();
     > ```
     >
     > ---
     >
     > ### 说明
     >
     > - **线程安全**：枚举的实例创建由JVM保证线程安全。
     > - **防止反射和反序列化攻击**：枚举天然防止反射和反序列化产生新的实例。
     > - **最简洁**：只需一行声明即可实现单例。
     > - **缺点**：
     >   - 不能延迟加载（枚举类在加载时就实例化）。
     >   - 枚举类不能继承其他类（但可以实现接口）。
     >
     > ---
     >
     > ### 总结
     >
     > **实现单例模式的标准写法如下：**
     >
     > ```java
     > public enum Singleton {
     >     INSTANCE;
     >     // 可以添加更多方法和字段
     > }
     > ```
     >
     > **调用：**
     >
     > ```java
     > Singleton singleton = Singleton.INSTANCE;
     > ```
     >
     > 这样就实现了线程安全、简洁且防攻击的单例模式。

**问：单例模式如何防止序列化和反序列化破坏单例？**

答：防止序列化和反序列化破坏单例的方法：
1. 在单例类中实现`readResolve()`方法，确保反序列化时返回单例实例

   ```java
   import java.io.ObjectStreamException;
   import java.io.Serializable;
   
   public class Singleton implements Serializable {
       private static final long serialVersionUID = 1L;
       // 私有静态实例
       private static final Singleton INSTANCE = new Singleton();
   
       // 私有构造方法，防止外部实例化
       private Singleton() {}
   
       // 提供全局访问点
       public static Singleton getInstance() {
           return INSTANCE;
       }
   
       // 确保反序列化时返回同一个实例
       private Object readResolve() throws ObjectStreamException {
           return INSTANCE;
       }
   }
   ```

   

2. 使用枚举实现单例，因为Java确保枚举实例序列化后不会创建新实例

3. 不使单例类实现Serializable接口，避免序列化

**问：如何实现线程安全的懒加载单例？**

答：实现线程安全的懒加载单例有以下方法：
1. 使用synchronized同步方法（性能较差）
2. 双重检查锁定（DCL）配合volatile关键字
3. 使用静态内部类方式，利用类加载机制保证线程安全
4. 使用ThreadLocal实现线程单例

### 工厂方法模式
**问：简单工厂、工厂方法和抽象工厂有什么区别？**

答：三种工厂模式的区别：
1. **简单工厂**（不属于GoF的23种设计模式）：
   - 一个工厂类负责创建多种产品
   - 通过参数类型决定创建哪种具体产品
   - 违反开闭原则，添加新产品需修改工厂类

2. **工厂方法**：
   - 定义创建产品的接口，由子类决定实例化哪个类
   - 每种产品对应一个工厂子类
   - 符合开闭原则，添加新产品只需添加对应的工厂子类

3. **抽象工厂**：
   - 提供创建一系列相关或依赖对象的接口，无需指定具体类
   - 每个工厂可以创建多种不同类型但相关的产品
   - 强调产品族概念，便于交换产品族

> 我悟了：其实抽象工厂和工厂方法的代码结构几乎一样，都是一个抽象产品类，具体产品类，抽象工厂类，具体工厂类，只是抽象产品类里面，抽象工厂有多个产品，而工厂方法只有一个产品；
>
> 先从抽象工厂模式说起，在产品类里面定义了一大堆的产品（沙发，茶几，电视柜）这些属于一个大族群（家具），然后我们的工厂类就定义不同风格的族群（唐代家具，宋代家具，清朝家具），这些家具工厂都会生产（沙发，茶几，电视柜）这些产品。好了，到这里我们就可以引出抽象工厂的优势和劣势了：我们发现如果要添加一个XX家具这样的产品就很容易实现（只需要重新按照抽象产品的规则定制XX风格的产品），但是我们的家具这个基类如果要添加一个产品，比如添加一个冰箱，那么所有的工厂类还需要重新写这个新的冰箱的代码，违反了开闭原则。
>
> 然后时工厂方法类，一句话：单一产品的不同品牌。抽象产品是手机，那么我们的工厂只生产手机。而手机有很多的品牌（华为，小米），但是都是生产手机，这个其实有一点多态的味道。
>
> 普通工厂：通过不同的入参来觉得工厂生产什么产品。

**问：什么情况下应该选择工厂方法而不是简单工厂？**

答：应选择工厂方法而非简单工厂的情况：
1. 需要遵循开闭原则，系统需要频繁添加新产品类型
2. 产品创建逻辑复杂，使用工厂方法可将逻辑分散到各个工厂中
3. 产品层次结构明确，适合于产品等级结构较为稳定的情况
4. 在框架设计中，需要让框架使用者通过继承定制产品创建过程
5. 强调依赖倒置原则，希望高层模块依赖抽象而非具体类

**问：抽象工厂模式如何应对产品族扩展和产品结构变化？**

答：抽象工厂模式对两种变化的适应性不同：
1. **添加新的产品族**（优势）：
   - 只需创建新的具体工厂类，实现抽象工厂接口
   - 不需要修改现有代码，符合开闭原则
   - 例如：添加Linux风格UI，只需创建LinuxFactory及相关产品

2. **添加新的产品结构**（劣势）：
   - 需要修改抽象工厂接口和所有现有工厂
   - 违反开闭原则
   - 例如：添加新产品类型Dialog，需要修改所有工厂实现

应对产品结构变化的策略：
1. 使用反射和配置动态创建产品
2. 使用默认方法或适配器模式减少接口变化影响
3. 组合使用工厂模式和原型模式，通过原型复制创建新产品

### 建造者模式
**问：建造者模式与工厂模式有什么区别？何时应该用建造者而非工厂？**

答：建造者模式和工厂模式的区别：
1. **关注点不同**：
   - 工厂模式关注于**创建什么产品**（产品类型）
   - 建造者模式关注于**如何创建产品**（产品构建过程）

2. **构建复杂度**：
   - 工厂模式适用于创建结构相对简单的产品
   - 建造者模式适用于创建内部结构复杂的产品

3. **客户参与度**：
   - 工厂模式中客户端不关心产品创建过程
   - 建造者模式允许客户端参与定制产品的创建过程

应该使用建造者而非工厂的场景：
1. 当对象有很多参数，特别是有许多可选参数时
2. 当对象构造有特定步骤顺序要求时
3. 当需要创建不可变对象，同时避免构造函数参数过多时
4. 当创建过程中需要多次调用才能构建完整对象时

**问：建造者模式的"链式调用"是如何实现的？有什么优势？**

答：建造者模式的链式调用（流式接口）实现原理是每个设置方法都返回建造者对象本身（this）。

链式调用的优势：
1. **易读性**：代码可读性更强，清晰表达了对象构造过程
2. **灵活性**：可以任意顺序设置属性，只调用需要的方法
3. **参数清晰**：避免了构造函数参数顺序混淆的问题
4. **不可变性支持**：支持创建不可变对象
5. **参数验证**：可以在build()方法中集中验证参数

**问：建造者模式中Director的作用是什么？什么情况下可以省略Director？**

答：Director在建造者模式中的作用：
1. **封装构建过程**：Director封装了使用Builder创建产品的算法
2. **复用构建逻辑**：相同的构建过程可以用于创建不同表示的产品
3. **隔离客户端**：客户端不需要了解产品构建的具体步骤
4. **强制构建顺序**：确保产品构建按照特定步骤和顺序进行

可以省略Director的情况：
1. **简单构建过程**：当产品构建过程相对简单时
2. **链式调用**：使用流式接口方式的Builder时通常不需要Director
3. **只有一种构建算法**：当系统中只有一种构建算法时
4. **客户端控制**：当客户端需要直接控制构建过程时

### 原型模式
**问：深拷贝和浅拷贝在原型模式中有什么区别？如何实现深拷贝？**

答：在原型模式中，深拷贝和浅拷贝的区别：
1. **浅拷贝**：
   - 只复制对象本身及其基本类型的属性值
   - 对于引用类型属性，只复制引用，不复制引用指向的对象
   - 原对象和克隆对象共享引用类型属性指向的对象

2. **深拷贝**：
   - 复制对象本身及其所有属性（包括基本类型和引用类型）
   - 对于引用类型属性，递归复制引用指向的对象
   - 原对象和克隆对象拥有完全独立的对象图，互不影响

实现深拷贝的方法：
1. **手动递归克隆**：为每个引用类型属性调用其克隆方法
2. **序列化**：通过对象序列化和反序列化实现深拷贝
3. **使用第三方库**：如Apache Commons Lang的SerializationUtils
4. **使用JSON转换**：将对象转为JSON再转回对象
5. **构造函数复制**：在拷贝构造函数中递归创建新对象

**问：原型模式在实际项目中有哪些应用场景？**

答：原型模式在实际项目中的应用场景：
1. **对象初始化成本高**：
   - 数据库连接对象：避免频繁建立数据库连接
   - 图像处理：图像加载和处理开销大
   - 3D模型：复制基础模型后修改，避免重新加载和解析

2. **保存对象状态**：
   - 编辑器的撤销功能：在编辑前克隆对象，便于恢复
   - 游戏存档：保存游戏角色或场景的特定状态
   - 表单编辑：保存表单原始状态，用于重置或比较变更

3. **复杂对象构建**：
   - 配置模板：基于模板配置创建具体配置
   - 预设对象：如预设的文档模板、游戏角色模板等
   - CAD系统：复制标准零件后修改参数

**问：原型模式与对象池模式有什么关系？**

答：原型模式与对象池模式的关系：
1. **互补关系**：
   - 原型模式关注对象的克隆和创建
   - 对象池模式关注对象的重用和生命周期管理

2. **结合使用的优势**：
   - 提高性能：避免频繁创建开销大的对象
   - 资源优化：有效管理有限资源
   - 一致性：确保池中对象具有一致的初始状态

结合使用方式：
- 使用原型模式初始化对象池中的对象
- 从对象池获取对象时，可以先克隆原型再返回
- 归还对象到池中时，可以将对象重置为原型状态

## 结构型模式

### 适配器模式
**问：类适配器和对象适配器有什么区别？各自有什么优缺点？**

答：类适配器和对象适配器的区别：
> 没问题！下面用**通俗易懂的方式**帮你区分“对象适配器”和“类适配器”的区别，并结合实际例子。
>
> ---
>
> ```
> Client ---> Target(接口)
>                ^
>                |
>             Adapter（实现Target接口，组合Adaptee）
>                |
>                v
>            Adaptee（已有类）
> ```
>
> ## 一、类适配器（Class Adapter）
>
> - **实现方式**：通过**继承**实现（一般用多重继承，但 Java 只支持单继承）。
> - **结构**：适配器类**继承**了被适配的类，并**实现了目标接口**。
> - **优点**：适配器类可以直接重写或扩展被适配者的方法。
> - **缺点**：受限于语言单继承（如Java），只能适配一个类；而且适配器和被适配者高度耦合。
>
> ### 示例（Java 伪代码）：
> ```java
> // 目标接口
> interface Target {
>     void request();
> }
> 
> // 被适配类
> class Adaptee {
>     void specificRequest() {
>         System.out.println("Adaptee method");
>     }
> }
> 
> // 类适配器（通过继承）
> class Adapter extends Adaptee implements Target {
>     public void request() {
>         specificRequest(); // 调用父类方法
>     }
> }
> ```
>
> ---
>
> ## 二、对象适配器（Object Adapter）
>
> - **实现方式**：通过**组合**实现（持有被适配者对象的引用）。
> - **结构**：适配器类**实现目标接口**，并**持有关联的被适配者对象**，通过这个对象调用被适配者的方法。
> - **优点**：可以适配多个被适配者的子类，灵活且不受单继承限制，解耦更好。
> - **缺点**：不能重写被适配者的行为，只能调用已有的方法。
>
> ### 示例（Java 伪代码）：
> ```java
> // 目标接口
> interface Target {
>     void request();
> }
> 
> // 被适配类
> class Adaptee {
>     void specificRequest() {
>         System.out.println("Adaptee method");
>     }
> }
> 
> // 对象适配器（通过组合）
> class Adapter implements Target {
>     private Adaptee adaptee;
> 
>     public Adapter(Adaptee adaptee) {
>         this.adaptee = adaptee;
>     }
> 
>     public void request() {
>         adaptee.specificRequest(); // 通过对象调用方法
>     }
> }
> ```
>
> ---
>
> ## 三、总结对比
>
> |           | 类适配器               | 对象适配器             |
> | --------- | ---------------------- | ---------------------- |
> | 实现方式  | 继承                   | 组合                   |
> | 适配范围  | 只能适配一个类         | 可以适配多个类及其子类 |
> | 扩展性    | 受限于继承，灵活性较低 | 灵活性高               |
> | 代码耦合  | 与被适配类耦合度高     | 与被适配类解耦         |
> | Java 支持 | 只支持单继承，有限制   | 不受限制               |
>
> **打个比方**：  
> - 类适配器像是“直接变成”了被适配的类（你继承了它）。
> - 对象适配器像是“拥有”了被适配的类（你用它来帮你做事）。
>
> ---
>
> 如果你想看更详细的例子（比如在 C++、Python 里的实现），或者有具体需求，可以告诉我！

**问：适配器模式与装饰器模式的区别是什么？如何选择？**

答：适配器模式与装饰器模式的区别：
1. **意图不同**：
   - 适配器模式：将一个类的接口转换成客户端期望的另一个接口
   - 装饰器模式：动态地给对象添加额外的职责，比子类更灵活的扩展功能

2. **接口关系**：
   - 适配器模式：目标接口与被适配者接口不同
   - 装饰器模式：装饰器与被装饰对象实现相同的接口

3. **透明性**：
   - 适配器模式：客户端看不到被适配者，只知道目标接口
   - 装饰器模式：对客户端透明，可以递归嵌套多个装饰器

4. **结构变化**：
   - 适配器模式：通常是一次性的接口转换
   - 装饰器模式：支持动态添加和组合多个功能

如何选择：
- **使用适配器的情况**：需要使用现有类，但其接口与需求不匹配；想整合多个第三方库；系统重构时，需要保持旧接口兼容
- **使用装饰器的情况**：需要动态透明地向对象添加职责；需要为对象增强功能；当继承不适合扩展功能时

**问：双向适配器是什么？如何实现？**

答：双向适配器是一种特殊的适配器，它允许客户端透明地使用两个不兼容接口中的任意一个。它同时实现了目标接口和被适配者接口。

双向适配器的特点：
1. 同时实现两个（或多个）接口
2. 可以在两个方向上进行适配
3. 使得两个原本不兼容的接口能够相互协作

双向适配器的应用场景：
1. 系统重构时，兼容新旧接口
2. 不同系统集成时，需要双向通信
3. 需要在两个现有系统之间建立桥梁，而不修改现有代码

实现方法：适配器同时实现两个接口，并在每个接口方法实现中调用另一个接口的相应方法。

### 装饰器模式
**问：为什么Java I/O库选择装饰器模式而不是继承？**

答：Java I/O库选择装饰器模式而不是继承的原因：
1. **避免类爆炸问题**：
   - 如果使用继承，每种组合都需要一个子类
   - 例如：缓冲+加密+压缩 = 需要7种组合类
   - 装饰器模式通过组合实现，可以动态组合任意功能

2. **灵活的功能组合**：
   - 装饰器允许在运行时动态组合功能
   - 用户可以按需选择和堆叠I/O流装饰器

3. **单一职责原则**：
   - 每个装饰器类只负责一个特定功能
   - 功能划分清晰，便于维护和扩展

4. **开闭原则**：
   - 不修改现有代码即可扩展I/O流功能
   - 新增装饰器不影响现有代码

**问：装饰器模式与代理模式有什么区别？**

答：装饰器模式与代理模式的主要区别：
1. **意图不同**：
   - 装饰器模式：动态地给对象添加额外职责
   - 代理模式：控制对对象的访问，或延迟对象的创建

2. **关注点不同**：
   - 装饰器模式关注于在不改变接口的前提下增强功能
   - 代理模式关注于控制对象的访问，可能不改变原始功能

3. **透明度不同**：
   - 装饰器通常对客户端完全透明
   - 代理可能对客户端透明也可能不透明

4. **组合方式**：
   - 装饰器模式强调动态可组合性，常常叠加多个装饰器
   - 代理模式通常是一对一的关系，不强调组合

5. **应用场景区别**：
   - **装饰器典型应用**：Java I/O库、UI组件功能增强、数据加密转换
   - **代理典型应用**：远程代理、虚拟代理、保护代理、AOP中的方法拦截

**问：如何避免装饰器模式带来的复杂性？**

答：避免装饰器模式带来的复杂性的方法：
1. **使用工厂或生成器模式创建装饰链**，简化客户端创建过程
2. **使用建造者模式构建装饰链**，提供流畅的API
3. **使用注解和AOP简化**装饰器的应用
4. **使用函数式编程组合装饰器**（Java 8+）
5. **使用模板方法控制装饰顺序**，确保正确的装饰顺序
6. **配置驱动的装饰器链**，通过配置文件定义装饰链
7. **使用装饰器注册表管理装饰器**，集中管理装饰器
8. **保持装饰器简单**，每个装饰器只负责单一职责

### 代理模式
**问：动态代理和静态代理有什么区别？如何选择？**

答：动态代理和静态代理的区别：
1. **创建时机**：
   - 静态代理：编译时确定，在代码中明确定义代理类
   - 动态代理：运行时动态生成代理类

2. **实现方式**：
   - 静态代理：手动编写代理类，实现与目标对象相同的接口
   - 动态代理：通过反射或字节码生成技术自动生成代理类

3. **适用场景**：
   - 静态代理：代理关系固定，目标类较少
   - 动态代理：代理关系灵活，目标类较多

4. **性能差异**：
   - 静态代理通常性能更好（无反射开销）
   - 动态代理涉及反射调用，性能略低
   - 现代JVM对反射的优化使差距变小

选择标准：
- **选择静态代理的情况**：代理关系固定且不会改变；只代理少量类；对性能要求极高；不需要对所有方法都进行代理
- **选择动态代理的情况**：需要为大量类提供统一代理行为；代理关系在运行时确定；需要动态添加或移除代理行为；AOP场景

**问：JDK动态代理和CGLIB动态代理的区别是什么？**

答：JDK动态代理和CGLIB动态代理的主要区别：
1. **代理对象的生成方式**：
   - JDK动态代理：基于接口，通过实现接口生成代理类
   - CGLIB动态代理：基于继承，通过继承目标类生成代理类

2. **适用范围**：
   - JDK动态代理：只能代理实现了接口的类
   - CGLIB动态代理：可以代理没有实现接口的类（final类除外）

3. **性能比较**：
   - JDK动态代理：反射调用，在早期版本中性能较低
   - CGLIB动态代理：生成字节码，初始化较慢，但方法调用较快
   - JDK 8+版本优化后，两者性能差距不大

4. **代理方式**：
   - JDK动态代理：通过InvocationHandler实现
   - CGLIB动态代理：通过MethodInterceptor实现

5. **限制**：
   - JDK动态代理：不能代理没有接口的类，不能代理接口中未定义的方法
   - CGLIB动态代理：不能代理final类和final方法，构造函数不会被拦截

**问：代理模式在AOP中是如何应用的？**

答：代理模式是AOP（面向切面编程）实现的核心技术基础：
1. **AOP与代理模式的关系**：
   - AOP使用代理模式将横切关注点（如日志、事务等）与业务逻辑分离
   - 代理对象包装目标对象，在方法调用前后插入额外逻辑

2. **AOP核心概念与代理的映射**：
   - 切面（Aspect）：对应代理中的附加功能
   - 通知（Advice）：对应代理中的前置/后置处理
   - 连接点（Join Point）：程序执行点，通常是方法调用
   - 切点（Pointcut）：指定应用通知的连接点集合
   - 织入（Weaving）：将切面应用到目标对象创建代理的过程

3. **Spring AOP中的代理实现**：
   - Spring通过BeanPostProcessor在Bean初始化后创建代理
   - 如果目标类实现了接口，默认使用JDK动态代理
   - 如果目标类没有实现接口，使用CGLIB动态代理

4. **AOP中的代理模式优势**：
   - 关注点分离，提高模块化
   - 避免代码重复和横切关注点散布
   - 使业务逻辑更清晰，减少非业务代码干扰
   - 动态应用/移除切面，无需修改原始代码

5. **实际应用场景**：
   - 事务管理（@Transactional）
   - 安全控制（@Secured, @PreAuthorize）
   - 缓存（@Cacheable）
   - 日志记录
   - 性能监控
   - 重试机制

### 外观模式
**问：外观模式和中介者模式有什么区别？**

答：外观模式和中介者模式的主要区别：
1. **意图不同**：
   - 外观模式：为子系统提供统一的高层接口，简化客户端与子系统的交互
   - 中介者模式：封装对象间的交互，使对象之间不直接引用，降低耦合

2. **通信方向**：
   - 外观模式：单向通信，客户端通过外观访问子系统
   - 中介者模式：多向通信，各组件通过中介者相互交互

3. **依赖关系**：
   - 外观模式：子系统不知道外观的存在，外观依赖子系统
   - 中介者模式：所有组件都知道并依赖中介者

4. **解决的问题**：
   - 外观模式：解决客户端与复杂子系统的耦合问题
   - 中介者模式：解决组件之间的相互耦合问题

**问：外观模式会不会违反开闭原则？如何处理？**

答：外观模式与开闭原则的关系：
1. **外观模式可能违反开闭原则的情况**：
   - 当子系统变化时，外观类可能需要修改
   - 当需要添加新功能时，可能需要修改已有的外观类
   - 单一外观类可能变得过于庞大，承担过多职责

2. **解决方案**：
   - **分层外观**：创建多层外观，新功能通过扩展外观而非修改
   - **组合外观**：将不同功能的外观拆分成多个小外观，再组合使用
   - **接口外观**：定义外观接口，通过不同实现扩展功能
   - **工厂模式结合**：使用工厂创建适当的外观实例
   - **遵守开闭原则的最佳实践**：定义稳定的外观接口，使用组合而非继承

**问：在微服务架构中，外观模式如何应用？**

答：外观模式在微服务架构中的应用：
1. **API网关作为外观**：
   - API网关聚合多个微服务的调用，为客户端提供统一入口
   - 隐藏内部系统复杂性，简化客户端开发
   - 处理跨服务请求，减少客户端与服务间通信次数

2. **BFF（Backend For Frontend）模式**：
   - 为特定前端提供定制化的API外观
   - 聚合数据，减少前端请求次数
   - 处理前端特定需求，如数据转换、过滤

3. **服务聚合器**：
   - 组合多个微服务的结果
   - 处理复杂的业务流程
   - 实现数据转换和协议适配

4. **服务网关中的跨切面功能**：
   - 身份验证和授权
   - 速率限制
   - 请求/响应转换
   - 日志记录和监控
   - 错误处理

5. **微服务架构中外观模式的优势**：
   - 减少客户端与微服务直接交互的复杂性
   - 提供粗粒度API，降低网络调用次数
   - 隐藏内部服务实现细节和位置
   - 支持系统演化，服务可以独立更改

### 桥接模式
**问：桥接模式和策略模式有什么区别？**

答：桥接模式和策略模式的区别：
1. **意图不同**：
   - 桥接模式：将抽象部分与实现部分分离，使它们可以独立变化
   - 策略模式：定义一系列算法，使它们可以互相替换，且算法变化不影响客户端

2. **结构不同**：
   - 桥接模式：两个维度的类层次结构（抽象部分和实现部分）
   - 策略模式：单一维度的算法类层次结构

3. **关注点不同**：
   - 桥接模式：关注对象结构的组合和分离，强调两个变化维度
   - 策略模式：关注行为或算法的封装和替换，强调单一维度的多种实现

4. **关键区别**：
   - **维度**：桥接模式处理两个或多个维度的变化，策略模式处理单一维度的多种算法
   - **组合方式**：桥接模式通过组合连接两个不同的类层次结构，策略模式将算法封装在独立的类中
   - **扩展方向**：桥接模式可以在两个维度上独立扩展，策略模式主要在单一的算法维度上扩展
   - **客户端认知**：桥接模式中客户需要知道并选择抽象和实现的组合，策略模式中客户只需选择一种策略

**问：桥接模式如何解决多层继承的问题？**

答：桥接模式解决多层继承问题：
1. **多层继承导致的问题**：
   - **类爆炸问题**：当有多个变化维度时，继承层次呈指数级增长
   - **僵化设计**：难以添加新的实现或抽象
   - **紧耦合**：抽象与实现紧密绑定，难以独立变化
   - **功能重复**：子类中存在大量重复代码

2. **桥接模式解决多层继承问题的原理**：
   - **分离抽象与实现**：将问题分解为正交的维度（相互独立的变化方向）
   - **使用组合替代继承**：通过组合将多个维度关联起来，避免类层次的指数级增长
   - **独立扩展**：可以在不修改抽象层的情况下添加新实现，也可以在不影响实现层的情况下扩展抽象层

3. **类爆炸问题对比**：
   假设有3种形状和3种颜色：
   - **传统继承方式**：需要3×3=9个类
   - **桥接模式**：只需要3+3=6个类

**问：如何判断什么时候应该使用桥接模式而不是适配器模式？**

答：判断使用桥接模式还是适配器模式：
1. **设计意图不同**：
   - 桥接模式：预先设计，用于将抽象与实现分离，处理多维度变化
   - 适配器模式：事后补救，用于使不兼容的接口能够协同工作

2. **使用时机的关键判断点**：
   - **设计阶段 vs. 集成阶段**：
     - 系统设计初期考虑多维度变化 → 使用桥接模式
     - 已有系统中集成不兼容组件 → 使用适配器模式

   - **接口变化性质**：
     - 需要处理正交变化的多个维度 → 使用桥接模式
     - 需要转换一个接口为另一个接口 → 使用适配器模式

   - **设计自由度**：
     - 可以控制所有相关类的设计 → 考虑桥接模式
     - 要使用现有不可修改的类 → 使用适配器模式

3. **实际案例判断**：
   - 需要支持不同操作系统上的图形渲染 → 使用桥接模式
   - 需要集成第三方支付API到统一支付接口 → 使用适配器模式

### 组合模式
**问：组合模式和装饰器模式有什么区别？**

答：组合模式和装饰器模式的区别：
1. **核心意图不同**：
   - 组合模式：将对象组合成树形结构，统一处理个体和组合对象
   - 装饰器模式：动态地为对象添加额外职责，不改变接口

2. **结构差异**：
   - 组合模式：树形结构，包含一对多关系（组合节点包含多个子节点）
   - 装饰器模式：链式结构，包含一对一关系（装饰器包含一个被装饰对象）

3. **关注点不同**：
   - 组合模式：关注对象的结构组织和层次关系
   - 装饰器模式：关注对象功能的动态扩展

4. **递归组合特性**：
   - 组合模式：具备递归组合特性，可以无限嵌套同类型组件
   - 装饰器模式：强调功能叠加，不关注构建对象结构

**问：组合模式中的安全性和透明性有什么区别？如何选择？**

答：组合模式中的安全性和透明性：
1. **安全性组合模式**：
   - **定义**：组合节点和叶子节点具有不同接口，组件接口只定义共有操作
   - **特点**：叶子节点没有管理子节点的方法（如add, remove）
   - **优点**：类型安全，叶子节点不会被错误调用管理子节点的方法
   - **缺点**：客户端必须区分处理组合节点和叶子节点

2. **透明性组合模式**：
   - **定义**：组合节点和叶子节点共享相同接口，包括管理子节点的方法
   - **特点**：所有节点都有管理子节点的方法（叶子节点中为空实现）
   - **优点**：客户端无需区分组合节点和叶子节点
   - **缺点**：类型不安全，可能对叶子节点调用无意义的方法

3. **如何选择**：
   - **选择安全性的情况**：系统对类型安全要求高；客户端可以方便区分节点类型；叶子和组合节点功能差异明显
   - **选择透明性的情况**：客户端希望统一对待所有节点；组合结构复杂，难以区分节点类型；希望简化客户端代码

4. **折中方案**：
   - 在Component接口中定义子节点管理方法，但设为默认空实现
   - 使用默认方法或提供空实现，避免抛出异常
   - 使用Optional返回值表示可能的空操作

**问：如何在组合模式中处理不同类型的组件？**

答：处理组合模式中不同类型的组件有几种策略：
1. **类型安全的层次结构**：使用泛型参数限定组件类型
2. **访问者模式结合**：使用访问者模式处理不同类型组件的操作
3. **组合模式与桥接模式结合**：使用桥接模式处理多维度变化
4. **策略模式结合**：使用策略模式处理不同类型组件的行为变化
5. **动态类型检查**：使用instanceof进行类型检查并转换
6. **依赖注入处理器**：为不同类型组件注册专门的处理器
7. **命令模式分派**：为不同组件类型注册不同命令处理

最佳实践：
- 明确组件类型层次结构，使用接口表达通用行为
- 使用类型参数限定保证类型安全
- 结合其他模式处理不同类型组件
- 保持接口一致性，避免特殊情况处理

### 享元模式
**问：享元模式的内部状态和外部状态有什么区别？如何划分？**

答：享元模式中的内部状态和外部状态：
1. **内部状态（Intrinsic State）**：
   - 存储在享元对象内部
   - 可以被多个对象上下文共享
   - 独立于享元对象的使用场景
   - 通常不会改变

2. **外部状态（Extrinsic State）**：
   - 取决于享元对象的使用场景
   - 由客户端保存和传递
   - 不能被共享
   - 在不同情况下可能变化

3. **如何划分内部状态和外部状态**：
   - **判断标准**：
     - 数据是否随上下文变化？变化的是外部状态
     - 数据是否可以共享？可共享的是内部状态
     - 数据是否与特定对象实例相关？实例相关的是外部状态
     - 数据是否需要频繁修改？频繁修改的是外部状态

4. **常见的内部状态和外部状态例子**：
   - **文本编辑器中的字符**：
     - 内部状态：字符代码、字体类型
     - 外部状态：位置、大小、颜色
   - **游戏中的粒子系统**：
     - 内部状态：粒子纹理、粒子类型
     - 外部状态：位置、速度、存活时间、缩放

**问：享元模式与对象池模式有什么区别？**

答：享元模式与对象池模式的区别：
1. **核心意图不同**：
   - 享元模式：通过共享技术有效支持大量细粒度对象，主要目的是减少内存占用
   - 对象池模式：复用对象以减少对象创建和销毁的开销，主要目的是提高性能

2. **对象标识**：
   - 享元模式：对象由其内部状态唯一标识，具有相同内部状态的对象是同一个实例
   - 对象池模式：对象都是独立的实例，可以有完全相同的状态，按需分配与回收

3. **状态管理**：
   - 享元模式：将可变状态外部化，内部状态不变
   - 对象池模式：对象在回收前通常需要重置全部状态

4. **生命周期**：
   - 享元模式：享元对象一旦创建通常会一直存在，直到程序结束
   - 对象池模式：对象在使用和未使用之间转换，可能有闲置超时释放机制

5. **适用场景**：
   - 享元模式：当应用需要大量相似对象，且这些对象的部分状态可以共享时
   - 对象池模式：当对象创建成本高，且需要频繁创建和销毁对象时

**问：享元模式在Java中的典型应用有哪些？**

答：享元模式在Java中的典型应用：
1. **Java基础库中的应用**：
   - **Integer缓存**：Java会缓存-128到127之间的Integer对象
   - **Boolean对象**：Boolean.TRUE和Boolean.FALSE是预定义的享元实例
   - **字符串常量池**：相同字面量的字符串共享同一实例

2. **Java图形库中的应用**：
   - **Swing组件的UI委托**：所有JButton共享相同的BasicButtonUI实例
   - **字体和颜色对象**：相同字体和颜色被共享

3. **常见业务场景应用**：
   - **数据库连接池**：共享数据库连接
   - **线程池**：复用线程对象

4. **实际业务应用**：
   - **游戏开发中的粒子系统**：所有同类粒子共享纹理资源
   - **文本编辑器**：相同字符共享字形和字体信息
   - **地图应用**：共享地图图标和纹理
   - **电子商务**：共享产品描述、图片等静态信息

## 行为型模式

### 策略模式
**问：策略模式与简单工厂模式结合有什么好处？如何实现？**

答：策略模式与简单工厂模式结合的好处：
1. **封装创建逻辑**：客户端不需要知道具体策略类的实现细节
2. **简化客户端代码**：客户端只需知道策略名称或类型
3. **提高策略选择的灵活性**：可以基于参数动态选择策略
4. **减少依赖**：减少客户端对具体策略类的依赖

实现方法：
1. 定义策略接口
2. 实现具体策略类
3. 创建策略工厂，负责根据参数创建合适的策略
4. 上下文类使用工厂获取策略实例
5. 客户端只需与上下文和工厂交互，无需直接创建策略对象

高级实现可以：
- 使用反射动态创建策略
- 使用配置文件定义策略映射
- 缓存常用策略实例提高性能
- 支持策略的自动发现和注册

**问：策略模式和状态模式有什么区别？**

答：策略模式和状态模式的区别：
1. **核心意图不同**：
   - 策略模式：定义一系列算法，使它们可以相互替换，算法的变化独立于使用者
   - 状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类

2. **关注点不同**：
   - 策略模式：关注对算法的封装和灵活切换
   - 状态模式：关注对象状态的转换和状态相关行为的封装

3. **状态转换**：
   - 策略模式：通常不涉及状态转换，策略的切换由客户端控制
   - 状态模式：状态之间有明确的转换关系，状态自身知道如何切换到其他状态

4. **依赖关系**：
   - 策略模式：上下文不依赖于具体策略，策略之间相互独立
   - 状态模式：状态可能依赖于上下文或其他状态，状态之间可能有联系

5. **如何选择**：
   - 使用策略模式：当需要动态切换不同算法；有多种算法变体需要封装
   - 使用状态模式：当对象行为取决于其状态；存在多个状态转换逻辑；状态转换有特定规则

**问：如何避免策略模式带来的类爆炸问题？**

答：避免策略模式带来的类爆炸问题的方法：
1. **使用匿名内部类或Lambda表达式**（Java 8+）：
   - 为简单策略使用Lambda表达式，避免创建单独的类
   - 适用于策略逻辑简单的场景

2. **使用策略枚举**：
   - 在枚举中实现不同的策略
   - 减少类文件数量，提高代码组织性

3. **使用组合策略**：
   - 基于基本策略组件组合构建复杂策略
   - 避免为每种组合创建新类

4. **使用Map存储策略**：
   - 将策略存储在Map中，通过键获取
   - 适合策略可以用Lambda表示的场景

5. **使用工厂方法创建策略**：
   - 集中管理策略创建逻辑
   - 可以缓存常用策略实例

6. **策略参数化**：
   - 使用参数化的通用策略，通过不同参数实现不同行为
   - 减少相似策略类的数量

7. **使用反射自动发现策略**：
   - 通过注解或约定自动注册策略
   - 避免手动创建大量策略类引用

8. **使用配置驱动的策略**：
   - 通过配置文件定义策略行为
   - 适合策略行为频繁变化的场景

### 观察者模式
**问：观察者模式中如何避免通知风暴或循环通知？**

答：观察者模式中避免通知风暴或循环通知的方法：
1. **标记法防止循环**：
   - 使用标记变量追踪通知过程，防止重复通知
   - 在通知过程开始设置标记，结束后清除

2. **通知计数和阈值控制**：
   - 在特定时间窗口内限制通知次数
   - 超过阈值则暂停通知

3. **使用通知ID标识唯一通知**：
   - 为每个通知生成唯一ID
   - 标记观察者已处理的通知ID，避免重复处理

4. **通知队列与异步处理**：
   - 使用队列缓冲通知，异步处理
   - 避免递归调用，减少栈溢出风险

5. **弱引用存储观察者**：
   - 使用弱引用存储观察者，避免内存泄漏
   - 通知时检查观察者是否仍然有效

6. **层次结构中的通知追踪**：
   - 追踪通知路径，防止循环
   - 记录已通知的对象，避免重复通知

7. **版本或序列号机制**：
   - 使用递增的版本号，只处理更新的通知
   - 观察者记录最后处理的版本号

8. **使用有向图检测循环**：
   - 构建通知依赖图，检测循环
   - 发现循环时中断通知传播

**问：观察者模式与发布-订阅模式有什么区别？**

答：观察者模式与发布-订阅模式的区别：
1. **核心区别**：
   - **耦合度**：观察者模式中，观察者和被观察者直接耦合；发布-订阅模式中，发布者和订阅者完全解耦，通过中间的事件通道通信
   - **中间层**：观察者模式没有中间层，发布-订阅模式有事件通道/代理层
   - **通信方式**：观察者是直接通信，发布-订阅是间接通信

2. **主要区别总结**：

   | 特性       | 观察者模式             | 发布-订阅模式          |
   | ---------- | ---------------------- | ---------------------- |
   | 耦合度     | 直接耦合               | 完全解耦               |
   | 通信方式   | 同步直接通信           | 通常异步通过中间层     |
   | 了解对方   | 被观察者知道观察者     | 发布者不知道订阅者     |
   | 事件过滤   | 所有观察者收到相同通知 | 订阅者只收到订阅的事件 |
   | 实现复杂度 | 相对简单               | 较为复杂               |

3. **使用场景对比**：
   - **观察者模式适合**：组件间紧密协作；一对多依赖关系；单应用内的模块协作
   - **发布-订阅模式适合**：完全解耦的组件通信；跨应用系统集成；事件驱动架构；需要细粒度事件过滤

**问：如何实现线程安全的观察者模式？**

答：实现线程安全的观察者模式有以下几种方法：
1. **使用同步集合和同步方法**：
   - 使用线程安全的集合如CopyOnWriteArrayList存储观察者
   - 使用synchronized方法保护关键操作

2. **使用读写锁分离读写操作**：
   - 使用ReadWriteLock区分读写操作
   - 添加/移除观察者时获取写锁，通知时获取读锁

3. **使用CopyOnWriteArrayList**：
   - 专为并发遍历设计，在修改时复制整个集合
   - 适合读多写少的场景

4. **使用不可变集合和原子引用**：
   - 使用AtomicReference存储不可变的观察者集合
   - 修改时原子性地替换整个集合

5. **使用消息队列异步通知**：
   - 将通知事件放入队列，由专门线程处理
   - 避免在通知线程中执行耗时操作

6. **使用线程池并行通知**：
   - 使用线程池并行地通知多个观察者
   - 提高通知效率，减少阻塞

7. **使用Java的并发工具类**：
   - 使用ConcurrentHashMap管理观察者
   - 利用Java 8的并行流并行处理通知

8. **线程安全的观察者实现**：
   - 确保观察者自身的线程安全
   - 观察者方法内使用适当的同步机制

实现线程安全观察者模式的最佳实践：
- 根据场景选择合适的线程安全集合
- 通知时避免持有锁，先获取观察者列表副本再通知
- 处理观察者抛出的异常，避免影响其他观察者
- 考虑使用超时机制，避免观察者阻塞通知线程

### 命令模式
**问：命令模式如何实现撤销（Undo）和重做（Redo）功能？**

答：命令模式实现撤销(Undo)和重做(Redo)功能的方法：
1. **基本思路**：
   - 每个命令对象需要记住如何撤销自身效果
   - 使用两个栈分别存储已执行命令和已撤销命令
   - 执行命令时，将命令推入"已执行"栈
   - 撤销时，从"已执行"栈弹出命令并执行其撤销方法，然后推入"已撤销"栈
   - 重做时，从"已撤销"栈弹出命令并重新执行，然后推回"已执行"栈

2. **实现撤销功能的关键点**：
   - 命令需要存储足够信息以撤销操作
   - 命令应该是原子的，做单一操作便于撤销
   - 每个execute()方法都需要对应的undo()方法

3. **处理复杂情况**：
   - **批处理命令**：组合多个命令为一个宏命令，整体撤销
   - **不可撤销命令**：标记某些命令不可撤销，如保存文件
   - **状态快照**：对于复杂状态，可结合备忘录模式保存完整状态

4. **撤销/重做的高级功能**：
   - 支持有限历史记录
   - 实现事务性命令（全部成功或全部回滚）
   - 序列化命令历史，支持会话恢复
   - 版本控制或分支撤销

**问：命令模式如何支持事务和日志记录？**

答：命令模式支持事务和日志记录的实现方法：
1. **支持事务的命令模式实现**：
   - 创建事务命令接口，扩展基本命令接口
   - 事务命令包含begin()、commit()、rollback()方法
   - 事务命令内部维护子命令列表
   - 执行失败时自动回滚已执行的命令
   - 支持嵌套事务

2. **支持日志记录的命令实现**：
   - 使用装饰器模式为命令添加日志功能
   - 日志记录命令执行前后状态
   - 支持序列化命令对象，记录完整上下文
   - 实现命令回放功能，从日志重建操作

3. **日志记录的高级功能**：
   - 记录命令参数和时间戳
   - 支持系统崩溃后的恢复
   - 基于日志的审计跟踪
   - 事务边界的日志标记

4. **实际应用案例**：
   - 数据库事务管理
   - 文件系统操作的日志和恢复
   - 分布式系统的操作日志
   - 用户操作历史记录

**问：命令模式和策略模式有什么区别？如何选择？**

答：命令模式和策略模式的区别及选择指南：
1. **基本意图不同**：
   - **命令模式**：将请求封装为对象，使请求的发送者和接收者解耦，支持请求排队、日志和撤销
   - **策略模式**：定义一系列算法，封装每个算法，并使它们可互相替换，让算法独立于客户端

2. **关键特性对比**：

   | 特性       | 命令模式         | 策略模式             |
   | ---------- | ---------------- | -------------------- |
   | 主要目的   | 请求参数化       | 算法互换             |
   | 接收者     | 包含在命令中     | 无（由策略直接实现） |
   | 执行时机   | 可以延迟执行     | 通常立即执行         |
   | 历史记录   | 通常保存历史     | 通常不保存历史       |
   | 撤销/重做  | 支持             | 不支持               |
   | 事件队列   | 支持             | 不支持               |
   | 运行时替换 | 可以替换不同命令 | 可以替换不同策略     |

3. **如何选择**：
   - **使用命令模式的情况**：
     - 需要参数化对象的操作
     - 需要支持撤销、重做和日志记录
     - 需要将行为和触发者解耦
     - 需要支持事务操作

   - **使用策略模式的情况**：
     - 需要在运行时选择不同的算法
     - 需要避免大量的条件语句
     - 有多个可互换的算法实现
     - 算法与客户端解耦

4. **实际比较案例**：
   - 命令模式示例：文本编辑器的操作（剪切、粘贴、撤销）
   - 策略模式示例：不同的排序算法、支付方式选择

### 模板方法模式
**问：模板方法与策略模式有何不同？什么情况下选择模板方法而非策略模式？**

答：模板方法模式与策略模式的区别及选择标准：
1. **核心区别**：
   - **模板方法模式**：使用继承来改变算法的部分步骤
   - **策略模式**：使用组合来替换整个算法

2. **控制反转方向**：
   - **模板方法模式**：父类调用子类（父类定义算法骨架，子类实现细节）
   - **策略模式**：上下文调用策略（上下文使用策略接口，具体策略实现算法）

3. **何时选择模板方法**：
   - 算法的整体结构固定，只有部分
   - 算法的整体结构固定，只有部分步骤需要子类定制
   - 希望控制子类的扩展，只允许在特定点进行扩展
   - 避免子类重复代码，将公共代码放在父类中
   - 希望通过钩子方法让子类有选择性地改变算法的特定步骤

   4. **何时选择策略模式**：
      - 需要在运行时动态切换整个算法
      - 有许多独立的算法可以互相替换
      - 算法使用的数据不希望暴露给客户端
      - 希望避免使用条件语句选择行为变体

   5. **实现方式对比**：
      - 模板方法使用继承，子类覆盖父类中的抽象方法或钩子方法
      - 策略模式使用组合，通过不同的策略对象实现不同行为

   **问：模板方法模式中的钩子方法有什么作用？如何使用？**

   答：模板方法模式中的钩子方法：
   1. **钩子方法的定义**：
      - 在模板方法中定义的可选方法，提供默认实现
      - 子类可以选择性地覆盖，以改变算法的特定部分
      - 通常是具体方法而非抽象方法

   2. **钩子方法的作用**：
      - 提供子类的扩展点，实现算法的可选步骤
      - 控制算法的执行流程，如条件判断
      - 允许子类决定是否执行某些步骤
      - 提供对算法的"微调"能力，而非重大改变

   3. **钩子方法的类型**：
      - **空实现钩子**：父类中提供空实现，子类可以选择性覆盖
      - **条件钩子**：返回布尔值，决定模板方法中的条件分支
      - **操作钩子**：提供默认操作，子类可以扩展或替换
      - **回调钩子**：在特定点被模板方法调用，通知子类

   4. **钩子方法使用示例**：
      - 在数据处理前后添加验证或转换钩子
      - 在业务流程的关键点添加条件判断钩子
      - 在框架中提供生命周期钩子，如初始化前后

   **问：如何在模板方法模式中处理多变点？**

   答：在模板方法模式中处理多变点的方法：
   1. **分解成多个模板方法**：
      - 将一个复杂的算法分解成多个小的模板方法
      - 每个小模板方法处理一个变化点或相关的几个变化点
      - 提高代码清晰度和可维护性

   2. **使用组合模式与模板方法结合**：
      - 将某些变化点从继承体系中抽取出来
      - 使用组合模式组织多个变化点
      - 保持主算法结构在模板方法中

   3. **结合策略模式**：
      - 对于变化较大的算法步骤，使用策略模式
      - 模板方法定义算法骨架，部分步骤委托给策略对象
      - 既保持了算法框架的稳定，又提供了变化点的灵活性

   4. **使用函数对象或Lambda表达式**（现代语言）：
      - 将变化点设计为函数参数
      - 客户端传入具体实现，如Lambda表达式
      - 结合函数式编程思想提高灵活性

   5. **泛型参数化**：
      - 使用泛型定义模板方法类
      - 通过类型参数控制变化点的行为
      - 提供类型安全的扩展机制

   6. **使用装饰器模式扩展功能**：
      - 保持核心模板方法不变
      - 通过装饰器添加或修改部分行为
      - 允许动态组合不同功能

   ### 状态模式

   **问：状态模式和策略模式有什么区别？何时使用状态模式？**

   答：状态模式与策略模式的区别：
   1. **核心意图不同**：
      - 状态模式：让对象在内部状态改变时改变它的行为，对象看似改变了类
      - 策略模式：定义一系列算法，封装每个算法，使它们可互相替换

   2. **关键区别**：
      - **状态转换**：状态模式关注状态转换和状态相关行为，状态自己知道如何切换到其他状态；策略模式不涉及状态转换，策略切换由客户端控制
      - **关系结构**：状态模式的状态类通常引用上下文，可能触发状态转换；策略模式中策略类通常不引用或改变上下文
      - **对象数量**：状态模式通常每个上下文对象有自己的一组状态实例；策略模式通常所有上下文共享同一组策略实例

   3. **何时使用状态模式**：
      - 对象行为依赖于其内部状态，且需要随状态变化而变化
      - 有明确定义的状态和规则的状态转换图
      - 状态转换逻辑复杂，使用条件语句会导致代码难以维护
      - 需要将特定状态相关的行为局部化，而非分散在代码中
      - 状态转换有副作用，如需要执行额外操作

   4. **应用实例**：
      - 工作流状态管理（订单处理、审批流程）
      - 游戏角色状态（站立、行走、跳跃、攻击）
      - UI控件状态（正常、悬停、禁用、选中）
      - 网络连接状态管理
      - 电商订单状态流转

   **问：如何避免状态模式中的状态爆炸问题？**

   答：避免状态模式中的状态爆炸问题的方法：
   1. **状态分层**：
      - 将状态组织为层次结构，使用继承关系
      - 共享通用行为在基类状态中
      - 特殊行为在子类状态中实现

   2. **状态机框架**：
      - 使用专门的状态机框架处理复杂状态逻辑
      - 通过配置或DSL定义状态转换规则
      - 自动生成状态类或处理状态转换

   3. **组合状态**：
      - 将状态分解为多个正交维度
      - 使用组合模式组合多个简单状态
      - 避免为每种组合创建单独的类

   4. **状态共享**：
      - 将无状态的状态对象设计为单例
      - 多个上下文共享相同的状态实例
      - 减少状态对象的数量

   5. **使用枚举状态**：
      - 对于简单状态模式，使用枚举表示状态
      - 状态行为可以定义在枚举内部
      - 简化状态管理和转换

   6. **表驱动的状态转换**：
      - 使用转换表定义状态转换规则
      - 从配置或数据库加载状态转换矩阵
      - 避免硬编码的状态转换逻辑

   7. **部分状态模式**：
      - 只将关键状态或复杂状态作为对象
      - 简单状态可以用简单条件语句处理
      - 平衡设计复杂度和代码简洁性

   **问：如何在状态模式中实现历史状态和回退功能？**

   答：在状态模式中实现历史状态和回退功能的方法：
   1. **状态历史栈**：
      - 在上下文中维护一个状态历史栈
      - 每次状态转换前，将当前状态压入栈
      - 需要回退时，从栈中弹出并恢复状态

   2. **备忘录模式结合**：
      - 状态转换前创建状态备忘录
      - 备忘录包含状态的完整信息
      - 回退时使用备忘录恢复状态

   3. **命令模式结合**：
      - 将状态变化封装为命令对象
      - 命令对象包含执行和撤销逻辑
      - 使用命令模式的撤销机制实现回退

   4. **层次状态历史**：
      - 记录每个层次的历史状态
      - 支持局部或全局状态回退
      - 适用于复杂的嵌套状态机

   5. **有限历史与无限历史**：
      - 有限历史：只保留最近N个状态
      - 无限历史：保留所有状态转换记录
      - 根据内存和性能需求选择合适策略

   6. **历史状态的序列化**：
      - 支持历史状态的持久化存储
      - 允许跨会话的状态恢复
      - 适用于长时间运行的工作流

   7. **回退点标记**：
      - 允许用户或系统标记特定状态为回退点
      - 只能回退到指定的回退点
      - 减少存储开销和回退复杂度

   ### 责任链模式

   **问：责任链模式与装饰器模式有何区别？**

   答：责任链模式与装饰器模式的区别：
   1. **核心意图不同**：
      - 责任链模式：为请求创建一个接收者对象的链，沿链传递请求，直到有对象处理它
      - 装饰器模式：动态地给对象添加额外的职责，比子类更灵活的扩展功能

   2. **处理方式不同**：
      - 责任链模式：链上的每个处理者决定是否处理请求，若不处理则传给下一个，可能只有一个处理者处理请求
      - 装饰器模式：链上的每个装饰器都会处理请求，并传给下一个，通常所有装饰器都会执行

   3. **控制流不同**：
      - 责任链模式：处理者可以决定请求终止还是继续传递
      - 装饰器模式：装饰器通常不会打断控制流，而是添加行为后调用被装饰对象

   4. **目的不同**：
      - 责任链模式：分离请求发送者和接收者，让多个对象都有机会处理请求
      - 装饰器模式：在不修改类的基础上为对象添加功能，对象功能的增强

   5. **应用场景区别**：
      - 责任链适用于：请求处理者在运行时确定；多个对象可以处理同一请求；处理者集合可动态指定
      - 装饰器适用于：需要透明地扩展对象功能；需要动态组合多种功能

   **问：如何在责任链模式中处理请求的部分处理问题？**

   答：在责任链模式中处理请求的部分处理问题：
   1. **累积处理结果**：
      - 在请求对象中添加结果收集字段
      - 每个处理者处理后更新请求对象中的结果
      - 链结束后获取完整的处理结果

   2. **责任链与命令模式结合**：
      - 请求表示为命令对象
      - 每个处理者执行命令的一部分
      - 命令对象记录已处理和未处理的部分

   3. **处理者协作机制**：
      - 定义处理者之间的通信协议
      - 前一个处理者将部分结果传递给下一个处理者
      - 使用上下文对象在处理者间共享信息

   4. **部分处理标志**：
      - 在请求中添加处理状态标志
      - 处理者根据标志确定请求的处理阶段
      - 支持多阶段处理和分段处理

   5. **处理者能力声明**：
      - 处理者声明自己能处理的请求类型或部分
      - 责任链根据能力将请求路由到合适的处理者
      - 支持专业化处理和并行处理

   6. **过滤器责任链**：
      - 每个处理者作为过滤器处理请求的不同方面
      - 请求依次经过所有过滤器
      - 适用于请求预处理、转换、后处理等场景

   **问：纯责任链和不纯责任链有什么区别？**

   答：纯责任链和不纯责任链的区别：
   1. **定义区别**：
      - 纯责任链：请求要么被链上的某个处理者完全处理，要么不被处理
      - 不纯责任链：请求可能被链上多个处理者部分处理，多个处理者协作完成请求

   2. **请求传递方式**：
      - 纯责任链：处理者要么完全处理请求，要么完全不处理并传给下一个
      - 不纯责任链：处理者处理请求的一部分，然后总是传给下一个处理者

   3. **控制流特点**：
      - 纯责任链：处理完成后请求传递终止，类似"短路"操作
      - 不纯责任链：请求通常会流经整个链，类似"过滤器链"

   4. **处理结果**：
      - 纯责任链：只有一个处理者返回结果
      - 不纯责任链：多个处理者可能都对结果有贡献

   5. **适用场景**：
      - 纯责任链适用于：互斥处理场景，如异常处理、权限检查
      - 不纯责任链适用于：请求需要多重处理的场景，如过滤器、拦截器链

   6. **实现方式**：
      - 纯责任链：通常检查能否处理，若能则处理并返回，否则传递
      - 不纯责任链：总是处理自己能处理的部分，然后调用下一个处理者

   7. **框架示例**：
      - 纯责任链：JavaScript的事件冒泡（stopPropagation可终止传播）
      - 不纯责任链：Java Servlet过滤器链、Spring MVC拦截器

   ### 观察者模式

   **问：观察者模式与发布-订阅模式有什么区别？**

   答：观察者模式与发布-订阅模式的区别：
   1. **核心区别**：
      - **耦合度**：观察者模式中，观察者和被观察者之间是直接耦合的；而发布-订阅模式中，发布者和订阅者完全解耦，通过中间的事件通道通信
      - **中间层**：观察者模式没有中间层，而发布-订阅模式有一个事件通道/代理层
      - **通信方式**：观察者是直接通信，发布-订阅是间接通信

   2. **组件和角色**：
      - **观察者模式**：
        - Subject（被观察者/主题）：维护观察者列表，通知观察者
        - Observer（观察者）：接收通知并响应

      - **发布-订阅模式**：
        - Publisher（发布者）：产生事件并发布到事件通道
        - EventChannel/Broker（事件通道/代理）：接收和分发事件
        - Subscriber（订阅者）：订阅特定类型的事件并处理

   3. **了解对方**：
      - 观察者模式：被观察者知道它的观察者们（它维护观察者列表）
      - 发布-订阅模式：发布者不知道谁是订阅者，订阅者也不知道谁是发布者

   4. **使用场景对比**：
      - **观察者模式适合**：一个对象状态改变需通知其他对象；组件之间有明确的一对多依赖；单应用内的模块协作
      - **发布-订阅模式适合**：完全解耦的组件通信；跨应用或分布式系统集成；事件驱动架构；需要细粒度事件过滤

   **问：如何避免观察者模式中的内存泄露问题？**

   答：避免观察者模式中的内存泄露问题：
   1. **使用弱引用**：
      - 使用WeakReference存储观察者引用
      - 当观察者被垃圾回收时，弱引用自动失效
      - 定期清理已失效的弱引用

   2. **显式注销观察者**：
      - 提供明确的注册和注销方法
      - 观察者不再需要通知时主动调用注销方法
      - 在对象销毁时自动注销所有观察者

   3. **观察者生命周期管理**：
      - 将观察者生命周期与被观察者绑定
      - 被观察者销毁时自动清理所有观察者
      - 使用生命周期感知组件（如Android的LifecycleObserver）

   4. **使用事件总线或消息代理**：
      - 采用发布-订阅模式代替直接观察者模式
      - 使用事件总线管理订阅关系
      - 支持自动注销和清理功能

   5. **使用注解和AOP管理观察者**：
      - 使用注解标记观察者方法
      - 通过AOP自动管理观察者注册和注销
      - 减少手动管理的错误和遗漏

   6. **定期清理失效观察者**：
      - 定期检查观察者的有效性
      - 移除已不存在或不活动的观察者
      - 实现自动清理机制

   7. **使用标识符而非直接引用**：
      - 使用唯一标识符而非对象引用注册观察者
      - 通过查找表将标识符映射到实际观察者
      - 便于管理观察者生命周期

   **问：如何处理观察者模式中的并发问题？**

   答：处理观察者模式中的并发问题：
   1. **使用线程安全集合**：
      - 使用CopyOnWriteArrayList存储观察者
      - 读操作无锁，写操作创建新副本
      - 适合读多写少的场景

   2. **同步通知方法**：
      - 对添加、删除和通知方法进行同步
      - 使用synchronized或Lock保护观察者集合
      - 避免并发修改异常

   3. **复制观察者列表**：
      - 通知前复制观察者列表
      - 在复制的列表上遍历通知
      - 避免在通知过程中修改原列表引起的问题

   4. **异步通知**：
      - 将通知操作放入队列
      - 使用专门线程处理通知队列
      - 避免阻塞主线程

   5. **并行通知**：
      - 使用线程池并行通知多个观察者
      - 使用CountDownLatch等待所有通知完成
      - 提高通知效率

   6. **读写锁分离**：
      - 使用ReadWriteLock区分读写操作
      - 添加/删除观察者使用写锁
      - 通知观察者时使用读锁

   7. **避免在通知期间修改状态**：
      - 通知期间不要修改被观察者状态
      - 避免观察者回调中再触发通知
      - 防止递归通知和死循环

   8. **处理通知异常**：
      - 捕获并处理观察者抛出的异常
      - 避免一个观察者的异常影响其他观察者
      - 实现错误隔离和恢复机制

   ### 访问者模式

   **问：访问者模式适用于哪些场景？有什么局限性？**

   答：访问者模式的适用场景与局限性：
   1. **适用场景**：
      - 对象结构相对稳定，但需要经常添加新操作
      - 需要对一个复杂对象结构中的所有元素执行操作
      - 各元素类型不同，需要执行不同操作
      - 需要避免在元素类中添加与其核心职责无关的操作
      - 相关的操作需要集中管理，而非分散在各个元素类中

   2. **具体应用例子**：
      - 编译器中的AST（抽象语法树）处理
      - GUI组件树的操作（如文档转换、渲染）
      - 复杂的XML/JSON文档处理
      - 报表生成系统
      - 文件系统遍历处理

   3. **局限性**：
      - **破坏封装**：访问者需要访问元素的内部状态
      - **元素类层次固定**：添加新元素类型需要修改所有访问者
      - **难以添加新元素**：违反开闭原则（对元素的扩展）
      - **访问者与元素间的紧耦合**：访问者需要了解元素的具体类型
      - **复杂的双分派机制**：理解和维护较困难
      - **可能导致循环依赖**：访问者依赖元素，元素方法又接受访问者

   **问：如何在访问者模式中添加新的元素类型？**

   答：在访问者模式中添加新的元素类型：
   1. **传统方法（较为麻烦）**：
      - 在Visitor接口中添加新的visit方法以支持新元素类型
      - 修改所有现有的具体访问者实现以处理新元素
      - 创建新的元素类，实现accept方法
      - 在对象结构中加入新元素类型的支持

   2. **使用反射机制**：
      - 使用反射动态调用合适的visit方法
      - 访问者接口定义通用visit方法
      - 根据运行时类型选择合适的处理方法
      - 减少对访问者接口的修改

   3. **使用动态语言特性**：
      - 在支持动态分派的语言中使用duck typing
      - 根据元素提供的接口动态选择行为
      - 避免静态类型约束

   4. **使用Acyclic Visitor模式**：
      - 将访问者接口分解为多个独立接口
      - 具体访问者只实现关心的元素接口
      - 使用instanceof检查访问者支持的元素类型
      - 新元素只需添加新接口，不影响现有访问者

   5. **默认行为策略**：
      - 为新元素提供默认访问行为
      - 老访问者使用默认处理逻辑
      - 新访问者可以提供专门实现

   6. **组合访问者模式**：
      - 使用组合模式构建访问者
      - 将复杂访问者分解为多个简单访问者
      - 新元素只需添加相关访问者组件

   **问：访问者模式和迭代器模式如何结合使用？**

   答：访问者模式和迭代器模式结合使用：
   1. **结合目的**：
      - 迭代器提供遍历对象结构的机制
      - 访问者提供对元素操作的封装
      - 结合使用可以优雅地遍历复杂结构并执行操作

   2. **实现方式**：
      - 对象结构提供迭代器方法返回元素迭代器
      - 客户端使用迭代器遍历元素
      - 对每个元素应用访问者
      - 避免在对象结构中硬编码遍历算法

   3. **优势**：
      - 分离遍历算法和元素操作
      - 支持不同的遍历策略（深度优先、广度优先等）
      - 提高代码复用性和灵活性
      - 遵循单一职责原则

   4. **应用场景**：
      - 复杂树形结构处理
      - XML/JSON文档的遍历和转换
      - 复合对象的深度处理
      - 图形界面组件树的操作

   5. **示例场景**：
      - 文件系统遍历并处理不同类型文件
      - HTML DOM树遍历并应用不同样式转换
      - 企业组织架构遍历并生成不同报表

   ### 中介者模式

   **问：中介者模式和观察者模式有什么区别？如何选择？**

   答：中介者模式和观察者模式的区别与选择：
   1. **核心区别**：
      - 中介者模式：封装一组对象如何交互，所有通信都通过中介者对象
      - 观察者模式：定义对象间一对多的依赖，当一个对象状态变化时自动通知其依赖者

   2. **通信结构**：
      - 中介者模式：多对一对多（组件 → 中介者 → 组件）
      - 观察者模式：一对多（主题 → 多个观察者）

   3. **组件关系**：
      - 中介者模式：组件间完全解耦，但都依赖中介者
      - 观察者模式：主题和观察者之间存在直接关系

   4. **通信方向**：
      - 中介者模式：双向通信，组件可以发送和接收消息
      - 观察者模式：单向通信，主题向观察者发送通知

   5. **用途区别**：
      - 中介者模式：简化复杂的多对多关系，集中管理交互逻辑
      - 观察者模式：实现事件驱动的通知机制，主题状态变化时通知观察者

   6. **何时选择中介者模式**：
      - 一组对象以复杂但定义明确的方式通信
      - 对象间的交互逻辑复杂且难以维护
      - 希望集中控制对象间的通信
      - 对象间的多对多关系导致系统难以理解和维护
      - 需要复用组件但不复用它们的交互

   7. **何时选择观察者模式**：
      - 需要一对多的依赖关系，一个对象变化会影响多个对象
      - 主题不需要知道观察者的具体类
      - 需要动态添加和移除观察关系
      - 需要事件驱动的系统设计
      - 状态变化需要通知多个独立对象

   **问：如何避免中介者模式中中介者类变得过于复杂？**

   答：避免中介者模式中中介者类变得过于复杂：
   1. **将中介者分解为多个专门的中介者**：
      - 基于功能或组件组划分中介者职责
      - 每个中介者处理相关组件子集的交互
      - 中介者之间可以组成层次结构

   2. **使用组合模式构建中介者**：
      - 将中介者功能分解为独立组件
      - 使用组合模式组织多个小型中介者
      - 通过组合而非继承扩展中介者功能

   3. **使用命令模式处理交互逻辑**：
      - 将组件交互封装为命令对象
      - 中介者负责调度和执行命令
      - 分离交互逻辑和中介者核心逻辑

   4. **引入中介者协议**：
      - 定义标准化的消息格式和协议
      - 组件通过消息与中介者通信
      - 简化中介者的消息处理逻辑

   5. **使用事件处理机制**：
      - 基于事件和监听器模式实现中介者
      - 组件发布事件，中介者订阅并处理
      - 利用现有事件框架简化实现

   6. **应用责任链模式处理请求**：
      - 将复杂处理逻辑组织为责任链
      - 中介者将请求委托给责任链处理
      - 简化中介者的决策逻辑

   7. **使用状态模式管理中介者状态**：
      - 将中介者的不同状态封装为状态对象
      - 根据当前状态委托处理组件交互
      - 避免复杂的状态判断逻辑

   **问：中介者模式在前端框架中的应用有哪些？**

   答：中介者模式在前端框架中的应用：
   1. **前端框架中的应用场景**：
      - 组件通信机制
      - 状态管理
      - 事件总线
      - 路由管理
      - 表单验证协调

   2. **Vue.js中的应用**：
      - Vuex作为状态管理中介者，协调组件间的数据共享
      - EventBus实现非父子组件通信
      - Vue Router作为视图导航的中介者
      - 父组件作为子组件间通信的中介者
      - provide/inject API提供依赖注入的中介机制

   3. **React中的应用**：
      - Redux/Context API作为状态管理中介者
      - 高阶组件(HOC)作为功能组件间的中介者
      - React Router统一管理路由状态和导航
      - 容器组件作为展示组件的中介者
      - 自定义Hooks封装跨组件通信逻辑

   4. **Angular中的应用**：
      - 服务(Service)作为组件间的中介者
      - NgRx作为状态管理中介者
      - 路由模块(Router Module)管理视图导航
      - Subject/Observable提供响应式通信机制
      - 父组件协调子组件间的通信

   5. **具体实现示例**：
      - 表单验证中，FormValidator作为中介者协调多个输入字段的验证
      - 拖放操作中，DragDropManager作为中介者处理源和目标元素的交互
      - 游戏开发中，GameController作为游戏对象交互的中介者
      - 聊天应用中，ChatRoom作为用户间通信的中介者
      - 数据可视化中，ChartCoordinator协调图表组件的交互和联动

   ## 设计模式通用问题

   **问：如何选择合适的设计模式？有什么判断标准？**

   答：选择合适的设计模式的判断标准：
   1. **根据问题特征识别模式**：
      - 创建对象问题：考虑创建型模式（工厂、单例、原型等）
      - 对象组织结构问题：考虑结构型模式（组合、装饰、适配器等）
      - 对象交互问题：考虑行为型模式（观察者、策略、命令等）

   2. **考虑变化点**：
      - 分析系统中可能变化的部分
      - 选择能隔离这些变化的模式
      - 遵循"封装变化"的原则

   3. **评估模式适用性**：
      - 模式解决的问题是否与当前问题匹配
      - 模式的结构是否适合当前系统架构
      - 模式的限制和副作用是否可接受

   4. **考虑系统上下文**：
      - 当前系统架构和设计风格
      - 团队熟悉度和技术能力
      - 性能和资源限制
      - 开发时间和维护成本

   5. **考虑模式组合**：
      - 单一模式可能不足以解决复杂问题
      - 考虑多种模式组合使用
      - 评估模式间的互补性和兼容性

   6. **遵循设计原则**：
      - SOLID原则（单一职责、开闭原则、里氏替换、接口隔离、依赖倒置）
      - DRY（不要重复自己）
      - KISS（保持简单）
      - YAGNI（你不会需要它）

   7. **实用主义判断**：
      - 不要为使用模式而使用模式
      - 从简单解决方案开始，在需要时引入模式
      - 模式应该减少而非增加复杂性
      - 考虑实际收益与实现成本的比例

   **问：如何在设计模式之间进行权衡？**

   答：设计模式之间的权衡考量：
   1. **复杂性与灵活性权衡**：
      - 更复杂的模式通常提供更多灵活性
      - 评估当前需要的灵活性程度和未来变化可能性
      - 例如：简单工厂vs抽象工厂，装饰器vs策略

   2. **性能与可扩展性权衡**：
      - 某些模式可能引入性能开销（如代理模式、责任链）
      - 评估性能要求与可扩展性需求的优先级
      - 例如：享元模式（内存优化）vs原型模式（快速克隆）

   3. **耦合度与可测试性权衡**：
      - 降低耦合可能增加类的数量和系统复杂度
      - 权衡组件间独立性与系统整体复杂度
      - 例如：中介者（集中式）vs观察者（分布式）

   4. **代码量与可维护性权衡**：
      - 某些模式可能增加代码量但提高可维护性
      - 评估开发时间与长期维护成本
      - 例如：命令模式（增加代码量但支持撤销）

   5. **抽象层级与学习曲线权衡**：
      - 高抽象度模式可能增加理解难度
      - 考虑团队经验和项目周期
      - 例如：简单策略实现vs完整策略模式

   6. **特定模式权衡示例**：
      - **单例vs依赖注入**：全局访问便利性vs测试难度
      - **继承vs组合**：代码复用简便性vs系统灵活性
      - **命令vs策略**：操作历史和撤销vs简单算法替换
      - **中介者vs观察者**：集中控制vs事件驱动

   7. **情境考虑因素**：
      - 团队规模和经验
      - 项目生命周期和维护期望
      - 业务领域特性和变化频率
      - 技术栈和框架限制

   **问：如何避免设计模式的滥用？**

   答：避免设计模式滥用的方法：
   1. **从简单解决方案开始**：
      - 先考虑最简单直接的解决方案
      - 仅在简单方案不足时引入设计模式
      - 遵循YAGNI（"你不会需要它"）原则

   2. **明确问题再应用模式**：
      - 首先明确定义问题和需求
      - 确认选择的模式确实解决了特定问题
      - 避免"手里有把锤子，看什么都是钉子"的思维

   3. **考虑成本与收益**：
      - 评估模式带来的复杂性是否值得
      - 考虑模式实现成本与实际收益
      - 权衡短期开发时间与长期维护成本

   4. **认识过度设计的信号**：
      - 代码复杂度远超问题复杂度
      - 大量"以后可能需要"的灵活性设计
      - 团队成员难以理解设计意图
      - 简单功能需要了解多个类才能理解

   5. **寻求同行评审**：
      - 设计决策通过团队评审
      - 解释设计模式使用理由并接受质疑
      - 鼓励团队成员提出更简单的替代方案

   6. **逐步引入模式**：
      - 在系统演进过程中逐步引入模式
      - 基于实际需求而非预测性需求引入模式
      - 使用重构安全地引入设计模式

   7. **了解模式的局限性**：
      - 理解每种模式的缺点和使用成本
      - 知道什么时候不应该使用特定模式
      - 了解模式在特定语言和环境中的适用性

   8. **警惕的具体情况**：
      - 为每个类都创建接口
      - 过早抽象和过度泛化
      - 在不需要变化时使用策略模式
      - 为单一用途创建工厂
      - 过度使用单例代替依赖注入
      - 在简单调用链上使用命令模式

   **问：设计模式如何适应现代编程语言和范式？**

   答：设计模式适应现代编程语言和范式的方式：
   1. **函数式编程的影响**：
      - 使用高阶函数替代策略模式
      - 使用纯函数和不可变数据结构减少状态模式需求
      - 使用函数组合替代装饰器模式
      - 使用函数式响应编程(FRP)替代观察者模式

   2. **语言特性对模式的影响**：
      - **Lambda表达式**：简化命令、策略、观察者等模式实现
      - **类型推断**：减少工厂模式的必要性
      - **默认方法**：简化模板方法模式
      - **扩展方法**：提供装饰器模式的替代方案
      - **模式匹配**：简化访问者和状态模式

   3. **现代语言中的模式实现简化**：
      - **Kotlin的数据类**简化建造者模式
      - **Swift的协议扩展**简化适配器模式
      - **TypeScript的装饰器**简化装饰器和观察者模式
      - **Python的魔术方法**简化代理模式

   4. **响应式编程对模式的影响**：
      - 使用Observable替代传统观察者模式
      - 使用反应流简化责任链模式
      - 使用响应式状态管理替代中介者模式

   5. **依赖注入和IoC容器的影响**：
      - 减少工厂模式和单例模式的使用
      - 提供更灵活的对象组合方式
      - 简化组件间依赖管理

   6. **并发和异步编程的考量**：
      - 线程安全设计模式的重要性增加
      - 使用Actor模型替代某些并发设计模式
      - 异步模式和Promise/Future简化回调结构

   7. **微服务和分布式系统的适应**：
      - 服务发现替代部分工厂模式功能
      - API网关实现外观模式
      - 事件驱动架构体现观察者/发布-订阅模式
      - 断路器模式成为核心分布式设计模式

   8. **模式的演化与新模式**：
      - 传统模式根据新语言特性进行调整
      - 新的架构模式出现（如CQRS、Event Sourcing）
      - 领域特定模式的发展（微服务模式、云设计模式）