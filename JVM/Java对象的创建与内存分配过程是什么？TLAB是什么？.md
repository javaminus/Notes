# Java对象的创建与内存分配过程，TLAB 详解

## 1. 对象创建的五个步骤（以 HotSpot 为例）

1. **类加载检查和初始化**  
   - JVM 确认类已加载、验证、准备、解析并初始化（执行 `<clinit>` 静态代码块）。
2. **分配内存**  
   - 优先在 Eden 区分配（新生代），大对象或特殊情况直接分配到老年代。
   - 内存分配策略有三种：指针碰撞、空闲列表、TLAB（Thread-Local Allocation Buffer）。
3. **设置对象头**  
   - 包括 Mark Word（锁状态、hashCode、对象年龄等）和类型指针（指向 Klass 元数据）。
4. **零初始化**  
   - JVM 会将对象的内存块归零，提高安全性和一致性，有的平台可用 mmap 优化。
5. **执行构造函数**  
   - 执行父类构造器、实例初始化块、以及用户自定义构造代码。

---

## 2. 内存分配策略

- **指针碰撞（Bump-Pointer）**  
  - Eden 区为连续空间时，分配对象只需移动指针，速度极快。
- **空闲列表（Free-List）**  
  - 空间有碎片时，用链表管理空闲块，分配时查找合适块，常见于老年代。
- **TLAB（Thread-Local Allocation Buffer）**  
  - 每个线程在 Eden 预分配一小块缓冲区，线程内对象分配无需加锁，极大减少多线程竞争，提高分配吞吐量。
  - TLAB 用尽后向 Eden 申请新 Buffer，或回退到全局分配。

---

## 3. 大对象直接晋升

- 大对象（如数组、长字符串）如果超过 `PretenureSizeThreshold`，会直接分配到老年代。
- 避免大对象在新生代频繁复制，减少 GC 压力。

---

## 4. 并发分配与 Cache 行对齐

- HotSpot 为每个 TLAB 做 Cache 行/页对齐，降低 False Sharing 风险。
- 多线程环境中，TLAB 提升分配效率，减少锁和同步开销。

---

## 5. 面试常见追问及答案

### Q1. 什么情况下会发生失败分配？如何处理？
**A:**  
- Eden 或老年代空间不足时，分配失败，JVM 会尝试 Minor GC、Full GC；如果仍无空间则抛出 OOM（OutOfMemoryError）。

### Q2. G1/ZGC 下对象分配有什么不同？
**A:**  
- G1/ZGC 等新生代、老年代不是物理隔离而是逻辑分区。分配策略会根据区域可用情况动态调整，但 TLAB 机制依然存在。
- ZGC 的分配更强调并发和低延迟，对象分配和回收不再完全依赖于传统 Eden/老年代模型。

### Q3. 如何调优 TLAB 大小？
**A:**  
- JVM 参数 `-XX:+UseTLAB` 控制是否启用 TLAB。
- `-XX:TLABSize`, `-XX:TLABWasteTargetPercent`, `-XX:TLABSizeSlackPercent` 可调节 TLAB 大小和利用率。
- 一般无需手动调优，JVM 会根据负载自适应调整。

### Q4. TLAB 有什么弊端？
**A:**  
- 线程分配对象非常快，但 TLAB 可能存在一定的空间浪费（剩余块过小无法分配时会提前申请新 TLAB）。
- 在对象生命周期极短或线程频繁切换的场景下，TLAB 带来的优势会减弱。

### Q5. 如何判断我的应用是否使用了 TLAB？
**A:**  
- 默认开启，可通过 JVM 日志参数 `-XX:+PrintTLAB` 查看 TLAB 分配情况。

---

## 小结/复习提示词

- 步骤：加载→分配（Eden/老年代/TLAB）→设头→归零→构造
- TLAB：线程本地分配，减少竞争，高并发下显著提升分配效率
- 大对象：直接晋升老年代，减少新生代复制
- 复习口诀：“TLAB 本地分配，Eden 碰撞快，老年代晋升慎”

---