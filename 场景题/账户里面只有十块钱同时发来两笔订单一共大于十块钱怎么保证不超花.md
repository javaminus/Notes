# 如何保证账户余额不被超花（高并发防止超卖）

## 问题场景

- 账户余额只有10元
- 同时来了两笔订单，总金额大于10元
- 如何保证不会出现“余额变负数”或者“超花”？

---

## 方案一：分布式锁（悲观锁）🔒

- 在操作账户余额前，对账户加分布式锁（如 Redis/数据库锁）
- 只有获得锁的线程可以查询和扣减余额
- 其他线程等待锁释放
- **适用场景**：并发量不高，简单易实现
- **缺点**：加锁导致并发度低，影响吞吐量

---

## 方案二：数据库乐观锁（推荐）🛡️

- 直接用一条 SQL 实现扣减和判断原子性

```sql
UPDATE account SET balance = balance - #{amount}
WHERE user_id = #{userId} AND balance >= #{amount}
```

- 执行结果：
  - 更新成功（影响行数为1）：说明余额充足，扣减成功
  - 失败（影响行数为0）：余额不足，扣减失败
- **优点**：高并发时，天然排队且无锁等待，效率高
- **缺点**：热点数据行高并发下会有 MySQL 热点更新瓶颈

---

## 方案三：Redis原子扣减（高并发场景）🚦

- 利用 Redis 的原子性和 Lua 脚本
- 脚本中判断余额是否足够再扣减

```lua
local key = KEYS[1] -- 账户的键名
local amount = tonumber(ARGV[1]) -- 扣减的金额
local balance = tonumber(redis.call('get', key))
if balance >= amount then
    redis.call('decrby', key, amount)
    return redis.call('get', key)
else
    return "INSUFFICIENT BALANCE"
end
```

- **优点**：极高并发性能，天然串行
- **缺点**：需要解决 Redis 和数据库余额一致性问题（常用MQ异步同步+对账）

---

## 总结对比表

| 方案          | 并发能力 | 实现复杂度 | 一致性 | 推荐场景             |
| ------------- | -------- | ---------- | ------ | -------------------- |
| 分布式锁      | 低       | 简单       | 强     | 中低并发             |
| 数据库乐观锁  | 中高     | 简单       | 强     | 常规业务推荐         |
| Redis原子扣减 | 极高     | 复杂       | 需保障 | 超高并发、分布式场景 |

---

## 结论

- **核心**：必须让扣减余额的操作具备原子性，避免并发下重复扣减
- **生产常用**：乐观锁SQL or Redis原子扣减+一致性补偿
- **切忌**：不要用“查余额-扣减余额”两个分步操作，否则一定会超花

---