这是 Java 设计的一个语法和语义约束，主要原因如下：

**1. Lambda 捕获的局部变量本质上是只读的快照**
- Lambda 表达式可以访问方法中的局部变量，但这些变量在 Lambda 内部其实是“被复制”的。
- 如果允许在 Lambda 内部修改这些变量，容易导致数据不一致或并发问题。

**2. Java 实现机制决定**
- Java 的 Lambda，其实是编译器自动生成一个内部类（或类似机制），并把用到的局部变量以“快照”的方式传递进去。
- 局部变量本身存储在栈上，Lambda 可能会在方法执行结束后才执行（如在多线程场景），此时原变量已销毁，如果 Lambda 能修改原变量，就会有不可预料的后果。

**3. final 或 “effectively final” 的意义**
- 只有 final 或“实际上未改变过值”（effectively final）的局部变量，才能保证 Lambda 捕获的是稳定、不会被其他代码修改的值。
- 这样才能保证 Lambda 内部用到的变量值是确定的，避免潜在的线程安全和一致性问题。

---

### 举例说明

```java
public void test() {
    int num = 10; // 这里num必须是final或effectively final
    Runnable r = () -> {
        System.out.println(num); // 只能读取，不能修改num
    };
    // num = 20; // 这行如果取消注释，会编译报错
}
```

**只要 Lambda 用到的局部变量没有被修改过（即“实际上是final”），编译器会自动处理。否则会报错。**

---

### 总结一句话（面试用）：
> Java 的 Lambda 表达式只能使用 final 或 effectively final 的局部变量，是因为它捕获的是变量的快照，而不是变量本身，保证了变量的不可变性和线程安全，避免了数据不一致的问题。

如有需要深入底层实现细节，可以继续问我！