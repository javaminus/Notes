##JVM工具使用

```java
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) throws Exception {
        System.out.println("Java问题排查Demo开始，输入你想模拟的问题类型：");
        System.out.println("1. 高CPU线程");
        System.out.println("2. 内存泄漏");
        System.out.println("3. 死锁");
        System.out.println("4. 文件句柄泄漏");
        System.out.print("请输入选项编号(可多选,用逗号分隔)：");

        Scanner sc = new Scanner(System.in);
        String input = sc.nextLine();
        String[] options = input.split(",");

        for (String op : options) {
            switch (op.trim()) {
                case "1":
                    simulateHighCpu();
                    break;
                case "2":
                    simulateMemoryLeak();
                    break;
                case "3":
                    simulateDeadlock();
                    break;
                case "4":
                    simulateFileLeak();
                    break;
                default:
                    System.out.println("未知选项: " + op);
            }
        }
        System.out.println("模拟已启动，可用top、jps、jstat、jstack等工具排查。");
    }

    // 1. 高CPU线程
    private static void simulateHighCpu() {
        Thread t = new Thread(() -> {
            while (true) {} // 死循环
        }, "HighCpuThread");
        t.start();
        System.out.println("已启动高CPU线程：" + t.getName());
    }

    // 2. 内存泄漏
    private static void simulateMemoryLeak() {
        List<byte[]> leakList = new ArrayList<>();
        Thread t = new Thread(() -> {
            while (true) {
                leakList.add(new byte[1024 * 1024]); // 每次加1MB
                try { Thread.sleep(100); } catch (InterruptedException ignored) {}
            }
        }, "MemoryLeakThread");
        t.setDaemon(true);
        t.start();
        System.out.println("已启动内存泄漏线程：" + t.getName());
    }

    // 3. 死锁
    private static void simulateDeadlock() {
        final Object lock1 = new Object();
        final Object lock2 = new Object();
        Thread t1 = new Thread(() -> {
            synchronized (lock1) {
                try { Thread.sleep(100); } catch (InterruptedException ignored) {}
                synchronized (lock2) {}
            }
        }, "DeadlockThread-1");
        Thread t2 = new Thread(() -> {
            synchronized (lock2) {
                try { Thread.sleep(100); } catch (InterruptedException ignored) {}
                synchronized (lock1) {}
            }
        }, "DeadlockThread-2");
        t1.start();
        t2.start();
        System.out.println("已启动死锁线程：" + t1.getName() + ", " + t2.getName());
    }

    // 4. 文件句柄泄漏
    private static void simulateFileLeak() {
        Thread t = new Thread(() -> {
            int count = 0;
            while (true) {
                try {
                    // 不关闭文件，模拟句柄泄漏
                    new FileInputStream("/dev/null");
                    count++;
                    if (count % 1000 == 0) {
                        System.out.println("已打开文件句柄数：" + count);
                    }
                } catch (IOException e) {
                    System.err.println("打开文件失败: " + e.getMessage());
                    break;
                }
            }
        }, "FileLeakThread");
        t.setDaemon(true);
        t.start();
        System.out.println("已启动文件句柄泄漏线程：" + t.getName());
    }
}
```



```
jps // 查看所有Java进程及其PID
选择目标Java进程PID

jstat -gc PID // 查看当前GC/内存统计  jstat -gc <pid> 1000 —— 每秒输出一次，才是“实时监控”效果。
IF YGC/FGC异常频繁 或 Heap使用率高:
    说明存在内存泄漏或GC压力大
    jmap -heap PID // 查看堆内存详细分布与GC算法
    jmap -histo:live PID // 查看堆中存活对象数量与占用
    IF 某些对象数量/内存占用异常高:
        jmap -dump:live,format=b,file=heap.bin PID // 导出堆dump文件
        使用MAT/VisualVM分析heap.bin，定位内存泄漏或大对象
    ENDIF
ENDIF

jstat -gcutil PID // 观察GC各区利用率
IF Old区利用率持续高 或频繁FullGC:
    进一步分析堆外内存与GC原因
ENDIF

top/htop // 查看CPU占用
IF Java进程CPU异常高:
    jstack PID // 导出所有线程堆栈
    分析高CPU线程ID（top -H -p PID），用jstack查找对应线程栈
    定位死循环、死锁或热点方法
END

lsof -p PID // 查看文件句柄数
IF 文件句柄数异常高:
    检查是否有句柄泄漏
ENDIF

IF 需要进一步确认类加载/卸载等信息:
    jcmd PID VM.classloaders // 查看类加载器信息
    jcmd PID GC.heap_info    // 查询堆信息
ENDIF

记录排查过程，形成结论，准备修复方案
```

###执行`jstat -gc pid`打印的数据

```
S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   
15872.0 15872.0  0.0    0.0   98304.0  13763.8   261120.0     0.0     4480.0 778.0  384.0   76.6       0    0.000   0      0.000    0.000
```

 **逐项含义举例：**

- S0C/S1C = 15872 KB：两个Survivor区各16MB
- S0U/S1U = 0 KB：两个Survivor区都没用
- EC = 98304 KB：Eden区总容量96MB
- EU = 13763.8 KB：Eden区已用13.4MB
- OC = 261120 KB：Old区总容量255MB
- OU = 0 KB：Old区已用0MB
- MC = 4480 KB：Metaspace总容量4.4MB
- MU = 778 KB：Metaspace已用0.76MB
- CCSC/CCSU = 384 KB/76.6 KB：压缩类空间总容量/已用
- YGC = 0：年轻代GC次数为0
- YGCT = 0.000：年轻代GC总时长0
- FGC = 0：Full GC次数为0
- FGCT = 0.000：Full GC总时长0
- GCT = 0.000：GC总时长0

### 执行jmap -heap PID

下面是 `jmap -heap <PID>` 命令在典型 Java 8 HotSpot 虚拟机上的输出样例（部分内容，格式和字段在不同JVM版本可能略有差异，仅供参考）：

```
Attaching to process ID 12345, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.211-b12

using parallel gc algorithm

Heap Configuration:
   MinHeapFreeRatio         = 0
   MaxHeapFreeRatio         = 100
   MaxHeapSize              = 2147483648 (2048.0MB)
   NewSize                  = 4456448 (4.25MB)
   MaxNewSize               = 715653120 (682.5MB)
   OldSize                  = 8912896 (8.5MB)
   NewRatio                 = 2
   SurvivorRatio            = 8
   MetaspaceSize            = 21807104 (20.796875MB)
   CompressedClassSpaceSize = 1073741824 (1024.0MB)
   MaxMetaspaceSize         = 17592186044415 MB
   G1HeapRegionSize         = 0 (0.0MB)

Heap Usage:
PS Young Generation
Eden Space:
   capacity = 22020096 (21.0MB)
   used     = 1048576 (1.0MB)
   free     = 20971520 (20.0MB)
   4.761904761904762% used
From Space:
   capacity = 1048576 (1.0MB)
   used     = 0 (0.0MB)
   free     = 1048576 (1.0MB)
   0.0% used
To Space:
   capacity = 1048576 (1.0MB)
   used     = 0 (0.0MB)
   free     = 1048576 (1.0MB)
   0.0% used
PS Old Generation
   capacity = 49283072 (47.0MB)
   used     = 10485760 (10.0MB)
   free     = 38797312 (37.0MB)
   21.27970297029703% used

2089 interned Strings occupying 184600 bytes.

Metaspace
   used      = 3836544 (3.66MB)
   capacity  = 4460544 (4.25MB)
   committed = 4456448 (4.25MB)
   reserved  = 105381888 (100.56MB)
```

**说明：**
- “Heap Configuration” 显示堆相关的配置信息
- “Heap Usage” 分别显示新生代（Young Generation）、老年代（Old Generation）、元空间（Metaspace）的容量和使用情况
- “interned Strings” 表示常量池字符串占用
- 不同垃圾回收器（如G1、CMS）字段略有不同

如需特定JVM版本或GC类型的样例，请补充说明！

### 执行`jmap -histo:live PID`

执行 `jmap -histo:live <PID>` 命令时，控制台会打印**JVM 进程（由 PID 指定）当前存活对象的堆直方图（Histogram）**，内容为**所有类的实例个数、总大小**的统计信息。  
如果加上 `:live`，只统计**仍然存活的对象**（即已做一次 Minor GC 后仍在堆中的对象）。

**输出内容格式**

输出内容通常如下所示：

```
 num     #instances         #bytes  class name
----------------------------------------------
   1:         21288        3272000  [B
   2:         15642        1945328  [C
   3:         20152         644864  java.lang.String
   4:          9842         315904  java.util.HashMap$Node
   5:          8176         261632  java.lang.Integer
   6:          6144         196608  [I
   7:          5123         164736  java.lang.Object
   8:          2048          65536  java.util.ArrayList
   ...
Total        834567       13245678
```

**字段说明**

- **num**：排序编号，按内存占用从高到低
- **#instances**：该类的对象实例数
- **#bytes**：该类对象占用的总字节数
- **class name**：类的全限定名（比如 `[B` 表示 byte[]，`[C` 表示 char[]）

**最后一行是所有对象的总数和总占用内存**

---

**典型用途**

- 排查内存泄漏（可看到哪类对象占用最多内存）
- 分析应用运行期间对象分布情况

---

如果你需要某类型对象的详细分布，或者需要对比多次快照，可以多次执行该命令，或将结果保存到文件中分析。

### jstat -gcutil PID

`jstat -gcutil <PID>` 命令用于显示 JVM 进程（由 `<PID>` 指定）**各个内存区域的使用率和垃圾回收统计信息**。它会以表格形式定期输出当前内存使用和 GC 次数等信息，非常适合实时监控 JVM 的 GC 行为和堆内存变化。 

```
  S0     S1     E      O      M     CCS    YGC   YGCT    FGC    FGCT     GCT
 0.00  98.23  20.19  68.61  97.44  96.33    52   1.579     1    0.006   1.585
```

###`lsof -p <PID>`

`lsof -p <PID>` 会在控制台打印**指定进程（PID）打开的所有“文件”**，这些文件不仅包括普通文件，还包括目录、库文件、设备、管道、套接字（网络连接）等。  
这是类 Unix 系统中排查进程资源使用情况、文件描述符泄漏、端口占用等问题的常用命令。

---

**输出内容样例**

```
COMMAND    PID  USER   FD      TYPE     DEVICE   SIZE/OFF     NODE NAME
java     12345  user  cwd       DIR      8,1        4096        2 /home/user
java     12345  user  rtd       DIR      8,1        4096        2 /
java     12345  user  txt       REG      8,1    1713248   123456 /usr/bin/java
java     12345  user  mem       REG      8,1    1597440   234567 /lib/x86_64-linux-gnu/libc-2.31.so
java     12345  user    0u      CHR      136,2        0t0       5 /dev/pts/2
java     12345  user    1u      CHR      136,2        0t0       5 /dev/pts/2
java     12345  user    2u      CHR      136,2        0t0       5 /dev/pts/2
java     12345  user    3u     IPv6     39666        0t0       TCP *:8080 (LISTEN)
...
```

---

**字段解释**

- **COMMAND**：进程名称  
- **PID**：进程号  
- **USER**：所属用户  
- **FD**：文件描述符（如`cwd`当前目录，`txt`程序本身，`mem`映射文件，数字是打开的普通文件、socket等）  
- **TYPE**：文件类型（REG=普通文件，DIR=目录，CHR=字符设备，IPv4/IPv6=网络连接等）  
- **DEVICE**：设备号
- **SIZE/OFF**：文件大小或偏移量
- **NODE**：节点号（inode）
- **NAME**：文件名或端点描述

---

**总结**  
`lsof -p <PID>` 可以让你看到进程当前所有打开的文件、日志、库、socket、端口等，是诊断文件/端口占用、泄漏等问题的利器。

### jcmd PID VM.classloaders

执行 `jcmd <PID> VM.classloaders` 命令时，控制台会打印出**指定 JVM 进程（PID）中所有正在加载的类加载器（ClassLoader）及其基本信息**。  
该命令用于诊断和分析 Java 应用的类加载器结构，常用于查找类加载器泄漏、理解类加载器层次等场景。

---

**输出内容（样例）**

输出会类似如下（具体内容依 JVM 版本和实现方式略有不同）：

```
12345:
ClassLoader 0x0000000100081028  (bootstrap)
  - name: <bootstrap>
  - parent: null

ClassLoader 0x00000001000c1028  (platform)
  - name: jdk.internal.loader.ClassLoaders$PlatformClassLoader
  - parent: 0x0000000100081028

ClassLoader 0x00000001000e1028  (app)
  - name: jdk.internal.loader.ClassLoaders$AppClassLoader
  - parent: 0x00000001000c1028

ClassLoader 0x00000001001a1028
  - name: org.springframework.boot.loader.LaunchedURLClassLoader
  - parent: 0x00000001000e1028

...
```

---

**典型字段说明**

- **ClassLoader 0x...**：类加载器对象的内存地址（唯一标识）。
- **name**：类加载器的类型或实现类名。
- **parent**：父类加载器的内存地址（或 `null`，如 Bootstrap）。
- 可能还会有一些附加信息（比如被加载类的数量等，取决于JVM实现）。

---

**总结**

- 该命令**不会显示每个类加载器加载的所有类**，但能帮助你了解 JVM 内部类加载器的结构和关系。
- 常用于分析类加载器泄漏、排查 OOM、理解第三方框架自定义ClassLoader的使用方式等。

如果需要查看**每个ClassLoader加载了哪些类**，可结合 `jcmd <PID> GC.class_stats`、`jcmd <PID> VM.class_hierarchy` 或使用更高级的分析工具（如MAT、Arthas等）。



##Arthas

```
启动 Arthas
Attach 到目标 Java 进程

dashboard // 查看整体状态
IF 发现异常:
    // 常见异常参考
    // 1. CPU高（整体或线程） 2. 内存高（heap使用率高、频繁GC）
    // 3. 线程数异常 4. TPS骤降 5. 类加载数异常

    thread // 分析线程详情
    IF 定位到高CPU/死锁/阻塞线程:
        记录线程ID和堆栈，准备修复
    ELSE:
        monitor 目标方法 // 监控方法调用次数和平均耗时
        IF 有性能热点方法:
            watch 目标方法 // 观察方法参数、返回值、异常
            trace 目标方法 // 分析方法调用路径与各步骤耗时
            profiler start/stop // 采样生成火焰图，查找CPU/内存热点
            IF 需要查看实际代码逻辑:
                jad 目标类 // 反编译线上实际运行的类
            ENDIF
            IF 需要临时修复:
                本地修改class -> 上传服务器
                mc 或 retransform // 热加载新class
                IF 需要临时修改变量或调用对象方法:
                    ognl // 动态执行表达式或修改变量
                ENDIF
            ENDIF
        ELSE:
            继续观察或记录当前现象
        ENDIF
    ENDIF
ELSE:
    继续观察或退出
ENDIF

记录排查和修复过程，归纳经验
```

