# 分布式锁与事务的加锁顺序对比 🚦

在实际开发中，经常会遇到分布式锁（如 Redis 实现）与数据库事务（如 Spring 的 `@Transactional`）同时使用的场景。分布式锁应该加在事务外还是事务内？两种方式有何区别？这里做一个详细对比 🔍。

---

## 1️⃣ 锁在事务外（锁的粒度 > 事务粒度）

伪代码示例：

```java
lock.lock();
try {
    // 开启事务
    transactionalMethod();
} finally {
    lock.unlock();
}
```

**优点：**
- 🕐 事务时长不受锁的影响，只负责数据库操作，事务更快提交，数据库连接占用时间短。
- ✅ 避免在事务内进行外部调用（如 Redis、MQ、RPC 等），降低出现分布式一致性问题的概率。

**缺点：**
- ⏳ 锁的时间更长，涵盖整个事务，系统吞吐量会降低。

---

## 2️⃣ 锁在事务内（事务粒度 > 锁粒度）

伪代码示例：

```java
@Transactional
public void method() {
    lock.lock();
    try {
        // 事务性操作
    } finally {
        lock.unlock();
    }
}
```

**优点：**
- 🔓 锁的持有时间短，提高了并发度。

**缺点：**
- ⚠️ 在事务中进行了外部调用（如 Redis），可能拖长事务，导致数据库连接占用时间变长。
- ❌ 可能出现数据不一致问题。例如经典的“一锁二查三更新”场景，仍然可能出现并发写入导致的数据重复。

> 详细案例参见：[为什么会出现重复数据？](https://www.yuque.com/hollis666/hkhtl7/gz2qwl)

---

## 🚦 如何选择？

- **推荐：** 优先选择“锁在事务外”，即**先加锁再开启事务**。  
  - 👍 这样可以有效避免数据库连接长时间占用和数据不一致等问题。
  - 💰 Redis 等分布式锁资源成本低于数据库资源，可以接受锁的粒度略大。
  - 🔄 加锁时长一般可控，且通常有续期机制，影响可忽略。

- **不建议：** 在事务中做外部调用（如加锁），否则可能导致事务时长不可控，影响系统性能。

---

## 总结建议 💡

- 🚫 不要在事务中做外部调用（如 Redis、MQ、RPC），事务应该只操作数据库。
- 🛡️ 为保证数据一致性和系统性能，**加锁要在事务外**，锁粒度可以适当大一些。
- 🔄 通常加锁有续期机制，加锁时长增加的影响很小。

---

> **一句话总结：**  
> **分布式锁建议加在事务外，优先保证数据一致性和系统稳定性。**