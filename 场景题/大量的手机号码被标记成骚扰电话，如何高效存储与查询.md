# 大量的手机号码被标记成骚扰电话，如何高效存储与查询？

这是一个典型的“黑名单识别”场景。由于骚扰号码量大，核心目标是：**高效存储+高性能查询**。推荐方案如下：

---

## 1️⃣ 数据库存储（持久化）

- 建立关系型数据库表（如 MySQL），记录手机号、标记时间等信息
- 对手机号字段建立唯一索引，保证查询效率

```sql
CREATE TABLE black_phone_list (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  phone VARCHAR(20) NOT NULL UNIQUE,
  create_time DATETIME DEFAULT CURRENT_TIMESTAMP
);
CREATE UNIQUE INDEX idx_phone ON black_phone_list(phone);
```

- 3000万手机号级别，依赖索引可以做到秒级查询

---

## 2️⃣ 分布式缓存（提升查询性能）

- 在数据库基础上，加一层 **分布式缓存**（如 Redis）
- 方案一：**只缓存热点手机号**  
  - 采用 LFU/LRU 等策略，只缓存常用、查询频繁的号码，减少内存消耗
  - 动态更新缓存，保证热点数据命中率

- 方案二：**布隆过滤器（BloomFilter）**
  - **布隆过滤器极适合黑名单这类“只增不减”的大数据集**，能用极低内存判定“手机号可能存在/一定不存在”
  - 适合亿级手机号场景，查询速度极快，但存在极小概率误判

---

## 3️⃣ 本地缓存（进一步加速）

- 可用 Caffeine、GuavaCache 等本地缓存，将最近查询的黑名单手机号缓存在应用内存
- 命中本地缓存直接返回，未命中再查 Redis，最后查数据库

---

## 4️⃣ 多级缓存架构

- 查询流程：**本地缓存** → **Redis缓存/布隆过滤器** → **数据库**
- 只要上层缓存未命中，继续向下查，命中即返回，保证高并发下性能最优

---

## 5️⃣ 一致性问题

- 黑名单手机号几乎只增不减，允许 eventual consistency
- 新增拉黑时需同步更新缓存和数据库

---

## ✅ 总结

- 持久化用数据库，提升查询用多级缓存
- 热点数据可用 Redis，超大集可用布隆过滤器
- 本地缓存加速极热数据，组合多级缓存架构
- 这样能兼顾超大数据量下的**查询性能**与**存储成本**，并且易于扩展！

---