## 滥用事务/单个事务SQL语句过多的弊端

### 1. 锁资源占用时间长，影响并发性能
- 事务未提交前，相关数据行/表会被锁住，其他事务无法访问或等待，导致**并发能力下降**，出现**锁等待、锁竞争**甚至**死锁**。

### 2. 占用大量内存与日志空间
- 事务会生成 Undo Log、Redo Log，SQL越多日志越大，**内存、磁盘压力变大**，极端情况下可能导致磁盘爆满甚至数据库崩溃。

### 3. 回滚成本高，恢复慢
- 事务出错需要回滚时，SQL越多，**回滚越慢**，Undo Log越大，恢复耗时严重，影响数据库可用性。

### 4. 长事务导致快照保留时间长，影响垃圾回收
- InnoDB的MVCC需要为老事务保留历史版本，**长事务会阻碍老数据的清理（Purging）**，造成表空间膨胀。

### 5. 死锁概率增加
- SQL多、锁多，**死锁概率提升**，影响系统稳定性。

### 6. 影响主从复制延迟
- 大事务提交时主从同步要等事务全部完成，**导致主从延迟，影响数据一致性和读写分离效果**。

---

## 总结性口诀

- 事务越大，锁得越久，日志越多，风险越高。
- **能小则小，能短则短，频繁提交，利于性能和安全。**

---

## 面试官可能追问

1. **如何拆分大事务？**
   - 按业务分批、分段提交；批量操作时，每批处理适量数据。

2. **如何监控和排查长事务？**
   - 查询 `information_schema.innodb_trx`，分析慢SQL和锁等待，及时kill异常长事务。

3. **实际开发中如何平衡批量操作和事务安全性？**
   - 既要保证数据一致性，也要考虑性能，采用合理的批量提交策略。

---