# 为什么不用分布式锁来实现秒杀？❌🔒

在设计高并发的秒杀系统时，很多人会问：为什么不用 Redis 分布式锁来实现库存扣减，防止超卖？其实，最佳实践是**不用分布式锁，而是用 Lua 脚本**。原因如下👇：

---

## 1️⃣ 分布式锁没必要，Lua 脚本即可 💡

- **目的**：秒杀最重要的是两点：① 高并发抗压，② 避免超卖。
- **Lua 脚本**：利用 Redis 的原子性，一次性检查并扣减库存，天然防止并发超卖。
- **分布式锁**：只是让操作排队，本质也只是串行化，并没有比 Lua 脚本更优。

---

## 2️⃣ Lua 脚本具备原子性，天然防并发冲突 ⚡

- Redis 在执行 Lua 脚本时，所有操作不可拆分，中途不会被其它命令打断。
- 可以把“查询库存+扣减库存”写进一个 Lua 脚本，实现**原子扣减**，避免超卖。

---

## 3️⃣ 用锁反而增加复杂度和延迟 🕙

- 分布式锁需要多次与 Redis 通信（加锁、查库存、扣减、释放），网络延时变多。
- Lua 脚本只需一次请求，直接在 Redis 内部完成所有操作，效率更高。

---

## 4️⃣ 锁管理有风险，Lua 脚本更安全 🛡️

- 分布式锁涉及锁超时、死锁、锁失效等问题，稍有不慎会影响系统稳定性。
- Lua 脚本无需锁管理，天然串行执行，代码层面更易维护，出错概率低。

---

## 5️⃣ Redis 单线程机制得天独厚 🧵

- Redis 本身就是单线程模型，Lua 脚本执行时不会被其它命令打断。
- 利用这一点，直接用 Lua 脚本即可安全、高效地处理高并发库存扣减。

---

## 🚫 “加锁 + Lua 脚本”是脱裤子放屁

- 有人建议先加锁再用 Lua 脚本，其实完全没必要。
- Lua 脚本本身就保证了原子性，无需额外加锁。

---

## 📝 总结

- 秒杀场景下，直接用 Redis Lua 脚本实现库存扣减，效率高、并发强、无超卖风险。
- 分布式锁方案复杂、易出错、性能低，完全没必要。

---

> **一句话总结：**  
> **秒杀不用分布式锁，直接用 Lua 脚本，既高效又安全！👍**