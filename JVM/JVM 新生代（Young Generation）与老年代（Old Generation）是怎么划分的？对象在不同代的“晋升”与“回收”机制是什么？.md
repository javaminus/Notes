## 问题：JVM 新生代（Young Generation）与老年代（Old Generation）是怎么划分的？对象在不同代的“晋升”与“回收”机制是什么？

---

### 详细解释（结合场景 & 通俗例子）

#### 1. 新生代与老年代的基本概念

- **新生代（Young Generation）**
  - 存放新创建的对象。
  - 内部分为 Eden 区和两个 Survivor 区（S0/S1）。
  - 特点：大部分对象“朝生夕死”，存活时间短，回收频繁。
- **老年代（Old/Tenured Generation）**
  - 存放经过多次 GC 仍然存活的“老”对象。
  - 特点：对象生命周期长，回收频率低。

#### 2. 对象的“晋升”机制（晋升到老年代）

- **Minor GC**
  - 只发生在新生代。
  - 大部分新生对象会在 Eden 区被回收，存活下来的移动到 Survivor 区。
- **晋升到老年代的三种典型情况**
  1. **年龄阈值**  
     对象每经历一次 Minor GC，年龄+1，达到阈值（如15，`-XX:MaxTenuringThreshold`），晋升到老年代。
  2. **Survivor 区空间不足**  
     Survivor 区放不下存活对象时，直接晋升到老年代。
  3. **大对象直接进入老年代**  
     超过特定大小（`PretenureSizeThreshold`）的大对象直接分配到老年代，避免新生代频繁 GC。

#### 3. 回收机制

- **Minor GC**
  - 回收新生代，速度快，影响小。
- **Major GC（Full GC）**
  - 回收老年代（有时也包括新生代），速度慢，影响大，可能造成应用停顿。

#### 4. 典型场景与调优

- **短生命周期对象多（如请求、临时变量）**  
  → 适合新生代 GC 频繁、老年代较小。
- **大对象/缓存/集合长期存在**  
  → 经常晋升老年代，需关注老年代空间与 Full GC 频率。

- **调优参数**
  - 新生代大小：`-Xmn` 或 `-XX:NewSize`/`-XX:MaxNewSize`
  - 晋升阈值：`-XX:MaxTenuringThreshold`
  - 大对象直接进入老年代阈值：`-XX:PretenureSizeThreshold`

#### 5. 通俗例子

```java
for (int i = 0; i < 100000; i++) {
    // 绝大多数对象在 Eden 区创建，用完即丢，很快被 Minor GC 回收
    String tmp = new String("hello" + i);
}
```
- 只有少量 survive 的对象会经历多次 Minor GC 后晋升到老年代。

---

### 总结性的回答（复习提示词）

- **新生代**：Eden、S0、S1，短命对象多，Minor GC 频繁
- **老年代**：长寿对象、缓存、晋升/大对象
- **晋升机制**：年龄、空间不足、大对象
- **口诀**：`“朝生夕死新生代，历经磨难进老年，空间不足早晋升，大对象直接进老年”`