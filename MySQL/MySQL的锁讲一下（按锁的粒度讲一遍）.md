MySQL的锁按照**粒度**（即作用范围的大小）可以分为以下几类（从大到小）：

---

## 1. 全局锁（Global Lock）
- **范围**：整个数据库实例（所有库所有表）。
- **常用场景**：全库备份（如FLUSH TABLES WITH READ LOCK）。
- **特点**：加锁后，整个数据库只允许读操作，不允许写操作，影响最大。

---

## 2. 表级锁（Table Lock）
- **范围**：单张表。
- **常用场景**：MyISAM存储引擎、DDL操作、LOCK TABLES语句。
- **特点**：加锁快、开销小，不会死锁，但并发能力低。

---

## 3. 页级锁（Page Lock）
- **范围**：一页（多个连续的记录，通常为数据库存储的物理页）。
- **常用场景**：BDB存储引擎（MySQL默认的InnoDB并不使用页锁）。
- **特点**：粒度介于表锁和行锁之间，能够减少锁冲突，提高并发，但容易死锁。

---

## 4. 行级锁（Row Lock）
- **范围**：单行数据。
- **常用场景**：InnoDB存储引擎（MySQL 默认存储引擎）。
- **特点**：粒度最小，并发度最高，但加锁开销大，容易死锁。

---

## 总结表

| 锁粒度 | 作用范围 | 并发能力 | 死锁可能性 | 典型应用       |
| ------ | -------- | -------- | ---------- | -------------- |
| 全局锁 | 整个实例 | 最低     | 无         | 全库备份       |
| 表级锁 | 单张表   | 较低     | 无         | MyISAM、DDL    |
| 页级锁 | 一页数据 | 中等     | 有         | BDB引擎        |
| 行级锁 | 单行数据 | 最高     | 有         | InnoDB（默认） |

---

## 备注
- 锁的粒度越小，并发性能越高，但管理开销越大。
- InnoDB实际还包括间隙锁（Gap Lock）、Next-Key Lock等特殊行锁机制，用于解决幻读等问题。
- 不同存储引擎支持的锁粒度不同：MyISAM支持表锁，InnoDB支持行锁和表锁，BDB支持页锁。

如需了解每种锁的用法、SQL示例或具体实现细节，可以继续提问！