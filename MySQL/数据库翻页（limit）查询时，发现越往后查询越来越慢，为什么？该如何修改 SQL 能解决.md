你的问题很经典，下面详细解释原因和改进方法：

---

## 1. 为什么用 `LIMIT offset, size` 翻页越来越慢？

假设你的 SQL 语句如下：

```sql
SELECT * FROM table_name ORDER BY id LIMIT 10000, 20;
```

- 这里 offset=10000，size=20，意味着你要跳过前10000条，只取后20条。
- **MySQL 的执行方式**：会先找到前10020行，然后丢弃前10000行，只返回后20行。
- **问题**：随着 offset 越来越大，MySQL 需要扫描和丢弃的数据越来越多，查询越来越慢。

---

## 2. 解决办法：使用“条件翻页”或“覆盖索引”

### 方法一：基于上次主键或唯一索引的“条件翻页”（推荐）

假设你的表里有自增主键 `id`，已经查到了上一页的最后一条的id=`10500`，下一页直接这样查：

```sql
SELECT * FROM table_name WHERE id > 10500 ORDER BY id ASC LIMIT 20;
```

- **原理**：利用索引快速定位，不用跳过前面所有数据，效率极高。
- **注意**：每次都记录上一页最后一条数据的主键值。

#### 适用于：
- 主键递增、有唯一索引的场景。

---

### 方法二：利用覆盖索引+子查询

如果必须用 offset，可以先只用索引字段查子查询，再回表查数据：

```sql
SELECT * FROM table_name 
WHERE id IN (
  SELECT id FROM table_name ORDER BY id LIMIT 10000, 20
);
```

- **原理**：先用索引字段定位，再回表查询，效率高于直接大 offset。

---

### 方法三：物化分页（记录每页的条件）

- 业务层提前缓存或记录每一页的“起点条件”，避免 offset 越来越大。

---

## 3. 总结

- **慢的根本原因**：大 offset 会导致数据库扫描和丢弃大量数据。
- **最佳实践**：用主键条件（或唯一索引）做“基于游标的分页”。
- **SQL 示例**：

    - 慢：`SELECT * FROM t ORDER BY id LIMIT 10000, 20;`
    - 快：`SELECT * FROM t WHERE id > 上一页最后一条id ORDER BY id LIMIT 20;`

---

如需根据业务场景给出具体 SQL 优化建议，可补充表结构和分页方式！