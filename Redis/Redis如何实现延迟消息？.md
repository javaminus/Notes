# Redis如何实现延迟消息？【关闭订单的场景，用户提交订单没有支付，但是订单会有一个等待支付的时间】

## 方案一：Redis过期消息实现延迟消息(不推荐)

Redis有一个监听的功能，在redis.conf文件中，加入一条配置`notify-keyspace-events Ex`开启过期监听，然后在代码中实现一个KeyExpirationEventMessageListener，就可以监听key的过期消息了。 

这样就可以在接收到过期消息的时候，进行订单的关单操作。 

这个方案不建议大家使用，是因为Redis官网上明确的说过，Redis并**不保证**Key在过期的时候就能被立即删除，更不保证这个消息能被立即发出。所以，消息延迟是必然存在的，随着数据量越大延迟越长，延迟个几分钟都是常事儿。  

而且，在Redis 5.0之前，这个消息是通过PUB/SUB模式发出的，他**不会做持久化**，至于你有没有接到，有没有消费成功，他不管。也就是说，如果发消息的时候，你的客户端挂了，之后再恢复的话，这个消息你就彻底丢失了。 

## 方案二：Redis的zset实现延迟消息

zset是一个有序集合，每一个元素(member)都关联了一个 score，可以通过 score 排序来取集合中的值。 

我们将订单超时时间的时间戳（下单时间+超时时长）与订单号分别设置为 score 和 member【订单号】。这样redis会对zset按照score延时时间进行排序。然后我们再开启redis扫描任务，获取”当前时间 > score”的延时任务，扫描到之后取出订单号，然后查询到订单进行关单操作即可。 【这里需要我们手写定时轮询任务】

使用redis zset来实现订单关闭的功能的优点是可以借助redis的持久化、高可用机制。避免数据丢失。但是这个方案也有缺点，那就是在高并发场景中，有可能有多个消费者同时获取到同一个订单号，一般采用加分布式锁解决，但是这样做也会降低吞吐型。 

## 方案三：Redission实现延迟消息 

Redission中定义了分布式延迟队列RDelayedQueue，这是一种基于我们前面介绍过的zset结构实现的延时队列，它允许以指定的延迟时长将元素放到目标队列中。 

其实就是在zset的基础上增加了一个基于内存的延迟队列。当我们要添加一个数据到延迟队列的时候，redission会把数据+超时时间放到zset中，并且起一个延时任务，当任务到期的时候，再去zset中把数据取出来，返回给客户端使用。 【redission帮我们实现了定时轮询任务】

