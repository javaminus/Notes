## 问题：JVM GC 调优中常见的误区与陷阱有哪些？如何避免？

---

### 详细解释（结合场景 & 通俗例子）

#### 1. 只关注停顿时间或吞吐量，忽视业务场景
- 误区：盲目追求最短 GC 停顿或最高吞吐量，却忽略业务实际需求。
- 场景：低延迟金融系统更关注“最大停顿时间”，而批量计算型服务关注“总吞吐”。
- 建议：根据业务特性选择合适的 GC 策略（如 G1/ZGC 适合低延迟，Parallel GC 适合高吞吐）。

#### 2. 机械调整堆大小，忽略分代比例
- 误区：只调大/调小堆，不考虑新生代与老年代分配比例。
- 场景：新生代太小导致 Minor GC 频繁，太大则对象提前进入老年代，加速 Full GC。
- 建议：通过 GC 日志分析对象晋升与回收效率，合理设置 `-Xmn`、`-XX:NewRatio` 等参数。

#### 3. 误用 GC 参数，配置不兼容
- 误区：不同 GC 回收器参数混用（如 CMS、G1 特有参数），导致启动报错或参数无效。
- 场景：`-XX:+UseConcMarkSweepGC` 与 `-XX:MaxGCPauseMillis` 同时设置，后者对 CMS 无效。
- 建议：查阅官方文档，明确参数适用的回收器类型。

#### 4. 忽视元空间、直接内存等“非堆”区域的调优
- 误区：只关注堆参数，忽略 `Metaspace`、`Direct Memory` 配置。
- 场景：动态生成类多导致 `Metaspace` OOM，NIO/Netty 应用直接内存泄漏。
- 建议：根据应用类型设置 `-XX:MaxMetaspaceSize`、`-XX:MaxDirectMemorySize`，并及时监控。

#### 5. 只看 GC 次数，不分析 GC 日志细节
- 误区：认为 GC 次数越少越好，忽略每次回收的耗时、晋升速率、堆空间变化等更重要信息。
- 建议：开启详细 GC 日志（如 `-Xlog:gc*`），结合工具分析回收效果。

#### 6. 盲目使用 Full GC 或 System.gc()
- 误区：手工调用 `System.gc()` 希望立刻回收内存，实际上会引发全停顿，反而加重负担。
- 建议：禁止业务代码调用 `System.gc()`，如需主动触发可加参数 `-XX:+DisableExplicitGC`。

---

### 总结性的回答（复习提示词）

- **GC调优误区**：只调堆、不分代、参数混用、忽略非堆、只看次数、乱用Full GC
- **优化建议**：结合业务场景，分析GC日志，合理分代与参数，关注非堆区域
- **口诀**：`“调优不迷信，参数看回收，日志细分析，场景定策略”`