## 问题：JVM垃圾回收（GC）的分代模型是什么？各代的回收器如何协同工作？

### 详细解释

JVM的堆内存采用**分代管理**，主要分为**新生代（Young Generation）**、**老年代（Old Generation）**和**元空间/方法区（Metaspace/Method Area）**。分代模型的核心思想是：不同生命周期的对象用不同的回收策略，提高GC效率。

#### 1. 分代内存结构

- **新生代（Young Gen）**  
  存放新创建的对象。分为 Eden 区和两个 Survivor 区（S0、S1）。
- **老年代（Old Gen）**  
  存放从新生代晋升过来的长生命周期对象。
- **元空间（Metaspace，JDK8+）/方法区**  
  存放类元数据、静态变量等，不再属于堆。

#### 2. 垃圾回收器协同工作

- **新生代回收（Minor GC）**  
  采用“复制算法”，通常只回收新生代。对象大多存活时间短，回收频繁但速度快。
- **老年代回收（Major/Full GC）**  
  采用“标记-清除”或“标记-整理”算法。回收老年代，通常伴随新生代的回收，耗时较长。
- **元空间/方法区回收**  
  主要回收废弃的类元数据。

**典型组合：**
- ParNew + CMS
- Parallel Scavenge + Parallel Old
- G1（统一管理新生代、老年代）

#### 3. 对象晋升与回收流程

1. 对象新建于 Eden 区。
2. Minor GC后仍存活，对象进入 Survivor 区。
3. 多次GC后仍存活，晋升到老年代。
4. 老年代空间不足时触发Full GC，回收整个堆。

**示意图：**
```
Eden -> Survivor0 <-> Survivor1 -> Old Gen
```

#### 4. 典型场景与例子

- 高频请求、临时对象（如Web请求参数）往往在新生代分配并很快被回收。
- 长连接、缓存等对象容易晋升到老年代，需关注老年代内存溢出风险。

#### 5. 分代带来的优化好处

- 针对不同对象生命周期采用最优回收算法，提高GC效率。
- 减少Full GC发生频率，提升吞吐量和响应速度。

### 总结性回答/提示词

- JVM分代：新生代（Eden+Survivor）、老年代、元空间
- GC分为Minor GC（新生代）、Full GC（全堆/老年代）
- 对象“熬老”：多次GC后晋升老年代
- 典型回收器组合：ParNew/CMS、Parallel Scavenge/Parallel Old、G1
- 复习提示：**“分代GC分新老，复制算法快，晋升规则定，回收器协同优化效率”**

## 7. 面试官常见追问与参考答案

### Q1: 为什么新生代采用复制算法，老年代用标记-清除/整理？
**答**：新生代对象大多“朝生暮死”，存活率低，复制算法只需移动少量存活对象，速度快；老年代对象存活率高，用复制算法会浪费空间，标记-清除/整理更高效。

---

### Q2: Minor GC 与 Full GC 有什么区别？
**答**：Minor GC只回收新生代，速度快、影响小；Full GC回收整个堆（新生代+老年代+方法区），耗时久、影响大，通常需重点优化以防频繁发生。

---

### Q3: Survivor区的存在意义是什么？
**答**：防止新生代存活对象直接晋升老年代，经过多次GC考验后再晋升，减少老年代压力和Full GC频率。

---

### Q4: 新生代对象如何晋升到老年代？晋升阈值如何确定？
**答**：对象在Survivor区存活一定次数后晋升老年代，阈值可通过`-XX:MaxTenuringThreshold`设置（默认15次），大对象直接晋升。

---

### Q5: G1 GC与传统分代GC有何不同？
**答**：G1不再严格区分新生代/老年代，按Region划分内存，能并发预测回收停顿目标，适合大堆高并发场景。

---

### Q6: 如何判断是Minor GC还是Full GC导致的性能问题？
**答**：可通过GC日志区分（如`[GC ...]`为Minor GC，`[Full GC ...]`为Full GC），重点看Full GC频率、耗时，分析老年代回收与内存分配情况。

当然可以，下面详细讲解JVM垃圾回收中的三种核心算法：**复制算法（Copying/Scavenge）**、**标记-清除（Mark-Sweep）**、**标记-整理（Mark-Compact）**。

---

## 一、复制算法（Copying/Scavenge）

### 原理
- 将内存分为两块大小相等的区域（如新生代中的Eden+Survivor0/Survivor1）。
- 每次只使用一块，另一区空闲。
- GC时，遍历当前使用区，把**存活对象复制**到另一块空闲区，原区域直接一次性清空。
- 下次GC时，两块角色互换。

### 优点
- 复制过程简单高效，无需考虑内存碎片。
- 分配时只需指针顺移，速度快。

### 缺点
- 实际可用内存减半。
- 只适用于“绝大多数对象存活率低”的场景（如新生代）。

### 应用
- JVM新生代（Minor GC）常用复制算法（如ParNew、Parallel Scavenge、G1新生代部分）。

---

## 二、标记-清除算法（Mark-Sweep）

### 原理
1. **标记阶段**：遍历所有对象，把所有**存活对象打上标记**。
2. **清除阶段**：扫描堆，把没有标记的对象（即死对象）**直接回收**，释放空间。

### 优点
- 不需要移动对象，适用所有存活率场景。
- 实现简单。

### 缺点
- 回收后空间**不连续**，易产生内存碎片。
- 后续大对象分配时可能需要额外的合并或查找空闲块，降低分配效率。
- 清理速度相对较慢。

### 应用
- 老年代回收（如Serial Old、CMS），Full GC时常用。

---

## 三、标记-整理算法（Mark-Compact）

### 原理
1. **标记阶段**：同样先遍历并标记所有存活对象。
2. **整理（压缩）阶段**：将所有存活对象**向一端移动**，移动后顺序排列，**清理掉边界以后的全部空间**。

### 优点
- 回收后空间**连续**，没有内存碎片。
- 有利于大对象分配和后续快速分配。

### 缺点
- 移动对象有一定的性能开销，需要更新所有指针引用。
- 实现复杂度较高。

### 应用
- 老年代的垃圾回收器（如Serial Old、G1老年代），Full GC时常用。

---

## 对比总结表

| 算法      | 优点             | 缺点                   | 主要应用场景    |
| --------- | ---------------- | ---------------------- | --------------- |
| 复制算法  | 速度快，无碎片   | 内存利用率低（减半）   | 新生代 Minor GC |
| 标记-清除 | 无需移动，简单   | 有碎片，分配慢         | 老年代/Full GC  |
| 标记-整理 | 无碎片，空间连续 | 需移动对象，性能开销大 | 老年代/Full GC  |

---

## 面试官可能追问与参考答案

### Q1: 为什么新生代适合用复制算法，老年代不适合？
**答**：新生代对象大部分“朝生暮死”，存活率低，复制算法只需复制少量存活对象到另一块，开销小；老年代对象存活率高，如果用复制算法会导致大量对象复制，效率低且内存浪费大。

---

### Q2: 标记-清除和标记-整理的最大区别是什么？
**答**：“标记-清除”只清理死亡对象不移动存活对象，会产生碎片；“标记-整理”则会移动存活对象，把内存压紧，清理后空间连续，无碎片。

---

### Q3: 为什么内存碎片会影响性能？
**答**：内存碎片导致大对象分配时找不到足够连续空间，需额外合并碎片或频繁Full GC，降低分配和GC效率。

---

### Q4: G1、ZGC等新一代GC用的是什么算法？
**答**：G1综合采用“分区+复制+标记-整理”；ZGC、Shenandoah等采用并发标记+并发整理（压缩/转移）算法，目标是低延迟、高吞吐。

---

如需具体代码示例或GC日志解读，也可继续补充说明！