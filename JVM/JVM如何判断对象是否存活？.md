# JVM如何判断对象是否存活？

当JVM判断对象不再存活的时候，便会在下一次GC时将该对象回收掉，为堆腾出空间。那么JVM如何判断对象是否存活呢？主要有两种算法：**引用计数法**和**可达性分析算法**。

---

## 一、引用计数法

- 给对象添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1。
- 任何时候计数器为 0 的对象就是不可用的对象。
- 实现简单、效率高，但主流JVM并未采用。原因是难以解决对象间**循环引用**问题（如A引用B，B又引用A，但二者都不被其他对象引用，计数不会为0，无法回收，导致内存泄漏）。

---

## 二、可达性分析算法

- 通过一系列被称为“GC Roots”的对象作为起点，向下搜索引用链。
- 当某对象到GC Roots没有任何引用链相连，则判定该对象不可用。

### 两次标记机制

1. **第一次标记**：通过可达性分析算法标记无引用链的对象。
2. **第二次标记**：若对象覆盖了`finalize()`方法且未执行过，则会被放入F-Queue队列等待执行。执行后若对象再次被GC Roots引用，则移出“即将回收”集合，否则进行第二次标记才会被真正回收。

> 覆盖`finalize()`方法已不推荐，影响安全和GC性能。

---

## 三、GC Roots的定义与举例

**GC Roots**是可达性分析算法的起点，必须是活跃的引用。主要包括：

- Class：由系统类加载器加载的类（如静态字段持有的对象）。
- Thread：存活的线程对象。
- Stack Local：方法中的局部变量或参数。
- JNI Local：JNI方法中的局部变量或参数。
- JNI Global：全局JNI引用。
- Monitor Used：被`synchronized`持有的对象。
- Held by JVM：JVM内部保留的对象（如类加载器、重要异常类、预分配对象等）。
- Remembered Set：为解决跨代引用问题，记忆集也会作为GC Root（很少被提及）。

---

## 四、跨代引用问题

### 什么是跨代引用？

Java堆内存分为不同代（如新生代、老年代），代之间存在引用关系即为跨代引用。例如：新生代对象引用老年代对象，或老年代对象引用新生代对象。

### 问题及解决

- 跨代引用会影响GC的准确性和效率。
- 为解决跨代引用，JVM采用**Remembered Set**等机制，将其作为GC Roots的一部分。

---

## 五、可达性分析算法的不足

1. **STW（Stop The World）时间长**  
   - 可达性分析需要全局扫描对象和引用，过程复杂且需要暂停应用（STW），对性能有较大影响。
   - CMS、G1等回收器采用**三色标记算法**等优化技术（如增量标记、增量拷贝）来减少STW时长。

2. **内存消耗大**  
   - 需存储所有对象及其引用关系，信息量巨大，可能导致内存空间不足或性能下降，尤其是大型应用。

---

## 六、三色标记算法

三色标记算法是CMS、G1等收集器实现高效标记垃圾对象的核心算法。通过将对象分为白、灰、黑三类，动态进行标记，减少GC过程中的STW时长和误回收问题。

---

> 参考：《深入理解Java虚拟机（第三版）》