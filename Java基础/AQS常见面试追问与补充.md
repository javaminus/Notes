# 🌟 AQS常见面试追问与补充

---

## 1️⃣ AQS为什么能高效支持并发？

- **原因一：CAS原子操作**  
  AQS通过CAS（Compare-And-Swap）保证state变量的原子操作，避免了传统锁的大量阻塞唤醒，提升了性能。

- **原因二：队列化管理线程**  
  线程竞争失败后会被加入到FIFO等待队列，通过队列管理线程的阻塞和唤醒，保证获取资源的公平性和有序性。

- **原因三：挂起/唤醒机制高效**  
  使用LockSupport.park()/unpark()实现线程阻塞和唤醒，比传统的wait/notify粒度更细、效率更高。

---

## 2️⃣ AQS的公平锁与非公平锁区别

- **公平锁**：线程按照队列的FIFO顺序获取锁，先来先得，防止“插队”。
- **非公平锁**：允许新来的线程直接竞争锁，有可能插队，提高吞吐量但可能导致“饥饿”。
- **AQS通过构造方法参数或子类实现区分公平/非公平逻辑**。

---

## 3️⃣ AQS与传统synchronized的对比

| 特性          | AQS（如ReentrantLock） | synchronized（内置锁） |
| ------------- | ---------------------- | ---------------------- |
| 阻塞/唤醒机制 | LockSupport            | Object.wait/notify     |
| 公平性        | 支持公平/非公平        | 只能非公平             |
| 可中断锁获取  | 支持                   | 不支持                 |
| 可重入        | 支持                   | 支持                   |
| 超时锁获取    | 支持                   | 不支持                 |
| 条件变量      | 支持Condition          | 支持wait/notify机制    |

---

## 4️⃣ 面试易错点与补充

- **AQS不是一把锁，而是锁的基础框架。实际加锁逻辑由具体实现类决定。**
- **AQS不仅能实现锁，还能实现信号量、闭锁、栅栏等多种同步器。**
- **AQS的阻塞线程不会一直占用CPU资源，而是被高效挂起，只有被唤醒时才消耗CPU。**
- **自定义同步器时只需重写tryAcquire/tryRelease等方法，队列和线程管理全部AQS自动完成。**

---

## 5️⃣ 面试简答模板

> **AQS是JUC包下锁和同步器的基础框架，核心思想是用CAS保证state原子性，用FIFO队列管理等待线程，通过模板方法支持独占与共享两种模式。常见实现有ReentrantLock、Semaphore、CountDownLatch等。AQS通过高效挂起/唤醒和公平/非公平策略，兼顾了性能和灵活性，是Java并发编程的基石。**

---

# 🧩 AQS面试补充问答与实战建议

---

## 1️⃣ 实战开发中如何选择使用AQS？

- **直接用AQS还是用其实现类？**
  - 日常开发中，绝大多数情况下使用JDK自带的实现类（如ReentrantLock、CountDownLatch、Semaphore等）即可，不建议直接继承AQS自定义同步器，除非有特殊并发场景需求。
  - 只有在JDK现有同步器不能满足需求时，才需要自定义AQS子类。

---

## 2️⃣ 自定义同步器的典型步骤

1. 继承`AbstractQueuedSynchronizer`。
2. 根据需要重写核心方法：
   - 独占模式：`tryAcquire(int arg)`、`tryRelease(int arg)`
   - 共享模式：`tryAcquireShared(int arg)`、`tryReleaseShared(int arg)`
3. 封装AQS为外部可用的同步器接口（如lock/unlock等）。
4. 利用AQS父类的`acquire`、`release`等模板方法，自动完成排队、阻塞和唤醒。

---

## 3️⃣ 经典面试追问：AQS为什么需要队列？

- 并发环境下，多个线程同时竞争锁/资源，失败的线程必须有序排队等待，避免死锁和饥饿，保证公平性和系统有序性。
- 队列结构可自动管理线程的阻塞和唤醒，极大简化了同步器开发的复杂度。

---

## 4️⃣ 经典面试追问：AQS如何避免死锁和饥饿？

- **避免死锁**：通过FIFO队列管理线程等待顺序，线程拿不到资源时自动阻塞，资源释放后唤醒下一个线程继续尝试，避免多个线程互相等待形成死锁。
- **避免饥饿**：公平锁实现时，总是优先唤醒队首线程，后来的线程不能插队，防止某些线程长期得不到资源。

---

## 5️⃣ AQS与CAS、LockSupport的关系

- **CAS（Compare-And-Swap）**：AQS通过CAS保证同步状态（state）的原子修改，是无锁并发的基础。
- **LockSupport**：AQS利用LockSupport.park()挂起线程，LockSupport.unpark()唤醒线程，高效实现线程阻塞/唤醒。

---

## 6️⃣ 面试高频总结

- AQS是Java并发锁和同步器的核心基础，掌握其原理和常见实现是面试高频要求。
- 能说清楚AQS的核心结构（state+队列）、模板方法、独占/共享模式、常见应用场景，以及和CAS/LockSupport的关系，就能应对大部分面试追问。

---

> **高频答题模板：AQS是Java并发核心同步基础，采用CAS原子操作state，FIFO队列管理线程等待，通过LockSupport高效阻塞和唤醒线程，支持独占与共享两种模式，常用实现包括ReentrantLock、Semaphore、CountDownLatch等。只有极少数特殊场景才需要自定义AQS同步器。**