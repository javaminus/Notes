限流算法主要用于 **控制并发请求数量**，防止系统过载。常见的限流算法包括以下几种：  

---

## 1. **计数器（Fixed Window Counter）**
### **原理**：
- 设定一个 **固定时间窗口**（如 1 秒）。
- 记录该窗口内的请求数，若超过阈值，则拒绝请求。
- 时间窗口结束后，计数器归零。

### **示例**：
假设 **限制 1 秒最多 100 个请求**：
- 00:00:00 ~ 00:00:01 内，允许最多 100 次请求。
- 00:00:01 ~ 00:00:02 重新计数。

### **优缺点**：
✅ **实现简单**，适用于 **短时间限流**。  
❌ **可能突发流量过载**，比如 00:00:00 结束时有 100 次请求，00:00:01 又突然有 100 次，总体 QPS 突然翻倍。  

### **适用场景**：
- **简单限流**，如 API 请求限流。

---

## 2. **滑动窗口（Sliding Window Counter）**
### **原理**：
- **将时间窗口拆分为多个小窗口**（例如 1 秒划分 10 份，每份 100ms）。
- 维护 **多个小窗口的计数**，计算最近 N 个窗口的请求总数，决定是否允许请求。

### **示例**：
- 限制 1 秒最多 100 个请求，划分 10 个 100ms 窗口，每个窗口最多 10 次请求。
- 计算最近 1 秒（10 个窗口）内的请求数，若超过 100，则拒绝请求。

### **优缺点**：
✅ **减少流量突刺问题**，更加平滑。  
❌ **需要存储多个窗口的数据**，计算复杂度略高。

### **适用场景**：
- 适用于 **波动流量**，如高并发 API 请求限流。

---

## 3. **令牌桶（Token Bucket）**
### **原理**：
- 令牌以 **固定速率** 生成，放入桶中（如每秒 10 个）。
- 请求需要 **获取令牌** 才能通过。
- 若令牌不足，则请求被限流。
- 桶的容量有限，防止短时间大量请求透支未来的流量。

### **示例**：
- 限制 API 每秒最多 10 次请求：
  - 初始桶容量 10，每秒补充 10 个令牌。
  - 1 个请求消耗 1 个令牌，若令牌不足，则限流。

### **优缺点**：
✅ **允许一定的突发流量**（存储的令牌可以在短时间内被消耗）。  
✅ **控制平均流量**，适用于 **突发请求但需要平稳处理** 的场景。  
❌ **可能会有短暂的高峰流量**（令牌积累后瞬间被消耗）。

### **适用场景**：
- **API 限流**（如 Google Guava RateLimiter）。
- **突发请求但总体流量稳定** 的场景。

---

## 4. **漏桶（Leaky Bucket）**
### **原理**：
- 以 **固定速率** 处理请求（出水）。
- 请求进入队列（进水），若队列满，则丢弃请求。

### **示例**：
- 限制 **每秒只能处理 10 个请求**：
  - 每个请求进入 **漏桶队列**。
  - 服务器每 100ms 处理 1 个请求（即 10 QPS）。
  - 若桶满，新的请求将被丢弃。

### **优缺点**：
✅ **完全平滑请求速率**，防止突发流量压垮系统。  
❌ **可能导致请求丢失**，因为超出队列长度的请求会被丢弃。

### **适用场景**：
- **严格控制请求处理速率**，如支付系统、队列消费处理。

---

## 5. **滑动窗口日志（Sliding Log）**
### **原理**：
- 记录每个请求的时间戳（日志）。
- 计算最近时间窗口内（如 1 秒）的请求数，决定是否限流。

### **优缺点**：
✅ **精度高**，比滑动窗口计数更平滑。  
❌ **存储请求日志**，消耗 **大量内存**，性能开销较大。

### **适用场景**：
- 需要 **高精度限流** 的场景，如风控系统。

---

## **对比总结**
| 算法 | 允许突发流量 | 控制速率平滑 | 适用场景 |
|------|------------|------------|--------|
| **计数器** | ❌ | ❌ | 简单 API 限流 |
| **滑动窗口计数** | ❌ | ✅ | 波动流量 |
| **令牌桶** | ✅ | ✅ | API 限流（允许突发流量） |
| **漏桶** | ❌ | ✅ | 任务队列（严格限流） |
| **滑动窗口日志** | ✅ | ✅ | 高精度限流 |

---

## **实际应用**

1. **Spring Cloud Gateway / Nginx 限流**：
   - 采用 **令牌桶算法**，如 Redis + Lua 进行分布式限流。

2. **API 限流（如 GitHub API）**：
   - 采用 **滑动窗口或令牌桶**，限制用户 QPS。

3. **支付系统**：
   - 采用 **漏桶算法**，确保交易请求稳定。

4. **流量控制（如秒杀系统）**：
   - 采用 **滑动窗口 + Redis**，防止超卖。

**选择合适的限流算法，能有效提高系统稳定性！** 🚀