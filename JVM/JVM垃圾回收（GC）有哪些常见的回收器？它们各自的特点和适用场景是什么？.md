## 问题：JVM垃圾回收（GC）有哪些常见的回收器？它们各自的特点和适用场景是什么？

### 详细解释

JVM 提供了多种垃圾回收器（GC），每种回收器针对不同应用场景和性能需求，采取了不同的回收策略。以下是主流 GC 的分类、特点与典型适用场景。

#### 1. Serial（串行）GC

- **特点**：单线程回收，GC 时所有用户线程暂停（Stop-The-World），简单高效，开销低。
- **适用**：小型应用、单核或内存小的环境（如嵌入式设备、客户端应用）。

#### 2. ParNew（并行新生代）GC

- **特点**：新生代并行回收，老年代需配合 CMS；多线程处理新生代垃圾收集。
- **适用**：与 CMS 搭配使用，适合多核服务器。

#### 3. Parallel Scavenge（吞吐量优先）GC

- **特点**：新生代和老年代都可并行回收（配合 Parallel Old），目标是高吞吐量，GC 可配置最大停顿时间和吞吐量。
- **适用**：注重任务处理总量且停顿时间要求不高的后台批处理、数据分析等。

#### 4. CMS（Concurrent Mark Sweep，并发标记清除）GC  低延迟

- **特点**：老年代并发回收，尽量减少停顿时间，GC 大部分阶段与用户线程并发执行。

- **缺点**：会有“浮动垃圾”，需要“remark”阶段短暂停顿，内存碎片化严重。

- **适用**：对响应时间敏感的Web服务、互联网业务等。

- > 在JDK8中，如果你选择了CMS GC（即 `-XX:+UseConcMarkSweepGC`），那么**新生代默认会使用 ParNew GC**（并行新生代收集器）。
  >
  > ### 详细说明
  >
  > - **老年代**：CMS GC（Concurrent Mark Sweep）。
  > - **新生代**：ParNew GC（Parallel New GC）。
  >
  > ParNew GC 是专为配合 CMS 使用的多线程新生代收集器。它在新生代垃圾回收时，能利用多核 CPU 提高回收效率。
  >
  > #### 常见配置示例
  > ```shell
  > -XX:+UseConcMarkSweepGC        # 启用 CMS GC
  > -XX:ParallelGCThreads=4        # 设置 ParNew GC 的线程数（可根据CPU核数调整）
  > -XX:CMSInitiatingOccupancyFraction=75  # CMS触发阈值
  > ```
  >
  > #### 其他说明
  > - 如果你单独加 `-XX:+UseConcMarkSweepGC`，新生代自动用 ParNew GC，无需再加 `-XX:+UseParNewGC`，不过加上也没问题。
  > - 新生代**不能配合 CMS 使用 Parallel Scavenge GC**，CMS 只能与 ParNew 配合。
  >
  > ### 总结
  > **CMS GC（老年代）+ ParNew GC（新生代）**是经典组合，适合对响应时间有要求的应用。
  >
  > 如需更细致的调优建议，可以补充你的应用场景和内存配置！

#### 5. G1（Garbage First）GC

- **特点**：面向服务端应用，堆空间划分为多个Region，混合新生代和老年代管理，支持预测最大停顿时间，适合大堆高并发。
- **优点**：低停顿、高吞吐、易配置。
- **适用**：JDK9及以后推荐的服务端GC，适合对停顿时间有要求的大型应用。

#### 6. ZGC（低延迟GC，JDK11+）

- **特点**：支持TB级大堆，GC停顿时间通常低于10ms，基于“着色指针”并发回收。
- **适用**：极致低延迟场景，如金融、在线交易、实时数据处理等。

#### 7. Shenandoah（低延迟GC，JDK12+）

- **特点**：Red Hat推出的低延迟GC，回收和应用线程几乎完全并发，停顿时间与堆大小无关。
- **适用**：大型内存、低延迟需求的业务。

#### 8. 典型GC选择建议

- **小型单机/开发环境**：Serial GC
- **高并发 Web/应用服务器**：G1 GC（首选）、CMS（老项目）、Parallel GC（吞吐量优先）
- **极致低延迟/大内存**：ZGC、Shenandoah

#### 9. 常用JVM参数

- `-XX:+UseSerialGC`、`-XX:+UseParallelGC`、`-XX:+UseParallelOldGC`
- `-XX:+UseConcMarkSweepGC`
- `-XX:+UseG1GC`
- `-XX:+UseZGC`
- `-XX:+UseShenandoahGC`

### 总结性回答/提示词

- GC有串行、并行、并发、低延迟多种，按业务选型
- 响应时间敏感选CMS/G1，吞吐量优先选Parallel，高并发/大堆优先选G1、ZGC、Shenandoah
- 复习提示：**“G1服务器首选，ZGC低延迟，CMS老年代并发，Parallel吞吐量优先”**



# JVM垃圾回收器（GC）面试常见追问及参考答案

为帮助你在面试中应对GC相关的深入追问，整理如下补充内容：

---

## Serial GC

- **Q：Serial GC为什么只用一个线程？**
  - **A**：由于设计初衷是为单核、小内存环境服务，多线程反而增加线程切换和同步的开销，小型应用中单线程效率更高。
- **Q：Stop-The-World的影响？**
  - **A**：所有应用线程暂停，GC完成后才恢复，可能导致短时卡顿，但在小应用中影响有限。

---

## ParNew GC

- **Q：ParNew和Serial的本质区别？**
  - **A**：ParNew可以多线程并行处理新生代垃圾，提升多核环境下的GC效率，而Serial仅单线程。
- **Q：ParNew能独立用在生产环境吗？**
  - **A**：通常和CMS配合用，单独使用时老年代只能用Serial Old，效果有限。

---

## Parallel Scavenge（Parallel GC）

- **Q：Parallel GC与ParNew的主要侧重点区别？**
  - **A**：Parallel GC关注吞吐量（即最大化CPU利用率），而ParNew更关注缩短响应时间。
- **Q：如何根据业务选择Parallel GC？**
  - **A**：适用于批处理、科学计算等停顿时间容忍度高、追求整体处理能力的场景。

---

## CMS GC

- **Q：CMS为什么可能导致内存碎片？**
  - **A**：CMS采用“标记-清除”算法，清除垃圾对象后不进行整理，导致内存空间碎片化。
- **Q：什么情况下CMS会发生Full GC？**
  - **A**：如老年代空间不足、并发模式失败、晋升失败等情况下，CMS会退化为Serial Old执行Full GC。
- **Q：什么是浮动垃圾？**
  - **A**：并发标记期间新产生的垃圾对象，由于与用户线程并发，无法立即回收，只能等下次GC。

---

## G1 GC

- **Q：G1 GC如何实现低停顿？**
  - **A**：通过将堆分为许多小Region，按停顿目标优先选择回收垃圾最多的Region，采用增量和并发算法减少单次停顿。
- **Q：G1如何避免内存碎片？**
  - **A**：G1在回收时会做对象拷贝和整理，动态合并Region，有效避免碎片化。
- **Q：G1与CMS区别？**
  - **A**：G1按Region管理堆空间，自动整理碎片，CMS则易碎片化且不整理。

---

## ZGC & Shenandoah

- **Q：ZGC/Shenandoah如何做到堆大小无关的极低停顿？**
  - **A**：绝大部分GC阶段与应用线程并发，只有极短的标记、重定位等阶段需要短暂停顿，停顿时间和堆大小关系极小。
- **Q：二者和G1相比优势？**
  - **A**：ZGC/Shenandoah停顿时间更短、扩展性更好，适合大堆极低延迟场景，G1则在通用服务端应用中表现更均衡。

---

## 综合追问

- **Q：如何判断GC调优目标？**
  - **A**：根据业务需求选择优先级：低延迟（如Web请求）选CMS/G1/ZGC，吞吐量优先（如批量计算）选Parallel GC。
- **Q：生产环境怎么选择GC？**
  - **A**：前提是业务场景。高并发、低延迟优选G1/ZGC，老项目可用CMS，数据处理型可用Parallel。
- **Q：如何诊断GC问题？**
  - **A**：通过GC日志分析（-XX:+PrintGCDetails）、内存快照、jstat、jmap等工具，定位频繁Full GC、长时间Stop-The-World等问题。

---

## 面试总结提示

- 回答GC问题时，先讲原理，再举例子，结合业务场景说明选择理由。
- 对于“为什么”、“如何实现”、“场景适用”类追问，结合算法原理和实际效果作答。