## 高频高并发面试题 —— “高并发下如何实现分布式锁？常见方案和优缺点分析”

### 问题
在高并发分布式系统中，如何实现分布式锁？请详细说明常见的分布式锁实现方式（如基于数据库、Redis、ZooKeeper），分析它们的原理、典型应用场景、优缺点，并给出实际案例。

---

### 详细解释

#### 1. 业务场景

在分布式环境下，多个服务实例可能会同时操作同一份资源（如库存扣减、订单生成等），必须用“分布式锁”保证同一时刻只有一个实例能操作，避免超卖、数据不一致等问题。

#### 2. 常见实现方式

- **基于数据库的分布式锁**
  - 通过数据库的唯一索引或悲观锁机制（如SELECT FOR UPDATE），让同一资源只能被一个进程持有。
  - **优点**：实现简单，无需引入新组件。
  - **缺点**：性能较低，锁粒度粗，容易成为数据库瓶颈，不适合高并发场景。

- **基于Redis的分布式锁**
  - 利用Redis的SETNX（set if not exists）、EXPIRE命令实现锁的获取和超时释放。常见实现有Redisson、基于SET key value NX PX等方式。
  - **优点**：高性能，支持高并发，易于部署，社区实现丰富。
  - **缺点**：需要考虑锁失效、主从同步延迟导致的锁安全问题。需实现锁自动失效/续期和唯一标识机制。

- **基于ZooKeeper的分布式锁**
  - 通过ZooKeeper的临时顺序节点实现队列式排队获取锁，节点销毁自动释放锁。
  - **优点**：强一致性，可靠性高，适合对一致性要求极高的场景。
  - **缺点**：实现复杂，性能不如Redis，依赖ZooKeeper服务，部署运维成本高。

#### 3. 通俗例子

比如“双十一”秒杀场景，多个服务实例同时扣减商品库存。如果没有分布式锁，可能导致库存被同时扣减多次，出现超卖。采用Redis分布式锁，只有拿到锁的服务实例才能扣减库存，其他实例需等待或重试。

#### 4. 技术陷阱和优化

- Redis锁要确保锁的唯一性（如用UUID标识），避免误释放他人持有的锁。
- Redis主从切换时可能丢失锁，建议使用RedLock算法或Redisson等成熟组件。
- ZooKeeper锁适合强一致性场景但不适合极高并发。
- 数据库锁仅适合小规模、轻量场景。

---

### 总结性回答（复习提示词）

- **分布式锁方案**：数据库锁（简单低效）、Redis锁（高性能高并发）、ZooKeeper锁（强一致性）
- **高并发推荐**：Redis锁+唯一标识+自动过期，或Redisson
- **记忆口诀**：数据库易瓶颈，Redis快需防误删，ZooKeeper强一致