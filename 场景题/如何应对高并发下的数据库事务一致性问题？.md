# ☕ Java秋招高频场景题 4  
## 场景题：如何应对高并发下的数据库事务一致性问题？

---

### 🧩 **场景描述**  
你负责的支付系统在高并发场景下，偶尔出现了“超卖”或者“脏读”等问题。面试官请你分析：  
- 数据库是如何保证事务一致性的？  
- 各种隔离级别分别能解决什么问题？  
- 实际开发中该如何选择和优化？

---

### 🎯 **核心考点**

- 事务的四大特性（ACID）
- 四种隔离级别与常见并发问题（脏读、不可重复读、幻读）
- 不同隔离级别的实现原理（如MVCC、加锁）
- 实际场景下的选型与性能折中

---

### 🛠️ **详细拆解与答题要点**

#### 1. 事务四大特性（ACID）
| 特性         | 含义                   |
| ------------ | ---------------------- |
| **A** 原子性 | 要么都成功，要么都失败 |
| **C** 一致性 | 执行前后数据满足约束   |
| **I** 隔离性 | 并发事务互不干扰       |
| **D** 持久性 | 提交后数据永久保存     |

---

#### 2. 常见并发异常与隔离级别

| 并发问题     | 解释                               | 解决的隔离级别             |
| ------------ | ---------------------------------- | -------------------------- |
| 🩸 脏读       | 读到未提交数据                     | **Read Committed** 及以上  |
| 🔁 不可重复读 | 同一事务两次查询结果不同           | **Repeatable Read** 及以上 |
| 🪄 幻读       | 同一事务两次范围查询，结果数量不同 | **Serializable**           |

---

#### 3. 四种隔离级别对比

| 隔离级别         | 脏读 | 不可重复读 | 幻读 | 性能消耗  |
| ---------------- | ---- | ---------- | ---- | --------- |
| Read Uncommitted | ❌    | ❌          | ❌    | 🚀（最快） |
| Read Committed   | ✅    | ❌          | ❌    | 👍         |
| Repeatable Read  | ✅    | ✅          | ❌    | ⭕         |
| Serializable     | ✅    | ✅          | ✅    | 🐢（最慢） |

*✅：能防止该问题，❌：不能防止*

---

#### 4. 实现原理（以MySQL为例）

- Read Committed/Repeatable Read：基于**MVCC**（多版本并发控制），读操作不加锁，写操作加锁。
- Serializable：强制加锁，所有操作串行，性能最低。

---

#### 5. 实际开发场景建议

- 日常业务（如订单、库存）：**Repeatable Read**（MySQL默认）即可，性能和一致性较好。
- 高一致性场景（如金融转账）：可考虑**Serializable**，或应用层加分布式锁。
- 仅查询业务：**Read Committed**，避免脏读，提升性能。

---

#### 6. 代码实现举例（Spring）

```java
// Spring事务隔离级别设置
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void updateStock(Long productId) {
    // 扣减库存逻辑
}
```

---

### 💡 **常见陷阱**

- 只会默认隔离级别，不清楚其保护范围
- 忽略MVCC对快照读/当前读的影响
- 过度追求高隔离导致性能瓶颈

---

## 🏆 **口诀总结**

> **“脏不可幻，级级防，ACID记心上；性能权衡场景挑，默认即可大多数。”**  
>
> - 脏读选Read Committed
> - 不可重复读用Repeatable Read
> - 幻读只靠Serializable或应用加锁

---

### 📊 **思维导图（文字版）**

```
事务一致性
├── ACID
├── 隔离级别
│   ├── Read Uncommitted（基本不用）
│   ├── Read Committed（防脏读）
│   ├── Repeatable Read（防不可重复读，MySQL默认）
│   └── Serializable（全防+性能最低）
├── 实现原理
│   └── MVCC、锁
└── 场景选择
    ├── 订单、库存：Repeatable Read
    ├── 金融：Serializable或锁
    └── 查询：Read Committed
```

---

> 🔖 **面试官追问Tip：**  
> - “为什么MySQL用Repeatable Read还能防止幻读？”（答：MVCC+间隙锁）
> - “MVCC快照读与当前读区别？”（快照读不加锁，当前读加锁）