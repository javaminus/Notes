# 用@Scheduled执行定时任务，如何避免集群并发问题？

Spring的`@Scheduled`默认每个实例都会执行定时任务，集群部署时会导致**同一任务被多个节点并发执行**，产生重复、冲突等问题。

---

## 解决思路

### 1️⃣ 加分布式锁（最常用，推荐）

- **原理**：所有节点同一时刻竞争分布式锁，只有拿到锁的节点才执行任务，其他节点不执行。
- **技术方案**：
  - **基于数据库**：如`SELECT ... FOR UPDATE`悲观锁，或在表中加一行唯一索引，谁插入成功谁执行（如xxl-job原理）。
  - **基于Redis**：用`setnx`、Redisson、RedLock等实现分布式锁，推荐用非阻塞锁（tryLock），抢不到直接返回。
  - **基于Zookeeper**：利用临时有序节点或leader选举，谁成为master谁执行任务。

#### 伪代码（以Redis为例）：

```java
boolean lock = redisTemplate.opsForValue().setIfAbsent("scheduled_lock_key", instanceId, 5, TimeUnit.MINUTES);
if (lock) {
    // 执行定时任务
} else {
    // 未获得锁，不执行
}
```

### 2️⃣ 选主（Master选举）

- 利用Zookeeper、Eureka等中间件做主从选举，只有主节点负责执行定时任务，其他节点不执行。
- 选主机制本质也是分布式锁的一种变体。

### 3️⃣ 使用专业任务调度框架

- 如**XXL-JOB**、**Quartz（集群模式）**等，这类框架自带分布式调度和去重机制，天然支持只在一个节点执行任务。
- 适合任务复杂、生产环境部署。

---

## 其他思路

- **废弃@Scheduled**，直接用调度平台（如XXL-JOB、Quartz等）。
- **消息队列模式**：所有实例监听一个任务队列，任务投递到队列，只被一台机器消费。

---

## 总结

- **分布式锁/选主**：适合简单场景，代码实现快。
- **调度框架**：适合复杂、企业级需求。
- **@Scheduled**直接用在集群时务必加锁或选主，否则一定会并发执行！

> 💡 **一句话总结：在集群下用@Scheduled必须引入分布式锁或主从选举机制，确保同一任务只执行一次，避免并发问题。**