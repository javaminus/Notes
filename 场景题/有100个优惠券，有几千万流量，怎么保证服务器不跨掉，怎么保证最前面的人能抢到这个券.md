# 秒杀场景下百万并发抢100张优惠券，如何保证不超卖、不少卖、服务高可用？

## 1️⃣ 核心挑战

- **超卖问题**：100张券，不能发出101张
- **少卖问题**：100张券，只发出99张，剩余券耗尽无法再抢
- **高并发冲击**：几千万流量瞬时涌入，服务器易被打垮
- **公平性**：先到的人应该优先抢到

---

## 2️⃣ 技术方案

### 一、Redis原子扣减库存（核心！）🚦

- **所有请求先打到Redis，库存做原子扣减**
    - Redis天然单线程+原子操作，利用 Lua 脚本或 `DECR` 指令
    - 先到的请求先被处理，保证公平性
    - 库存为0时直接返回失败，后续流量不会打到DB

**Lua脚本示例：**
```lua
local key = KEYS[1]
local stock = tonumber(redis.call('get', key))
if stock > 0 then
    redis.call('decr', key)
    return 1 -- 抢券成功
else
    return 0 -- 已抢光
end
```

### 二、异步削峰（消息队列）🧊

- **为防止Redis压力过大，可将请求入队，异步处理发券逻辑**
- 只在Redis库存扣减成功后，才将请求写入MQ（如RabbitMQ/Kafka），异步发券/落库，提升系统抗压能力

### 三、限流与降级🛡️

- **网关/接口前置限流**：如Nginx、Gateway等，限制单用户/单IP频率，防止恶意刷券
- **超卖保护开关**：如果发现Redis异常、库存被打爆，可直接熔断或降级，保护后端稳定

### 四、本地标识/缓存优化⚡

- **本地缓存**维护库存是否已抢光的标识，抢光后直接拦截，减少Redis压力

---

## 3️⃣ 流程图

```
[请求涌入]
   │
   ▼
[限流/鉴权/降级]
   │
   ▼
[Redis原子扣减库存]
   │   │
   │   └─ 失败（券抢光）：立即返回
   │
   └─ 成功：入队消息队列
           │
           ▼
      [异步发券落库]
```

---

## 4️⃣ 关键点总结

- **所有抢券请求必须先经过Redis原子扣减，保证不超卖/不少卖**
- **Redis串行处理请求，先到先服务，保证公平**
- **后端数据库异步落券，彻底削峰填谷，避免数据库被打垮**
- **配合限流、本地缓存进一步优化高并发下的系统稳定性**

---

> 这就是典型秒杀系统的设计思路，重点要能讲清楚Redis原子扣减+异步削峰+限流降级+公平性保障等核心机制。