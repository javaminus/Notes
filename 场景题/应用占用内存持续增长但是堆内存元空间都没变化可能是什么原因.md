# 应用占用内存持续增长，但是堆内存、元空间都没变化，可能是什么原因？

如果应用进程的总内存持续增长，但JVM堆和元空间占用没有明显变化，**大概率是堆外内存**（Off-Heap Memory）在增加。常见原因如下：

---

## 1. ByteBuffer未及时回收

Java NIO 的 `ByteBuffer.allocateDirect` 会分配直接内存（堆外内存），如果没有正确释放，可能导致堆外内存泄漏。

- 堆上只存放 `ByteBuffer` 对象本身，其关联的堆外内存可能非常大。
- 检查是否存在大量未释放的 Direct ByteBuffer 对象。

---

## 2. 堆外缓存框架使用不当

一些缓存框架（如 Ehcache、MapDB、OHC 等）会用堆外内存提升缓存性能。
- 若未设置合理的缓存过期策略，缓存数据长期无法清理，导致堆外内存持续增长。

---

## 3. 日志文件内存映射（Memory Mapped File）

很多日志框架支持内存映射文件（Memory Mapped File Appender），通过将日志文件内容映射到应用进程的地址空间，提高写入性能。
- 随着日志文件增长，映射到内存空间的大小也增长，占用堆外内存。

---

## 4. JNI和本地代码

应用通过 Java 本地接口（JNI）或调用 C/C++ 等本地库时，本地代码可能会分配和持有大量内存，这部分不会体现在 JVM 堆或元空间。
- 检查是否有大量本地库调用或第三方原生组件。

---

## 5. 线程栈内存

每个线程都有自己的栈空间，随着线程数量增加，线程栈占用的内存也会增加。
- 线程栈属于进程内存，但不属于 JVM 堆或元空间。

---

## 总结

应用总内存持续增长但堆内存、元空间无变化时，**重点排查堆外内存的分配和回收情况**。  
常见原因包括：Direct ByteBuffer泄漏、堆外缓存、内存映射文件、JNI本地代码、线程栈等。

建议：
- 使用工具如 `jcmd`, `jmap`, `NMT (Native Memory Tracking)`，或 `pmap`、`top` 等操作系统命令排查进程内存分布
- 排查代码和第三方库是否有堆外内存分配未释放