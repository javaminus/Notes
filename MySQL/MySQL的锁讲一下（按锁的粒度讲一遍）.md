MySQL的锁按照**粒度**（即作用范围的大小）可以分为以下几类（从大到小）：

---

## 1. 全局锁（Global Lock）
- **范围**：整个数据库实例（所有库所有表）。
- **常用场景**：全库备份（如FLUSH TABLES WITH READ LOCK）。
- **特点**：加锁后，整个数据库只允许读操作，不允许写操作，影响最大。

---

## 2. 表级锁（Table Lock）
- **范围**：单张表。
- **常用场景**：MyISAM存储引擎、DDL操作、LOCK TABLES语句。
- **特点**：加锁快、开销小，不会死锁，但并发能力低。

---

## 3. 页级锁（Page Lock）
- **范围**：一页（多个连续的记录，通常为数据库存储的物理页）。
- **常用场景**：BDB存储引擎（MySQL默认的InnoDB并不使用页锁）。
- **特点**：粒度介于表锁和行锁之间，能够减少锁冲突，提高并发，但容易死锁。

---

## 4. 行级锁（Row Lock）
- **范围**：单行数据。
- **常用场景**：InnoDB存储引擎（MySQL 默认存储引擎）。
- **特点**：粒度最小，并发度最高，但加锁开销大，容易死锁。

---

## 总结表

| 锁粒度 | 作用范围 | 并发能力 | 死锁可能性 | 典型应用       |
| ------ | -------- | -------- | ---------- | -------------- |
| 全局锁 | 整个实例 | 最低     | 无         | 全库备份       |
| 表级锁 | 单张表   | 较低     | 无         | MyISAM、DDL    |
| 页级锁 | 一页数据 | 中等     | 有         | BDB引擎        |
| 行级锁 | 单行数据 | 最高     | 有         | InnoDB（默认） |

---

## 备注
- 锁的粒度越小，并发性能越高，但管理开销越大。
- InnoDB实际还包括间隙锁（Gap Lock）、Next-Key Lock等特殊行锁机制，用于解决幻读等问题。
- 不同存储引擎支持的锁粒度不同：MyISAM支持表锁，InnoDB支持行锁和表锁，BDB支持页锁。

如需了解每种锁的用法、SQL示例或具体实现细节，可以继续提问！

## 面试官可能追问的问题和答案

### 1. 为什么InnoDB要用行级锁，而MyISAM只支持表级锁？
**答**：InnoDB主要面向高并发场景，行锁可以极大提高并发能力；而MyISAM设计简单，只支持表锁，适合读多写少的场景，锁管理和实现成本较低。

---

### 2. 行级锁是怎么实现的？
**答**：InnoDB的行锁是通过索引项加锁实现的（记录锁）；只有通过索引条件检索数据时才会真正加到行锁，否则会退化为表锁。

---

### 3. InnoDB的间隙锁（Gap Lock）和Next-Key Lock是什么？
**答**：间隙锁锁定一个范围，不锁定具体行，用于防止“幻读”；Next-Key Lock是行锁+间隙锁的组合，锁定一行及其前后的间隙，确保事务隔离级别下的数据一致性。

---

### 4. 如何查看当前数据库加了哪些锁？
**答**：可通过`SHOW ENGINE INNODB STATUS`命令查看当前InnoDB的锁等待和死锁信息；也可查`information_schema.innodb_locks`等表。

---

### 5. 行锁会不会退化成表锁？什么时候会？
**答**：会。当查询不走索引（全表扫描）或索引失效时，InnoDB会退化为表锁，导致并发性能下降。

---

### 6. 死锁发生后如何处理？
**答**：InnoDB有死锁检测机制，自动回滚其中一个事务；也可通过合理设计SQL和索引、缩短事务时间、控制并发等方式预防死锁。