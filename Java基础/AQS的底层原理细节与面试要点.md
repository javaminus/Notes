# 🔥 补充说明：AQS的底层原理细节与面试要点

---

## 1️⃣ AQS的底层结构

- **同步状态（state）**  
  - 本质是一个volatile int变量，表示资源状态。
  - 通过CAS（Compare-And-Swap）原子操作进行修改，保证并发安全。

- **等待队列（CLH队列）**  
  - 本质是一个FIFO的双向链表。
  - 队列中的每个节点（Node）都代表一个被挂起的线程。
  - 线程竞争资源失败后，进入队列并阻塞，等待被唤醒。

---

## 2️⃣ 线程的挂起与唤醒

- 挂起：线程获取资源失败，AQS会通过LockSupport.park()方法让其阻塞。
- 唤醒：前驱节点释放资源后，AQS会通过LockSupport.unpark()唤醒下一个节点对应的线程。

---

## 3️⃣ 独占与共享的实现区别

- **独占模式**：同一时刻只允许一个线程获取资源（如ReentrantLock）。
  - 相关方法：`tryAcquire()`、`tryRelease()`
- **共享模式**：允许多个线程同时获取资源（如Semaphore、CountDownLatch）。
  - 相关方法：`tryAcquireShared()`、`tryReleaseShared()`

---

## 4️⃣ 面试高频考点总结

1. **AQS的设计模式**：模板方法模式，子类只需关注如何获取/释放资源，队列管理由AQS完成。
2. **为什么AQS能够实现公平锁和非公平锁？**
   - 公平锁：按队列顺序唤醒线程
   - 非公平锁：允许插队，可能跳过等待队列直接竞争
3. **state原子性如何保证？**
   - 依靠CAS操作实现原子性修改
4. **阻塞和唤醒如何实现？**
   - 基于LockSupport.park()/unpark()，高效实现线程的挂起和恢复

---

## 5️⃣ 常见场景举例

- **ReentrantLock**：独占锁，支持公平/非公平
- **Semaphore**：限流，典型的共享模式
- **CountDownLatch**：线程等待其他线程完成任务
- **CyclicBarrier**：批量线程同步

---

## 6️⃣ 记忆口诀

> **AQS四字诀：状态、队列、挂起、唤醒，模板方法，独占共享，全搞定！**

---

## 7️⃣ 面试简答建议

- 用简明语言描述AQS的结构（state+队列），说明其支持的两种模式；
- 能举出常见实现类，并解释其底层原理；
- 强调AQS模板方法思想，子类只需实现资源获取/释放逻辑。

---