# TCP 三次握手与四次挥手详解

## 一、TCP三次握手（Three-way Handshake）

当然可以，下面我用**通俗生活例子 + 原理细节 + 逐步解析**来讲清楚：

------

## 🎯 目标：

### 明白 **TCP 为什么要“三次握手”建立连接，四次挥手断开连接”**，而不能多一次或少一次？

------

## 🧃 一、通俗举例：三次握手 = “我能听见你 + 你能听见我 + 我知道你能听见我”

想象你和朋友小明要在操场上打电话，但没有手机，只能靠喊：

### 📶 第一步：你大喊：

> 你：“小明你在吗？”（**SYN**）

小明听到了你，说明**你能发，小明能收**。

------

### 📶 第二步：小明大喊：

> 小明：“我在！你在吗？”（**SYN + ACK**）

你听到了小明，说明**小明也能发，你能收**。

------

### 📶 第三步：你再大喊：

> 你：“我知道你能听见我！”（**ACK**）

至此，双向通信完全建立：你能发，小明能收，小明能发，你也能收，**而且双方都知道这一点了！**

------

### ❓ 如果只有两次握手会怎样？

你喊：“你在吗？”

小明回：“我在！”

你这时候突然断线了，小明以为你在线，其实你已经走了！

> ⚠️ 没有第三步确认，就会出现“**伪连接**”——服务器误以为客户端还在，白白浪费资源。

------

## 🧠 技术细节（三次握手）

```
客户端（Client）                   服务端（Server）
   SYN ---------------------------->
        [请求建立连接，seq=x]

                       <---------- SYN + ACK
                        [确认收到，seq=y, ack=x+1]

   ACK ---------------------------->
        [确认服务端，ack=y+1]
```

- `SYN`：请求建立连接
- `ACK`：确认收到
- `seq`：序列号
- `ack`：确认号（对方序列号 + 1）

每一步都包含一个**序列号确认**，确保双方发送与接收能力都 OK。

------

## 🍵 二、通俗举例：四次挥手 = “我要走了 + 好的 + 我也走了 + 好的”

继续刚才例子，打完电话后：

### 📶 第一步（你说）：

> 你：“我说完了，我要挂电话了！”（**FIN**）

------

### 📶 第二步（小明回）：

> 小明：“好，我知道你说完了！”（**ACK**）

但是小明还有话没说完，所以他还在说话……

------

### 📶 第三步（小明说完了）：

> 小明：“我也说完了！”（**FIN**）

------

### 📶 第四步（你回）：

> 你：“好，我知道你也说完了！”（**ACK**）

两个人都“说完”并且“确认说完”，这才是真的**彻底断开连接**。

------

### ❓ 如果只有三次挥手会怎样？

比如合并成这样：

> 你：“我说完了！”
>  小明：“好，我也说完了！”
>  你：“好！”

但小明可能还没说完，就“误以为你挂了”，丢失最后一段话。

------

## 🧠 技术细节（四次挥手）

```
客户端                             服务端
 FIN ---------------------------->  // 客户端说我说完了（主动关闭）

                          <------ ACK
                                // 服务端确认收到

                          <------ FIN
                                // 服务端也说完了（被动关闭）

 ACK ----------------------------> // 客户端确认
```

------

## 🚦 最后总结（面试用语+类比记忆）

| 步骤       | TCP术语          | 类比                     | 目的                        |
| ---------- | ---------------- | ------------------------ | --------------------------- |
| 第一次握手 | Client → SYN     | 我想和你说话             | 确认客户端能发送            |
| 第二次握手 | Server → SYN+ACK | 我能听到你，你能听到我吗 | 确认服务器能发送 + 收到请求 |
| 第三次握手 | Client → ACK     | 我能听到你               | 客户端确认，连接建立完毕    |
|            |                  |                          |                             |
| 第一次挥手 | Client → FIN     | 我说完了                 | 客户端主动关闭写通道        |
| 第二次挥手 | Server → ACK     | 我知道你说完了           | 确认客户端请求关闭          |
| 第三次挥手 | Server → FIN     | 我也说完了               | 服务端也准备关闭            |
| 第四次挥手 | Client → ACK     | 我知道你说完了           | 最终确认，连接完全断开      |

------

如果你愿意，我还可以为你画一个“动画式”时序图（用 Mermaid）来进一步直观展示，是否需要？

### 目的
建立可靠的连接，保证双方收发能力正常。

### 过程详解

1. **第一次握手（SYN）**
   - 客户端发送SYN包（SYN=1, **seq=x**）到服务器，进入SYN_SEND状态，表示希望建立连接。

2. **第二次握手（SYN-ACK）**
   - 服务器收到SYN后，回复SYN+ACK包（SYN=1, ACK=1, **seq=y, ack=x+1**），进入SYN_RCVD状态。

3. **第三次握手（ACK）**
   - 客户端收到SYN+ACK后，回复ACK包（ACK=1, **seq=x+1, ack=y+1**），进入ESTABLISHED状态，服务器收到ACK后也进入ESTABLISHED状态，连接建立成功。

```
客户端                       服务器
  | ---------SYN(x)--------> |
  | <-----SYN(y)ACK(x+1)---- |
  | ---------ACK(y+1)------> |
```

---

## 二、TCP四次挥手（Four-way Handshake）

### 目的
可靠地断开连接，确保数据传输完成。

### 过程详解

1. **第一次挥手（FIN）**
   - 主动关闭方发送FIN包（FIN=1, seq=u），进入FIN_WAIT_1状态。

2. **第二次挥手（ACK）**
   - 被动方收到FIN，回复ACK包（ACK=1, seq=v, ack=u+1），进入CLOSE_WAIT状态，主动方收到ACK后进入FIN_WAIT_2状态。

3. **第三次挥手（FIN）**
   - 被动方准备关闭连接时，发送FIN包（FIN=1, seq=w），进入LAST_ACK状态。

4. **第四次挥手（ACK）**
   - 主动方收到FIN后，回复ACK包（ACK=1, seq=u+1, ack=w+1），进入TIME_WAIT状态，等待2MSL后进入CLOSED状态。被动方收到ACK后进入CLOSED状态。

```
主动关闭方                   被动关闭方
  | ---------FIN(u)--------> |
  | <--------ACK(u+1)------- |
  | <--------FIN(w)--------- |
  | ---------ACK(w+1)------> |
```

---

## 三、面试高频追问与参考答案

### 1. **为什么三次握手不是两次？**

**答：**
两次握手无法保证客户端和服务器的收发能力都正常。三次握手可以确认：
- 客户端能发、能收（第二次握手收到SYN+ACK）

- 服务器能发、能收（第三次握手收到ACK）

- > “三次握手”而不是“两次握手”是因为需要保证通信双方都能确认彼此的接收和发送能力。  
  > 简单来说：
  >
  > - **第一次**：客户端发送SYN包（请求建立连接），告诉服务器“我想和你通信”。
  > - **第二次**：服务器收到后，回复SYN+ACK包，告诉客户端“我收到了你的请求，也想和你通信”。
  > - **第三次**：客户端收到SYN+ACK后，再发送ACK包，告诉服务器“我收到了你的回复，现在我们可以通信了”。
  >
  > ### 如果只用“两次握手”会有什么问题？
  >
  > 如果只用两次：
  >
  > 1. 客户端发送SYN，服务器回SYN+ACK，连接就建立了。
  > 2. 但如果服务器的SYN+ACK由于网络等原因**没有被客户端收到**，客户端会以为没建立成功，服务器却以为已经建立成功。这样服务器会一直等待客户端的数据，浪费资源，出现**半连接**（半开连接）状态。
  >
  > “三次握手”中的第三步就是让服务器**确认客户端收到了自己的应答包**，从而双方都明确连接真正建立。
  >
  > ### 总结
  >
  > 三次握手可以**防止历史连接请求造成的混乱**，确保**双方都能正常收发数据**，避免资源浪费和状态不同步问题。
  >
  > 如需详细时序图或代码示例可进一步说明！

### 2. **为什么四次挥手不是三次？**

**答：**
TCP是全双工通信，双方都要单独关闭自己的发送通道。被动方收到FIN后，可能还有数据未发送完，所以需要分开发送ACK和FIN。

> TCP连接的“四次挥手”而不是“三次挥手”，是因为TCP的关闭是**双向的**，需要确保双方都能完全、可靠地终止数据收发。下面详细解释原因：
>
> ---
>
> ### TCP四次挥手过程
>
> 1. **第一次挥手**：客户端发送FIN，表示“我不再发送数据了，但还能接收你发的数据”。
> 2. **第二次挥手**：服务器收到FIN后，发送ACK，表示“我知道你不再发数据了”。
> 3. **第三次挥手**：服务器准备好后，发送自己的FIN，表示“我也不再发数据了”。
> 4. **第四次挥手**：客户端收到FIN后，发送ACK，表示“我知道你也不再发数据了”，连接正式关闭。
>
> ---
>
> ### 为什么不能用三次？
>
> 因为TCP的关闭是**单向独立**的，双方的**发送和接收状态需要分别关闭**：
>
> - 当一方（如客户端）发送FIN后，只是表示它的数据已经发送完毕，但它还可以接收服务器的数据。
> - 服务器收到FIN，确认后，可能还有数据要发送给客户端，所以不能马上关闭，必须等服务器也发送完数据，再发送自己的FIN。
> - 如果用三次挥手，比如把“服务器的ACK和FIN合并”，那服务器还没发送完数据就告诉对方“我要关闭了”，这会导致有数据丢失的风险。
>
> ---
>
> ### 总结
>
> - **四次挥手**保证双方都能各自独立地完成数据的发送和确认，彻底关闭连接，防止数据丢失。
> - 每一端的关闭都要被对方确认，所以需要分别发送和确认两次，共计四次。
>
> 如需详细时序图或举例说明，可以进一步补充！

### 追问：为什么第四次挥手不能取消？

> 第四次挥手（即客户端最后发送的ACK）**不能取消**，原因如下：
>
> ### 1. 确保可靠关闭
> - **第三次挥手**（服务器发送FIN）表示服务器也完成了数据的发送，请求关闭连接。
> - 客户端收到后，**必须回复ACK**，告诉服务器“我已经收到你关闭的请求”。
> - **如果没有这次ACK，服务器无法确认客户端是否真正收到了FIN**，就不能安全地释放资源，可能会一直等待导致资源浪费。
>
> ### 2. 保障双方状态一致
> - TCP是面向连接的协议，双方都需要明确：**连接已经被对方安全关闭**。
> - 第四次ACK让服务器知道自己的关闭请求被对方接受，防止“连接半开”状态。
>
> ### 3. 有丢包重传机制
> - 如果ACK丢失，服务器会重发FIN，客户端会再次发送ACK，直到服务器确认收到为止。
> - 这是TCP“可靠传输”的核心机制之一。
>
> ### 4. TCP 协议规范要求
> - 根据 [RFC 793](https://datatracker.ietf.org/doc/html/rfc793) 的规定，**每个FIN必须被ACK确认**，以确保双方都完成了各自方向的数据流关闭。
>
> ---
>
> **总结**：  
> 第四次挥手（ACK）是保证连接可靠完全关闭、避免资源泄漏和状态不一致的关键步骤，**不能省略**。

### 3. **TIME_WAIT状态存在的原因？**

**答：**
- 保证最后一个ACK能让对方收到，防止丢失导致对方无法正常关闭。

- 防止旧连接的重复报文影响新连接。

- 你提到的两个原因 **都是对的**，特别是第二点常被忽视但非常关键。下面我将详细解释为什么 TCP 主动关闭方会进入 `TIME_WAIT` 状态，以及这两个核心原因背后的原理。

  ------

  ## 🧠 什么是 `TIME_WAIT`？

  在 **TCP 四次挥手**中，**主动关闭连接的一方**（通常是客户端）在发送完最后一个 `ACK` 后，并不会立刻关闭连接，而是会进入一个**`TIME_WAIT` 状态，保持一段时间（默认 2 * MSL）**。

  > MSL：Maximum Segment Lifetime，报文在网络中最多可以存在的时间，常设为 30~60 秒。

  因此，`TIME_WAIT` 会持续 1~2 分钟，期间该连接的端口不能立即复用。

  ------

  ## ✅ 原因一：**确保对方收到 ACK（连接可靠关闭）**

  ### 🧾 背景：

  TCP 是一个可靠的协议，每一个 FIN 都必须被确认。如果我们是主动方，发送了最后一个 `ACK` 后**立即关闭连接**，可能会导致如下问题：

  ### ❗ 问题场景：

  - 服务端发出 `FIN`（第三次挥手）
  - 客户端（主动方）收到 `FIN`，立即发送 `ACK`
  - 但这个 `ACK` **在网络中丢了**
  - 服务端在超时后，**重发 FIN**
  - 如果客户端已经关闭，**它就无法回应 ACK，服务端会认为连接关闭失败**

  ### ✅ TIME_WAIT 的作用：

  客户端保持 `TIME_WAIT`，可以**收到这个重发的 FIN，并再次发 ACK**，保证连接可靠终止，避免资源泄露。

  ------

  ## ✅ 原因二：**防止旧数据包影响新连接（端口号复用安全）**

  ### 🧾 背景：

  TCP 的连接由四元组标识：

  ```
  <源IP, 源端口, 目标IP, 目标端口>
  ```

  如果一个旧连接刚刚断开，立刻建立一个相同四元组的新连接，那么之前连接中**未消失的老数据包**可能会误投到新的连接里。

  ### ❗ 问题场景：

  1. 旧连接未完全断开，网络中还滞留某个数据包。
  2. 客户端立即重用相同端口，发起新连接（IP和端口都一样）。
  3. 新连接收到了旧连接的残留包（如旧的 ACK、FIN）。
  4. **数据错乱**，导致严重 bug。

  ### ✅ TIME_WAIT 的作用：

  在 `TIME_WAIT` 持续时间内，**不会让相同四元组的连接再次建立**，从而保证老连接的数据包在网络中“自然消失”，避免干扰新连接。

  ------

  ## 🧯 如果没有 `TIME_WAIT` 会怎样？

  - ❌ 服务端可能**无限等待**最后一个 ACK（连接无法关闭）
  - ❌ 新连接可能收到老连接的包（造成数据污染、程序异常）
  - ❌ 增加 TCP 协议设计复杂度，不再是“可靠”的传输层协议

  ------

  ## 🧪 实际举例：高并发下的 `TIME_WAIT` 问题

  服务端在短时间内处理大量短连接，会产生**大量 TIME_WAIT 状态连接**，容易造成端口耗尽、资源占满。

  ### 🧰 解决策略（不是建议绕开 TIME_WAIT，而是合理管理）：

  - **增加临时端口范围**（Linux: `/proc/sys/net/ipv4/ip_local_port_range`）
  - **开启端口快速重用**（`SO_REUSEADDR`，但必须理解其风险）
  - 使用长连接或连接池

  ------

  ## ✅ 总结

  | 原因                    | 说明                                               |
  | ----------------------- | -------------------------------------------------- |
  | 1. 确保对方收到 ACK     | 如果 ACK 丢了，对方会重发 FIN，主动方需要重发 ACK  |
  | 2. 防止老数据干扰新连接 | 让旧连接的包完全过期后，才能建立相同四元组的新连接 |

  ------

  ### 🧠 一句话记忆：

  > `TIME_WAIT` 是 TCP 保护 **可靠性与数据一致性** 的“余温保护期”。

### 4. **SYN攻击是什么？如何防御？**

**答：**
**SYN攻击**：攻击者发送大量SYN请求但不回应服务器的SYN-ACK，导致服务器资源耗尽。
**防御措施**：
- SYN Cookie技术
- 限制半连接数量和超时时间

### 5. **三次握手过程中能携带数据吗？**

**答：**
- 客户端第三次握手可以携带数据，前两次不建议携带。
- 服务器在第二次回复SYN+ACK时一般不携带数据。

### 6. **CLOSE_WAIT状态过多的原因？**

**答：**
- 说明服务器没有及时关闭连接，通常是程序未调用close()，需检查业务逻辑。

---

## 四、扩展知识点

- **RST包的作用**：强制关闭连接。
- **为什么需要MSL（最大报文生存时间）？**：确保旧报文不会影响新连接，保证连接可靠关闭。
- **连接建立与断开状态机图**：建议面试前画一遍，加深理解。

---

> 面试时，建议结合实际场景和状态机图解释，可以加分。