# TCP 三次握手与四次挥手详解

## 一、TCP三次握手（Three-way Handshake）

### 目的
建立可靠的连接，保证双方收发能力正常。

### 过程详解

1. **第一次握手（SYN）**
   - 客户端发送SYN包（SYN=1, seq=x）到服务器，进入SYN_SEND状态，表示希望建立连接。

2. **第二次握手（SYN-ACK）**
   - 服务器收到SYN后，回复SYN+ACK包（SYN=1, ACK=1, seq=y, ack=x+1），进入SYN_RCVD状态。

3. **第三次握手（ACK）**
   - 客户端收到SYN+ACK后，回复ACK包（ACK=1, seq=x+1, ack=y+1），进入ESTABLISHED状态，服务器收到ACK后也进入ESTABLISHED状态，连接建立成功。

```
客户端                       服务器
  | ---------SYN(x)--------> |
  | <-----SYN(y)ACK(x+1)---- |
  | ---------ACK(y+1)------> |
```

---

## 二、TCP四次挥手（Four-way Handshake）

### 目的
可靠地断开连接，确保数据传输完成。

### 过程详解

1. **第一次挥手（FIN）**
   - 主动关闭方发送FIN包（FIN=1, seq=u），进入FIN_WAIT_1状态。

2. **第二次挥手（ACK）**
   - 被动方收到FIN，回复ACK包（ACK=1, seq=v, ack=u+1），进入CLOSE_WAIT状态，主动方收到ACK后进入FIN_WAIT_2状态。

3. **第三次挥手（FIN）**
   - 被动方准备关闭连接时，发送FIN包（FIN=1, seq=w），进入LAST_ACK状态。

4. **第四次挥手（ACK）**
   - 主动方收到FIN后，回复ACK包（ACK=1, seq=u+1, ack=w+1），进入TIME_WAIT状态，等待2MSL后进入CLOSED状态。被动方收到ACK后进入CLOSED状态。

```
主动关闭方                   被动关闭方
  | ---------FIN(u)--------> |
  | <--------ACK(u+1)------- |
  | <--------FIN(w)--------- |
  | ---------ACK(w+1)------> |
```

---

## 三、面试高频追问与参考答案

### 1. **为什么三次握手不是两次？**

**答：**
两次握手无法保证客户端和服务器的收发能力都正常。三次握手可以确认：
- 客户端能发、能收（第二次握手收到SYN+ACK）

- 服务器能发、能收（第三次握手收到ACK）

- > “三次握手”而不是“两次握手”是因为需要保证通信双方都能确认彼此的接收和发送能力。  
  > 简单来说：
  >
  > - **第一次**：客户端发送SYN包（请求建立连接），告诉服务器“我想和你通信”。
  > - **第二次**：服务器收到后，回复SYN+ACK包，告诉客户端“我收到了你的请求，也想和你通信”。
  > - **第三次**：客户端收到SYN+ACK后，再发送ACK包，告诉服务器“我收到了你的回复，现在我们可以通信了”。
  >
  > ### 如果只用“两次握手”会有什么问题？
  >
  > 如果只用两次：
  >
  > 1. 客户端发送SYN，服务器回SYN+ACK，连接就建立了。
  > 2. 但如果服务器的SYN+ACK由于网络等原因**没有被客户端收到**，客户端会以为没建立成功，服务器却以为已经建立成功。这样服务器会一直等待客户端的数据，浪费资源，出现**半连接**（半开连接）状态。
  >
  > “三次握手”中的第三步就是让服务器**确认客户端收到了自己的应答包**，从而双方都明确连接真正建立。
  >
  > ### 总结
  >
  > 三次握手可以**防止历史连接请求造成的混乱**，确保**双方都能正常收发数据**，避免资源浪费和状态不同步问题。
  >
  > 如需详细时序图或代码示例可进一步说明！

### 2. **为什么四次挥手不是三次？**

**答：**
TCP是全双工通信，双方都要单独关闭自己的发送通道。被动方收到FIN后，可能还有数据未发送完，所以需要分开发送ACK和FIN。

> TCP连接的“四次挥手”而不是“三次挥手”，是因为TCP的关闭是**双向的**，需要确保双方都能完全、可靠地终止数据收发。下面详细解释原因：
>
> ---
>
> ### TCP四次挥手过程
>
> 1. **第一次挥手**：客户端发送FIN，表示“我不再发送数据了，但还能接收你发的数据”。
> 2. **第二次挥手**：服务器收到FIN后，发送ACK，表示“我知道你不再发数据了”。
> 3. **第三次挥手**：服务器准备好后，发送自己的FIN，表示“我也不再发数据了”。
> 4. **第四次挥手**：客户端收到FIN后，发送ACK，表示“我知道你也不再发数据了”，连接正式关闭。
>
> ---
>
> ### 为什么不能用三次？
>
> 因为TCP的关闭是**单向独立**的，双方的**发送和接收状态需要分别关闭**：
>
> - 当一方（如客户端）发送FIN后，只是表示它的数据已经发送完毕，但它还可以接收服务器的数据。
> - 服务器收到FIN，确认后，可能还有数据要发送给客户端，所以不能马上关闭，必须等服务器也发送完数据，再发送自己的FIN。
> - 如果用三次挥手，比如把“服务器的ACK和FIN合并”，那服务器还没发送完数据就告诉对方“我要关闭了”，这会导致有数据丢失的风险。
>
> ---
>
> ### 总结
>
> - **四次挥手**保证双方都能各自独立地完成数据的发送和确认，彻底关闭连接，防止数据丢失。
> - 每一端的关闭都要被对方确认，所以需要分别发送和确认两次，共计四次。
>
> 如需详细时序图或举例说明，可以进一步补充！

### 追问：为什么第四次挥手不能取消？

> 第四次挥手（即客户端最后发送的ACK）**不能取消**，原因如下：
>
> ### 1. 确保可靠关闭
> - **第三次挥手**（服务器发送FIN）表示服务器也完成了数据的发送，请求关闭连接。
> - 客户端收到后，**必须回复ACK**，告诉服务器“我已经收到你关闭的请求”。
> - **如果没有这次ACK，服务器无法确认客户端是否真正收到了FIN**，就不能安全地释放资源，可能会一直等待导致资源浪费。
>
> ### 2. 保障双方状态一致
> - TCP是面向连接的协议，双方都需要明确：**连接已经被对方安全关闭**。
> - 第四次ACK让服务器知道自己的关闭请求被对方接受，防止“连接半开”状态。
>
> ### 3. 有丢包重传机制
> - 如果ACK丢失，服务器会重发FIN，客户端会再次发送ACK，直到服务器确认收到为止。
> - 这是TCP“可靠传输”的核心机制之一。
>
> ### 4. TCP 协议规范要求
> - 根据 [RFC 793](https://datatracker.ietf.org/doc/html/rfc793) 的规定，**每个FIN必须被ACK确认**，以确保双方都完成了各自方向的数据流关闭。
>
> ---
>
> **总结**：  
> 第四次挥手（ACK）是保证连接可靠完全关闭、避免资源泄漏和状态不一致的关键步骤，**不能省略**。

### 3. **TIME_WAIT状态存在的原因？**

**答：**
- 保证最后一个ACK能让对方收到，防止丢失导致对方无法正常关闭。

- 防止旧连接的重复报文影响新连接。

- > 问题：Time_wait状态也就是最后一个挥手之后，主动断开方需要等待的时间吗？ 
  >
  > 是的，**TIME_WAIT状态**就是主动断开连接的一方，在最后一个挥手（即发送ACK）后需要等待的一段时间。
  >
  > ### 详细解释
  >
  > - 当主动断开方（通常是客户端）发送完最后一个ACK之后，连接并不会立即释放，而是进入**TIME_WAIT**状态。
  > - 在TIME_WAIT状态下，主动方需要等待**2倍MSL（Maximum Segment Lifetime，最大报文段生存时间）**，一般为1~4分钟。
  >
  > ### 为什么要有TIME_WAIT？
  >
  > 1. **确保对方收到ACK**  
  >    如果最后一个ACK丢失，对方会重发FIN，这时主动方还可以再次发送ACK，保证连接可靠关闭。
  >
  > 2. **防止旧数据包影响新连接**  
  >    保证网络中的延迟数据包不会影响后续可能建立的同一端口的新连接。
  >
  > ### 总结
  >
  > - **TIME_WAIT**状态确实是主动断开方在最后一个挥手（ACK）后需要等待的时间。
  > - 等待结束后，系统才会彻底释放这次TCP连接相关的资源。
  >
  > 如果还想了解TIME_WAIT状态如何优化或其在服务器高并发下的影响，可以继续提问！

### 4. **SYN攻击是什么？如何防御？**

**答：**
**SYN攻击**：攻击者发送大量SYN请求但不回应服务器的SYN-ACK，导致服务器资源耗尽。
**防御措施**：
- SYN Cookie技术
- 限制半连接数量和超时时间

### 5. **三次握手过程中能携带数据吗？**

**答：**
- 客户端第三次握手可以携带数据，前两次不建议携带。
- 服务器在第二次回复SYN+ACK时一般不携带数据。

### 6. **CLOSE_WAIT状态过多的原因？**

**答：**
- 说明服务器没有及时关闭连接，通常是程序未调用close()，需检查业务逻辑。

---

## 四、扩展知识点

- **RST包的作用**：强制关闭连接。
- **为什么需要MSL（最大报文生存时间）？**：确保旧报文不会影响新连接，保证连接可靠关闭。
- **连接建立与断开状态机图**：建议面试前画一遍，加深理解。

---

> 面试时，建议结合实际场景和状态机图解释，可以加分。