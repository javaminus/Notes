## 问题：什么是逃逸分析？它是如何优化对象分配和同步的？

### 详细解释

**逃逸分析**（Escape Analysis）是JVM在JIT（即时编译）期间进行的一种静态代码分析技术。它的主要目的是判断对象的作用域（即对象是否会“逃逸”出方法之外）。通过逃逸分析，JVM可以对对象分配和锁优化进行一系列的性能提升。

#### 1. 逃逸分析的三种情况

- **无逃逸（No Escape）**：对象只在当前方法内被使用，不会被其他方法引用。
- **方法逃逸（Method Escape）**：对象作为参数传递到其他方法，但不会被线程外部引用。
- **线程逃逸（Thread Escape）**：对象可能被其他线程引用，如赋值给类成员变量或外部可见的静态字段。

#### 2. 优化方式

- **栈上分配**  
  如果一个对象不会逃离方法（无逃逸），JVM会将其分配在栈上，而不是堆上。这样对象在方法结束后能自动销毁，减少GC负担。
- **标量替换**  
  如果对象的字段可以被单独访问，JVM会将对象拆成若干个标量变量，避免真正分配对象实例。
- **同步消除**  
  如果对象不会被多线程共享，JVM会消除不必要的同步（如`synchronized`块中的锁），提升并发性能。

#### 3. 场景与例子

**场景1：普通方法内的临时对象**

```java
public void calculate() {
    Point p = new Point(1, 2); // 只在方法内使用
    int sum = p.x + p.y;
}
```
> 逃逸分析会发现`p`未逃逸出`calculate()`方法，可以栈上分配，无需GC。

**场景2：对象作为参数传递**

```java
public void process() {
    Data data = new Data();
    compute(data);
}
private void compute(Data d) {
    // 只在当前线程内使用
}
```
> `data`仅在当前线程内活动，也可进行优化。

**场景3：对象逃逸到线程外**

```java
private Data shared;
public void run() {
    shared = new Data(); // 赋值给成员变量，可能被其他线程访问
}
```
> 这种情况下，对象分配无法优化。

#### 4. JVM参数

- `-XX:+DoEscapeAnalysis`（默认开启）：启用逃逸分析
- `-XX:+EliminateAllocations`：开启标量替换
- `-XX:+EliminateLocks`：开启同步消除

### 总结性回答/提示词

- 逃逸分析：判断对象作用域，决定对象分配位置和优化锁
- 优化点：栈上分配、标量替换、同步消除
- 典型例子：方法内临时对象、同步块优化
- 相关JVM参数：`-XX:+DoEscapeAnalysis`
- 复习提示：**“判断对象是否只在方法内使用，能否避免堆分配和无用同步”**