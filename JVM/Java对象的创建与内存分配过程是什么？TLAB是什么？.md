## 问题7：Java对象的创建与内存分配过程是什么？TLAB是什么？

深入理解对象创建与内存分配，能够帮助我们诊断大对象分配延迟、频繁 GC 问题，并优化并发场景下的分配性能。

#### 1. 对象创建的五步骤（以 HotSpot 为例）
1. **类加载检查和初始化**  
   - 确保类已加载、验证、准备、解析并完成初始化（执行 `<clinit>`）。  
2. **分配内存**  
   - 在 Eden 分配（新生代）或直接在老年代分配（大对象或晋升分配）。  
   - 判断三种策略：指针碰撞、空闲列表、TLAB 分配。  
3. **设置对象头**  
   - 写入 Mark Word（锁状态、hashCode、年龄等）和类型指针（指向 Klass 元数据）。  
4. **零初始化（可选优化）**  
   - 默认会归零，部分平台可以使用 `mmap` 册页映射优化。  
5. **执行构造函数**  
   - 依次执行父类构造、实例初始化块、用户构造代码。

#### 2. 内存分配策略
- **指针碰撞（Bump-Pointer）**  
  - Eden 连续空间；用一个指针指向下一个可分配地址，分配后移动指针。  
- **空闲列表（Free-List）**  
  - 区域有碎片时，用链表跟踪空闲块，分配和回收需查找合适块。  
- **TLAB（Thread-Local Allocation Buffer）**  
  - 每个 Java 线程在 Eden 中预分配一小块缓冲区（默认几百 KB）。  
  - 线程分配对象时只在自己 TLAB 内 bump-pointer，避免多线程竞争。
  - TLAB 用尽后向 Eden 申请新的 Buffer 或回退到全局分配。

#### 3. 大对象直接晋升
- **判定**：对象大小 > `PretenureSizeThreshold`（可配置），或在 Eden 内多次晋升后直接进入老年代。  
- **优化意义**：避免大对象在 新生代中多次复制，减少 GC 负担。

#### 4. 并发分配与 Cache 行对齐
- HotSpot 会为每个 TLAB 做 Cache 行或页对齐，降低 False Sharing 风险。  
- 在高并发场景下，TLAB 显著提升分配吞吐，减少锁争用。

#### 5. 面试常见追问
- 什么情况下会发生失败分配？（如老年代空间不足 → Trigger Full GC、OOM）  
- 在 G1/ZGC 下对象分配有何区别？  
- 如何调优 TLAB 大小？（`-XX:+UseTLAB`、`-XX:TLABSizeSlackPercent`、`-XX:TLABWasteTargetPercent`）

### 小结/提示词
- **步骤**：加载→分配（Eden/老年代/TLAB）→设头→归零→构造  
- **TLAB**：线程本地分配，减少竞争  
- **大对象**：直接老年代或晋升  
- 复习提示：**“TLAB 本地分配，Eden 碰撞快，老年代晋升慎”**  