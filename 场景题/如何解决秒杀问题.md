# 如何解决“秒杀”问题（详细版，面试可用）

## 一、什么是“秒杀”问题？

- “秒杀”是指在极短时间内有大量用户同时抢购极少量商品的场景，常用于电商促销。典型特点是：高并发、瞬时流量大、商品稀缺、极易出现超卖和系统崩溃。

## 二、秒杀系统面临的技术挑战

1. **高并发冲击**：短时间内成千上万请求涌入，容易导致应用服务器、数据库、缓存等资源被打爆。
2. **超卖问题**：并发下库存扣减不严谨，容易导致售出数量超过实际库存。
3. **数据一致性**：订单、库存等核心数据需保持一致、原子操作。
4. **用户体验**：高并发下仍需保证系统响应速度、不卡顿、不掉单。
5. **安全问题**：防止黄牛/脚本刷单，防止接口被恶意攻击。

---

## 三、常见技术方案

### 1. 流量削峰与限流

- **网关层限流**：如 Nginx、API Gateway、Sentinel，对流量做初步拦截，防止系统瞬间被压垮。
- **应用层限流**：令牌桶、漏桶、计数器等算法限制 QPS（每秒请求数）。
- **验证码/动态地址**：防止恶意脚本自动化攻击，提升请求门槛。
- **用户排队/抽奖机制**：让部分请求排队或随机抽签，降低瞬时并发量。

### 2. 静态化与缓存

- **页面静态化**：秒杀活动页静态化，放CDN，减少后端压力。
- **本地缓存/Redis缓存**：活动配置信息、商品库存等提前缓存在本地或Redis。
- **接口结果缓存**：对于不可变的数据结果做短时缓存（如活动是否开始、商品详情页）。

### 3. 秒杀资格/抢购资格预判

- **预热名单**：提前筛选真实用户，只有名单内用户可参与。
- **资格校验**：活动开始前做资格校验，非资格用户提前拦截。

### 4. 库存预减与原子扣减

- **Redis原子扣减**：库存预存在Redis，使用Lua脚本原子扣减库存，保证并发下库存准确。
- **防止超卖**：扣减结果＜0直接返回秒杀失败，防止超卖。
- **数据库乐观锁/悲观锁**：最终写入数据库时加乐观锁（如version字段）或悲观锁（如for update），避免并发写超卖。

### 5. 消息队列异步削峰

- **请求入队**：用户秒杀请求通过消息队列（如RabbitMQ、Kafka）异步排队，后端服务按顺序异步消费，避免直接冲击数据库。
- **异步下单**：库存校验通过后入队，生成订单异步处理，提高系统吞吐量。
- **削峰填谷**：通过消息队列缓存高并发请求，缓慢释放压力。

### 6. 下单与库存的最终一致性

- **订单创建与库存扣减分离**：可先扣Redis库存再异步下单，最终通过数据库库存写入保证一致性。
- **定期比对**：定时任务比对Redis库存和数据库实际库存，发现不一致时修正。

### 7. 防刷与安全

- **验证码**：秒杀前置验证码，阻挡机器人。
- **动态URL**：下发动态接口地址，防止提前刷接口。
- **IP/用户限速**：单IP、单用户限流。
- **黑名单机制**：发现恶意行为，自动封禁。

---

## 四、Java技术实现要点

### 1. Redis库存原子扣减

- 使用`decr`或Lua脚本保证操作原子，示例Lua脚本：
```lua
if (redis.call('get', KEYS[1]) >= tonumber(ARGV[1])) then
    return redis.call('decrby', KEYS[1], ARGV[1])
else
    return -1
end
```
- 防止并发下超卖。

### 2. 消息队列异步下单

- 用户请求通过 MQ（RabbitMQ/Kafka）入队，后台消费者异步消费，减轻数据库压力。
- 适用于高并发场景下的订单系统。

### 3. 数据库乐观锁

- 数据表增加`version`字段，更新库存时带上旧version，CAS机制防止并发写超卖。
```sql
UPDATE goods SET stock = stock - 1, version = version + 1 WHERE id = ? AND version = ?
```

### 4. 限流组件

- 如 Sentinel、Guava RateLimiter、Nginx限流等，保障接口不被刷爆。

### 5. 分布式锁（如必要）

- 多实例部署时，可用Redisson（基于Redis）或ZooKeeper做分布式锁，保证全局一致性。

### 6. 前端页面静态化/CDN

- 活动页、商品信息等非动态内容全部CDN/静态化，减少后端压力。

---

## 五、典型秒杀流程（详细分步）

1. **用户访问秒杀页面**  
   — CDN/静态页，减少后端压力。

2. **用户提交秒杀请求**  
   — 校验登录、验证码、活动时间、资格、接口限流。

3. **Redis原子扣减库存**  
   — Redis缓存原子扣减库存，库存不足立即返回失败。

4. **请求入消息队列**  
   — 扣减成功后，将订单请求写入MQ，异步处理。

5. **异步下单与数据库库存更新**  
   — 消费者从MQ取出请求，校验库存并写数据库，使用乐观锁防止并发写超卖。

6. **返回结果给用户**  
   — 秒杀成功/失败结果异步通知或查询。

7. **后续一致性校正**  
   — 定时任务比对Redis和数据库库存，修正异常数据。

---

## 六、面试角度常见追问及要点

- **为什么用Redis扣库存？为什么还要用数据库校验？**
  - Redis高性能，减轻数据库压力，但最终一致性要靠数据库保证。
- **如何保证库存不会超卖？**
  - Redis原子扣减，返回负数即失败；数据库乐观锁/悲观锁防止并发写；异步校正。
- **消息队列崩了怎么办？**
  - MQ应有持久化、重试机制，异常时可人工补偿。
- **如何防止黄牛刷单？**
  - 验证码、动态路径、接口限流、行为风控等。
- **高并发下如何保证数据一致性？**
  - 依赖原子操作、锁、最终一致性校正。
- **整个链路瓶颈在哪？如何扩展？**
  - 瓶颈通常在数据库、消息队列、带宽，可通过分库分表、集群扩容、异步处理提升性能。

---

## 七、相关参考

- [美团技术团队：秒杀系统的设计与实现](https://tech.meituan.com/2019/11/14/seckill.html)
- [京东技术：高并发秒杀系统架构实战](https://juejin.cn/post/6844904062024118286)
- [《深入浅出分布式秒杀系统架构设计》](https://segmentfault.com/a/1190000018359484)

---

**如需具体代码实现，可再补充！建议结合Redis、MQ、数据库乐观锁实现完整流程。**