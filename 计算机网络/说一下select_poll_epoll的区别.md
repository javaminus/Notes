> 都是操作系统级别的I/O多路复用机制，用于实现NIO中Selector的功能。
> select：
> 最早的多路复用API，单次最多能处理1024个连接。
> 需要每次遍历所有fd，效率较低。
> poll：
> 改进版select，无数量限制，遍历效率仍低。
> epoll：
> Linux专有，支持超大连接数（百万级），事件驱动，无需遍历所有fd，效率高。
> 关系：NIO的Selector在不同操作系统上通过JNI调用这些API。
>
> **fd** 指的是 **文件描述符（File Descriptor）** 

`select`、`poll`、`epoll` 是 Linux 中实现 I/O 多路复用的三种机制，它们的主要作用是：**在单线程中同时监听多个文件描述符的 I/O 状态变化**，如是否可读/可写。它们的区别可以从以下几个方面说清楚：

---

### 1. **接口及数据结构**
| 机制     | 接口特点                                               |
|----------|--------------------------------------------------------|
| select   | 使用固定大小的 **位图数组**，如 `fd_set`，有最大 fd 数限制（通常是 1024） |
| poll     | 使用 **线性数组**（`pollfd` 数组），没有 fd 数量限制，但遍历效率低     |
| epoll    | 使用 **事件驱动**机制和回调函数，内核维护一个 **红黑树+就绪队列**    |

---

### 2. **性能差异**
| 机制     | 描述                                                   |
|----------|--------------------------------------------------------|
| select   | 每次调用都要把 fd 集合从用户态拷贝到内核态（**内存拷贝开销大**）        |
| poll     | 同样需要每次传入整个 `pollfd` 数组（**重复遍历，开销大**）               |
| epoll    | fd 一次注册即可，事件触发后通知（**无须重复传递fd，效率高**）             |

---

### 3. **工作方式**
| 机制     | 描述                                           |
|----------|------------------------------------------------|
| select   | **水平触发**：只要 fd 还就绪，每次都返回         |
| poll     | **水平触发**：同上                             |
| epoll    | 支持 **水平触发** 和 **边缘触发**（效率更高）    |

---

### 4. **适用场景**
| 机制     | 适用情况                                           |
|----------|--------------------------------------------------|
| select   | 连接数较少，跨平台时兼容性较好                      |
| poll     | 连接数较多但变化不大，且不需频繁触发                 |
| epoll    | 连接数极多（如 1万+），高并发服务器首选（如 Nginx）  |

---

### 总结口诀（便于记忆）：
> **select 有限，poll 线性，epoll 高效事件驱动；水平触发旧，边缘触发新。**

---

需要更深入讲解哪个部分吗？比如 `epoll` 的具体使用流程，或者三者的源码实现？

## select、poll、epoll——面试官常问深入问题与参考答案

---

### 1. 为什么 select 有最大 fd 数限制？epoll 为什么没有？

**参考答案：**  
select 使用的是定长的位图数组（fd_set）来存储文件描述符，每个位对应一个 fd，数组大小通常为 1024（可通过宏 FD_SETSIZE 修改），超出会报错。epoll 采用了内核维护的红黑树管理 fd，理论上只受限于系统最大文件描述符数，无此限制。

---

### 2. epoll 的边缘触发（ET）和水平触发（LT）有何区别？实际应用如何选择？

**参考答案：**  
水平触发（LT）模式下，只要 fd 就绪每次都会被 epoll 返回，适合大多数应用，易于编程。边缘触发（ET）仅在状态变化时通知（如由不可读变可读），效率高但对编程要求高，需一次性读完缓冲区数据，否则可能丢失事件。实际高性能服务器常用 ET 结合非阻塞 I/O 提升性能。


> 通俗例子讲解：
>
> 当然可以！下面用一个**通俗生活中的例子**来解释 epoll 的**水平触发（LT）**和**边缘触发（ET）**：
>
> ---
>
> ## 举个例子：收快递
>
> 假设你住在一个公寓，有一个快递柜（信箱），用来收包裹（数据），你每天都可以去查有没有新包裹。
>
> ### 1. 水平触发（LT）——“只要有包裹就会提醒你”
>
> - 快递柜系统设计成：**只要柜子里有包裹，每天都会给你发一条提醒短信**。
> - 你今天去取了一个包裹，但柜子里还有另一个没拿走，明天还会再收到提醒。
> - 只有当柜子里没有包裹了，系统才不会再提醒。
>
> **特点：**
> - 有包裹就一直提醒你，不断打扰，直到你拿完为止。
> - 适合“马虎大意”的人，拿不完也不会漏掉。
>
> ---
>
> ### 2. 边缘触发（ET）——“只有新包裹放进来时提醒你一次”
>
> - 快递柜系统变聪明了：**只有新包裹刚被放进柜子时，才发一条提醒短信**。
> - 你收到短信后，去柜子取了一部分包裹，还有一些没拿走，**系统不会再提醒你**。
> - 只有下次有新包裹进来，才会再提醒你。
>
> **特点：**
> - 有新变化才提醒一次，如果你没把包裹一次拿完，之后就不会再提醒，可能漏掉。
> - 适合“细心勤快”的人，每次都要把所有包裹都拿走。
>
> ---
>
> ## 总结
>
> - **LT（水平触发）**：只要柜子里有包裹就一直提醒你（一直通知你可以读取），拿一次、拿不完都没事，下次还会提醒。
> - **ET（边缘触发）**：只有新包裹放进来才提醒你一次（只通知状态变化），你必须一次性拿完所有包裹，否则之后不会再有提醒，容易漏掉。
>
> ---
>
> 如果你想要看到代码中的形象例子，也可以告诉我！

---

### 3. epoll 为什么比 select/poll 性能更高？原理是什么？

**参考答案：**  
epoll 采用回调/事件驱动机制，用户只需在 fd 状态变化时被通知，避免了每次都遍历全部 fd。内核通过红黑树高效管理 fd，并将就绪事件压入就绪队列，用户直接读取就绪列表，极大减少无效遍历和内存拷贝，尤其适合大并发场景。

---

### 4. epoll 的具体使用流程是怎样的？需要注意哪些细节？

**参考答案：**  
典型流程为：  
- epoll_create 创建 epoll 实例  
- epoll_ctl 注册/修改/删除 fd 及要监听的事件  
- epoll_wait 等待事件发生，返回所有就绪 fd  
  注意事项包括：fd 必须设置为非阻塞（尤其是边缘触发时），每次都要把缓冲区数据读/写完，避免丢事件。

---

### 5. select/poll/epoll 哪些是跨平台的？在实际开发中如何选择？

**参考答案：**  
select 和 poll 属于 POSIX 标准，基本所有类 Unix 系统都支持，兼容性强，适合简单或跨平台需求。epoll 只在 Linux 下有，适合高并发 Linux 服务器。开发时根据实际需求和平台选择，性能优先时选 epoll。

---

### 6. 为什么高并发服务器推荐 epoll？Nginx 内部是如何用 epoll 的？

**参考答案：**  
epoll 能高效处理数万甚至更多的并发连接，内存和 CPU 开销小，极适合高并发网络服务器。Nginx 在 Linux 下用 epoll 事件驱动模型，主进程调度事件，worker 进程异步处理请求，大幅提升并发能力和吞吐量。

---

### 7. 说说 select、poll、epoll 的缺点和局限？

**参考答案：**  
select：fd 数量有限制，内存和 CPU 开销大，效率低。  
poll：无 fd 限制，但每次都需遍历所有 fd，效率依旧低下。  
epoll：仅限 Linux，接口复杂，易用性和可移植性不如 select/poll。边缘触发下容易因编程失误丢事件。
