# 数据库逻辑删除后的唯一性约束方案

假设有一张服务开通记录表 service_record，主要字段如下：

| 字段         | 类型    | 是否可空 |
| ------------ | ------- | -------- |
| id           | long    | 否       |
| gmt_create   | date    | 否       |
| gmt_modified | date    | 否       |
| telephone    | varchar | 否       |
| product_code | varchar | 否       |
| state        | varchar | 否       |

当用户退出服务时，通常采用**逻辑删除**（如添加 `is_deleted` 字段），而不是物理删除，以便后续做数据分析和报表。

## 问题场景

- 如何在有逻辑删除字段的情况下，保证用户并发开通时不会插入多条记录？
- 如何设计唯一性约束？如果只是 `telephone + product_code`，则无法支持用户多次开通和退出。

---

## 四种典型解决方案

### 方案一：物理删除 + 数据归档

- 直接物理删除主表数据，归档到历史表（如 `service_record_his`）或离线数仓。
- 用户退出时，将主表记录插入历史表后删除主表数据，保证主表唯一性约束成立。
- 数据分析和报表基于历史表或数仓。
- 业务上可限制当日不能再次开通或退出，归档同步采用定时任务（如每天凌晨）。

**优缺点：**
- 优点：主表唯一性约束天然成立，查询高效。
- 缺点：归档逻辑复杂，恢复/查询历史需两表或数仓联查。

---

### 方案二：复用一条开通记录 + 记录开通流水

- 主表每个用户+产品只保留一条记录，使用状态字段表示状态（如 ACTIVE/QUIT）。
- 用户开通、退出都更新主表记录状态，所有操作写入流水表（如 `service_record_stream`）。
- 数据分析基于流水表完成。

**优缺点：**
- 优点：主表数据简洁，唯一性约束易实现，历史操作可追溯。
- 缺点：流水表逻辑复杂，依赖业务实现，恢复历史状态需查流水表。

---

### 方案三：`>0`都表示逻辑删除

- `is_deleted` 字段默认为 0（未删除），每次删除后递增（如 1、2、3...），或直接赋值为主键 id。
- 这样 `user_id + product_code + is_deleted` 可做联合唯一索引，允许多次逻辑删除和开通。
- 是否被删除通过 `is_deleted` 是否为 0 判断。

**优缺点：**
- 优点：实现简单，唯一性约束可行。
- 缺点：字段语义变复杂，仍需注意并发和唯一性兜底。

---

### 方案四：引入一个新的字段

- 增加辅助字段（如 `deleted_time`），联合 `user_id + product_code + is_deleted + deleted_time` 做唯一索引。
- 或者用 `deleted_time` 是否为空判断逻辑删除，无需单独 `is_deleted` 字段。

**优缺点：**
- 优点：唯一性约束灵活，历史信息可保留。
- 缺点：字段设计更复杂，业务代码需维护字段变更，维护成本高。

---

## 总结

- **物理删除+归档**：唯一性约束天然成立，适合不常查历史场景。
- **主表复用+流水表**：适合强追溯需求，主表唯一性约束易实现。
- **is_deleted递增**：便于逻辑删除和唯一性约束，适合简单场景。
- **新增辅助字段**：最灵活但设计复杂，适合业务多变和高并发场景。

实际选型需结合业务需求、数据分析、唯一性约束、维护复杂度等因素综合考虑。很多项目会多方案组合使用，如“历史表+流水表+数仓”，“流水表+>0逻辑删除”等。