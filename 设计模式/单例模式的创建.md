单例模式（Singleton Pattern）是指**一个类只允许创建一个实例**，并提供一个全局访问点。以下是Java中常见的单例实现方式：

---

### 1. 饿汉式（Eager Initialization）

```java
public class Singleton {
    private static final Singleton instance = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
        return instance;
    }
}
```
**优点**：线程安全，写法简单  
**缺点**：类加载时就实例化，资源浪费

---

### 2. 懒汉式（Lazy Initialization，线程不安全）

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```
**优点**：用到时才创建实例  
**缺点**：线程不安全

---

### 3. 懒汉式（线程安全，加锁）

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```
**优点**：线程安全  
**缺点**：加锁影响性能

- 每次调用`getInstance()`方法时**都要加锁**（即使对象已经创建好）。
- **加锁（synchronized）是重量级操作**，会影响性能，尤其是在并发量大的时候。
- 只有第一次创建实例时需要同步，后面没必要，结果每次都加锁，浪费了性能。

---

### 4. 双重检查锁（DCL，推荐）

```java
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```
**优点**：线程安全，性能好  
**缺点**：代码稍复杂

- **只在第一次需要创建实例时加锁**，后续大部分情况下（instance已存在）都**不会进入synchronized块**，即不会加锁。
- 这样，**只有极少数情况下需要同步**，绝大多数时候直接返回实例，性能大大提升。

 

---

### 5. 静态内部类（推荐）

```java
public class Singleton {
    private Singleton() {}

    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}
```
**优点**：懒加载，线程安全，效率高

> 静态内部类和饿汉式的区别：饿汉式是无论类有没有使用，都会被加载；而静态内部类是在第一次使用的时候才加载。

---

### 6. 枚举实现（最安全，推荐）

```java
public enum Singleton {
    INSTANCE;

    private int value;

    public void setValue(int value) {
        this.value = value;
    }
    public int getValue() {
        return value;
    }
}

Singleton.INSTANCE.setValue(100);
System.out.println(Singleton.INSTANCE.getValue());
```
**优点**：

- `enum`方式天生只会创建一个实例，且由JVM保证线程安全和反序列化安全。
- 枚举单例可以防止反射攻击和序列化漏洞，是最推荐的单例实现方式。

> ## 1. 枚举单例的优势
>
> ### （1）防止反射攻击
>
> - 普通饿汉式单例可以用反射（通过`Constructor#setAccessible(true)`）绕过私有构造方法，创建多个实例，**破坏单例**。
> - 枚举在JVM层面限制了通过反射创建枚举实例，一旦尝试会抛异常，**天然防御反射攻击**。
>
> ### （2）防止反序列化破坏
>
> - 普通单例在序列化和反序列化时，如果没有正确实现`readResolve()`，会产生新的对象，**破坏单例**。
> - 枚举单例天生支持序列化和反序列化，JVM保证只会有一个实例。
>
> ### （3）代码更简洁、表达更明确
>
> - 写法简单、无歧义、不容易出错。
> - 没有懒汉式、DCL等复杂性，也没有饿汉式的“看起来想防御但其实还不够”的情况。

